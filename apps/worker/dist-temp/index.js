// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = import.meta.require;

// ../../node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream;
  var util = __require("util");
  module.exports = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this;
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {});
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach(function(args) {
      this.emit.apply(this, args);
    }.bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message));
  };
});

// ../../node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS((exports, module) => {
  var util = __require("util");
  var Stream = __require("stream").Stream;
  var DelayedStream = require_delayed_stream();
  module.exports = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this;
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this));
        stream = newStream;
      }
      this._handleErrors(stream);
      if (this.pauseStreams) {
        stream.pause();
      }
    }
    this._streams.push(stream);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == "undefined") {
      this.end();
      return;
    }
    if (typeof stream !== "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        stream2.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream2);
      }
      this._pipeNext(stream2);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this));
      stream.pipe(this, { end: false });
      return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream) {
    var self2 = this;
    stream.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data) {
    this.emit("data", data);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
      this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
      this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream) {
      if (!stream.dataSize) {
        return;
      }
      self2.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
});

// ../../node_modules/form-data/node_modules/mime-types/node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// ../../node_modules/form-data/node_modules/mime-types/node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// ../../node_modules/form-data/node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var extname = __require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0;i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db[types[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  }
});

// ../../node_modules/asynckit/lib/defer.js
var require_defer = __commonJS((exports, module) => {
  module.exports = defer;
  function defer(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick) {
      nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
});

// ../../node_modules/asynckit/lib/async.js
var require_async = __commonJS((exports, module) => {
  var defer = require_defer();
  module.exports = async;
  function async(callback) {
    var isAsync = false;
    defer(function() {
      isAsync = true;
    });
    return function async_callback(err, result) {
      if (isAsync) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
});

// ../../node_modules/asynckit/lib/abort.js
var require_abort = __commonJS((exports, module) => {
  module.exports = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    state.jobs = {};
  }
  function clean(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  }
});

// ../../node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS((exports, module) => {
  var async = require_async();
  var abort = require_abort();
  module.exports = iterate;
  function iterate(list, iterator2, state, callback) {
    var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
    state.jobs[key] = runJob(iterator2, key, list[key], function(error, output) {
      if (!(key in state.jobs)) {
        return;
      }
      delete state.jobs[key];
      if (error) {
        abort(state);
      } else {
        state.results[key] = output;
      }
      callback(error, state.results);
    });
  }
  function runJob(iterator2, key, item, callback) {
    var aborter;
    if (iterator2.length == 2) {
      aborter = iterator2(item, async(callback));
    } else {
      aborter = iterator2(item, key, async(callback));
    }
    return aborter;
  }
});

// ../../node_modules/asynckit/lib/state.js
var require_state = __commonJS((exports, module) => {
  module.exports = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  }
});

// ../../node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS((exports, module) => {
  var abort = require_abort();
  var async = require_async();
  module.exports = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async(callback)(null, this.results);
  }
});

// ../../node_modules/asynckit/parallel.js
var require_parallel = __commonJS((exports, module) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = parallel;
  function parallel(list, iterator2, callback) {
    var state = initState(list);
    while (state.index < (state["keyedList"] || list).length) {
      iterate(list, iterator2, state, function(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      });
      state.index++;
    }
    return terminator.bind(state, callback);
  }
});

// ../../node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS((exports, module) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = serialOrdered;
  module.exports.ascending = ascending;
  module.exports.descending = descending;
  function serialOrdered(list, iterator2, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator2, state, function iteratorHandler(error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      state.index++;
      if (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator2, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    });
    return terminator.bind(state, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
});

// ../../node_modules/asynckit/serial.js
var require_serial = __commonJS((exports, module) => {
  var serialOrdered = require_serialOrdered();
  module.exports = serial;
  function serial(list, iterator2, callback) {
    return serialOrdered(list, iterator2, null, callback);
  }
});

// ../../node_modules/asynckit/index.js
var require_asynckit = __commonJS((exports, module) => {
  module.exports = {
    parallel: require_parallel(),
    serial: require_serial(),
    serialOrdered: require_serialOrdered()
  };
});

// ../../node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS((exports, module) => {
  module.exports = Object;
});

// ../../node_modules/es-errors/index.js
var require_es_errors = __commonJS((exports, module) => {
  module.exports = Error;
});

// ../../node_modules/es-errors/eval.js
var require_eval = __commonJS((exports, module) => {
  module.exports = EvalError;
});

// ../../node_modules/es-errors/range.js
var require_range = __commonJS((exports, module) => {
  module.exports = RangeError;
});

// ../../node_modules/es-errors/ref.js
var require_ref = __commonJS((exports, module) => {
  module.exports = ReferenceError;
});

// ../../node_modules/es-errors/syntax.js
var require_syntax = __commonJS((exports, module) => {
  module.exports = SyntaxError;
});

// ../../node_modules/es-errors/type.js
var require_type = __commonJS((exports, module) => {
  module.exports = TypeError;
});

// ../../node_modules/es-errors/uri.js
var require_uri = __commonJS((exports, module) => {
  module.exports = URIError;
});

// ../../node_modules/math-intrinsics/abs.js
var require_abs = __commonJS((exports, module) => {
  module.exports = Math.abs;
});

// ../../node_modules/math-intrinsics/floor.js
var require_floor = __commonJS((exports, module) => {
  module.exports = Math.floor;
});

// ../../node_modules/math-intrinsics/max.js
var require_max = __commonJS((exports, module) => {
  module.exports = Math.max;
});

// ../../node_modules/math-intrinsics/min.js
var require_min = __commonJS((exports, module) => {
  module.exports = Math.min;
});

// ../../node_modules/math-intrinsics/pow.js
var require_pow = __commonJS((exports, module) => {
  module.exports = Math.pow;
});

// ../../node_modules/math-intrinsics/round.js
var require_round = __commonJS((exports, module) => {
  module.exports = Math.round;
});

// ../../node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS((exports, module) => {
  module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
  };
});

// ../../node_modules/math-intrinsics/sign.js
var require_sign = __commonJS((exports, module) => {
  var $isNaN = require_isNaN();
  module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
});

// ../../node_modules/gopd/gOPD.js
var require_gOPD = __commonJS((exports, module) => {
  module.exports = Object.getOwnPropertyDescriptor;
});

// ../../node_modules/gopd/index.js
var require_gopd = __commonJS((exports, module) => {
  var $gOPD = require_gOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  module.exports = $gOPD;
});

// ../../node_modules/es-define-property/index.js
var require_es_define_property = __commonJS((exports, module) => {
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  module.exports = $defineProperty;
});

// ../../node_modules/has-symbols/shams.js
var require_shams = __commonJS((exports, module) => {
  module.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
});

// ../../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS((exports, module) => {
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = require_shams();
  module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
});

// ../../node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
});

// ../../node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS((exports, module) => {
  var $Object = require_es_object_atoms();
  module.exports = $Object.getPrototypeOf || null;
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a, b) {
    var arr = [];
    for (var i = 0;i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0;j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0;i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0;i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {};
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
  var implementation = require_implementation();
  module.exports = Function.prototype.bind || implementation;
});

// ../../node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS((exports, module) => {
  module.exports = Function.prototype.call;
});

// ../../node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS((exports, module) => {
  module.exports = Function.prototype.apply;
});

// ../../node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
});

// ../../node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS((exports, module) => {
  var bind2 = require_function_bind();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var $reflectApply = require_reflectApply();
  module.exports = $reflectApply || bind2.call($call, $apply);
});

// ../../node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS((exports, module) => {
  var bind2 = require_function_bind();
  var $TypeError = require_type();
  var $call = require_functionCall();
  var $actualApply = require_actualApply();
  module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
});

// ../../node_modules/dunder-proto/get.js
var require_get = __commonJS((exports, module) => {
  var callBind = require_call_bind_apply_helpers();
  var gOPD = require_gopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
    return $getPrototypeOf(value == null ? value : $Object(value));
  } : false;
});

// ../../node_modules/get-proto/index.js
var require_get_proto = __commonJS((exports, module) => {
  var reflectGetProto = require_Reflect_getPrototypeOf();
  var originalGetProto = require_Object_getPrototypeOf();
  var getDunderProto = require_get();
  module.exports = reflectGetProto ? function getProto(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto(O) {
    return getDunderProto(O);
  } : null;
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = require_function_bind();
  module.exports = bind2.call(call, $hasOwn);
});

// ../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS((exports, module) => {
  var undefined2;
  var $Object = require_es_object_atoms();
  var $Error = require_es_errors();
  var $EvalError = require_eval();
  var $RangeError = require_range();
  var $ReferenceError = require_ref();
  var $SyntaxError = require_syntax();
  var $TypeError = require_type();
  var $URIError = require_uri();
  var abs = require_abs();
  var floor = require_floor();
  var max = require_max();
  var min = require_min();
  var pow = require_pow();
  var round = require_round();
  var sign = require_sign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {}
  };
  var $gOPD = require_gopd();
  var $defineProperty = require_es_define_property();
  var throwTypeError = function() {
    throw new $TypeError;
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = require_has_symbols()();
  var getProto = require_get_proto();
  var $ObjectGPO = require_Object_getPrototypeOf();
  var $ReflectGPO = require_Reflect_getPrototypeOf();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
    "%AsyncFromSyncIteratorPrototype%": undefined2,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined2,
    "%Map%": typeof Map === "undefined" ? undefined2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
    "%Symbol%": hasSymbols ? Symbol : undefined2,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs,
    "%Math.floor%": floor,
    "%Math.max%": max,
    "%Math.min%": min,
    "%Math.pow%": pow,
    "%Math.round%": round,
    "%Math.sign%": sign,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var errorProto;
  var doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = require_function_bind();
  var hasOwn = require_hasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true;i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
});

// ../../node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS((exports, module) => {
  var hasSymbols = require_shams();
  module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
  };
});

// ../../node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasToStringTag = require_shams2()();
  var hasOwn = require_hasown();
  var $TypeError = require_type();
  var toStringTag2 = hasToStringTag ? Symbol.toStringTag : null;
  module.exports = function setToStringTag(object, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
      throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
    }
    if (toStringTag2 && (overrideIfSet || !hasOwn(object, toStringTag2))) {
      if ($defineProperty) {
        $defineProperty(object, toStringTag2, {
          configurable: !nonConfigurable,
          enumerable: false,
          value,
          writable: false
        });
      } else {
        object[toStringTag2] = value;
      }
    }
  };
});

// ../../node_modules/form-data/lib/populate.js
var require_populate = __commonJS((exports, module) => {
  module.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
      dst[prop] = dst[prop] || src[prop];
    });
    return dst;
  };
});

// ../../node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS((exports, module) => {
  var CombinedStream = require_combined_stream();
  var util = __require("util");
  var path = __require("path");
  var http = __require("http");
  var https = __require("https");
  var parseUrl = __require("url").parse;
  var fs = __require("fs");
  var Stream = __require("stream").Stream;
  var mime = require_mime_types();
  var asynckit = require_asynckit();
  var setToStringTag = require_es_set_tostringtag();
  var hasOwn = require_hasown();
  var populate = require_populate();
  function FormData2(options) {
    if (!(this instanceof FormData2)) {
      return new FormData2(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  util.inherits(FormData2, CombinedStream);
  FormData2.LINE_BREAK = `\r
`;
  FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData2.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options === "string") {
      options = { filename: options };
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value === "number" || value == null) {
      value = String(value);
    }
    if (Array.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData2.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += Number(options.knownLength);
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData2.prototype._lengthRetriever = function(value, callback) {
    if (hasOwn(value, "fd")) {
      if (value.end != null && value.end != Infinity && value.start != null) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs.stat(value.path, function(err, stat) {
          if (err) {
            callback(err);
            return;
          }
          var fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (hasOwn(value, "httpVersion")) {
      callback(null, Number(value.headers["content-length"]));
    } else if (hasOwn(value, "httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, Number(response.headers["content-length"]));
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData2.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header === "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers = {
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header === "object") {
      populate(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (hasOwn(headers, prop)) {
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
    }
    return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
  };
  FormData2.prototype._getContentDisposition = function(value, options) {
    var filename;
    if (typeof options.filepath === "string") {
      filename = path.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value && (value.name || value.path)) {
      filename = path.basename(options.filename || value && (value.name || value.path));
    } else if (value && value.readable && hasOwn(value, "httpVersion")) {
      filename = path.basename(value.client._httpMessage.path || "");
    }
    if (filename) {
      return 'filename="' + filename + '"';
    }
  };
  FormData2.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && value && typeof value === "object") {
      contentType = FormData2.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData2.prototype._multiPartFooter = function() {
    return function(next) {
      var footer = FormData2.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }.bind(this);
  };
  FormData2.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
  };
  FormData2.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (hasOwn(userHeaders, header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData2.prototype.setBoundary = function(boundary) {
    if (typeof boundary !== "string") {
      throw new TypeError("FormData boundary must be a string");
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData2.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    for (var i = 0, len = this._streams.length;i < len; i++) {
      if (typeof this._streams[i] !== "function") {
        if (Buffer.isBuffer(this._streams[i])) {
          dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
        } else {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
        }
        if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
        }
      }
    }
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData2.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i = 0;i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData2.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData2.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData2.prototype.submit = function(params, cb) {
    var request;
    var options;
    var defaults = { method: "post" };
    if (typeof params === "string") {
      params = parseUrl(params);
      options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults);
    } else {
      options = populate(params, defaults);
      if (!options.port) {
        options.port = options.protocol === "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol === "https:") {
      request = https.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength(function(err, length) {
      if (err && err !== "Unknown stream") {
        this._error(err);
        return;
      }
      if (length) {
        request.setHeader("Content-Length", length);
      }
      this.pipe(request);
      if (cb) {
        var onResponse;
        var callback = function(error, responce) {
          request.removeListener("error", callback);
          request.removeListener("response", onResponse);
          return cb.call(this, error, responce);
        };
        onResponse = callback.bind(this, null);
        request.on("error", callback);
        request.on("response", onResponse);
      }
    }.bind(this));
    return request;
  };
  FormData2.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData2.prototype.toString = function() {
    return "[object FormData]";
  };
  setToStringTag(FormData2, "FormData");
  module.exports = FormData2;
});

// ../../node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS((exports) => {
  var parseUrl = __require("url").parse;
  var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
  };
  function getProxyForUrl(url2) {
    var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
      return "";
    }
    proto = proto.split(":", 1)[0];
    hostname = hostname.replace(/:\d*$/, "");
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
      return "";
    }
    var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
    if (proxy && proxy.indexOf("://") === -1) {
      proxy = proto + "://" + proxy;
    }
    return proxy;
  }
  function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
    if (!NO_PROXY) {
      return true;
    }
    if (NO_PROXY === "*") {
      return false;
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
      if (!proxy) {
        return true;
      }
      var parsedProxy = proxy.match(/^(.+):(\d+)$/);
      var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
      var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
      if (parsedProxyPort && parsedProxyPort !== port) {
        return true;
      }
      if (!/^[.*]/.test(parsedProxyHostname)) {
        return hostname !== parsedProxyHostname;
      }
      if (parsedProxyHostname.charAt(0) === "*") {
        parsedProxyHostname = parsedProxyHostname.slice(1);
      }
      return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
  }
  function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
  }
  exports.getProxyForUrl = getProxyForUrl;
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip2 of createDebug.skips) {
        if (matchesTemplate(name, skip2)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// ../../node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// ../../node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// ../../node_modules/follow-redirects/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug;
  module.exports = function() {
    if (!debug) {
      try {
        debug = require_src()("follow-redirects");
      } catch (error) {}
      if (typeof debug !== "function") {
        debug = function() {};
      }
    }
    debug.apply(null, arguments);
  };
});

// ../../node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS((exports, module) => {
  var url2 = __require("url");
  var URL2 = url2.URL;
  var http = __require("http");
  var https = __require("https");
  var Writable = __require("stream").Writable;
  var assert = __require("assert");
  var debug = require_debug();
  (function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction2(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
      console.warn("The follow-redirects package should be excluded from browser builds.");
    }
  })();
  var useNativeURL = false;
  try {
    assert(new URL2(""));
  } catch (error) {
    useNativeURL = error.code === "ERR_INVALID_URL";
  }
  var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
  ];
  var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
  var eventHandlers = Object.create(null);
  events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
  var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
  var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
  var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
  var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  var destroy = Writable.prototype.destroy || noop2;
  function RedirectableRequest(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response) {
      try {
        self2._processResponse(response);
      } catch (cause) {
        self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
      }
    };
    this._performRequest();
  }
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
  };
  RedirectableRequest.prototype.destroy = function(error) {
    destroyRequest(this._currentRequest, error);
    destroy.call(this, error);
    return this;
  };
  RedirectableRequest.prototype.write = function(data, encoding, callback) {
    if (this._ending) {
      throw new WriteAfterEndError;
    }
    if (!isString2(data) && !isBuffer2(data)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (data.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data.length;
      this._requestBodyBuffers.push({ data, encoding });
      this._currentRequest.write(data, encoding, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError);
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data, encoding, callback) {
    if (isFunction2(data)) {
      callback = data;
      data = encoding = null;
    } else if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (!data) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data, encoding, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self2 = this;
    function destroyOnTimeout(socket) {
      socket.setTimeout(msecs);
      socket.removeListener("timeout", socket.destroy);
      socket.addListener("timeout", socket.destroy);
    }
    function startTimer(socket) {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
      }
      self2._timeout = setTimeout(function() {
        self2.emit("timeout");
        clearTimer();
      }, msecs);
      destroyOnTimeout(socket);
    }
    function clearTimer() {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
        self2._timeout = null;
      }
      self2.removeListener("abort", clearTimer);
      self2.removeListener("error", clearTimer);
      self2.removeListener("response", clearTimer);
      self2.removeListener("close", clearTimer);
      if (callback) {
        self2.removeListener("timeout", callback);
      }
      if (!self2.socket) {
        self2._currentRequest.removeListener("socket", startTimer);
      }
    }
    if (callback) {
      this.on("timeout", callback);
    }
    if (this.socket) {
      startTimer(this.socket);
    } else {
      this._currentRequest.once("socket", startTimer);
    }
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
  };
  [
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
      return this._currentRequest[method](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
      get: function() {
        return this._currentRequest[property];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
      throw new TypeError("Unsupported protocol " + protocol);
    }
    if (this._options.agents) {
      var scheme = protocol.slice(0, -1);
      this._options.agent = this._options.agents[scheme];
    }
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events) {
      request.on(event, eventHandlers[event]);
    }
    this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : this._options.path;
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers = this._requestBodyBuffers;
      (function writeNext(error) {
        if (request === self2._currentRequest) {
          if (error) {
            self2.emit("error", error);
          } else if (i < buffers.length) {
            var buffer = buffers[i++];
            if (!request.finished) {
              request.write(buffer.data, buffer.encoding, writeNext);
            }
          } else if (self2._ended) {
            request.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response) {
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response.headers,
        statusCode
      });
    }
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
      response.responseUrl = this._currentUrl;
      response.redirects = this._redirects;
      this.emit("response", response);
      this._requestBodyBuffers = [];
      return;
    }
    destroyRequest(this._currentRequest);
    response.destroy();
    if (++this._redirectCount > this._options.maxRedirects) {
      throw new TooManyRedirectsError;
    }
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
      requestHeaders = Object.assign({
        Host: response.req.getHeader("host")
      }, this._options.headers);
    }
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
      removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    if (isFunction2(beforeRedirect)) {
      var responseDetails = {
        headers: response.headers,
        statusCode
      };
      var requestDetails = {
        url: currentUrl,
        method,
        headers: requestHeaders
      };
      beforeRedirect(this._options, responseDetails, requestDetails);
      this._sanitizeOptions(this._options);
    }
    this._performRequest();
  };
  function wrap(protocols) {
    var exports2 = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
      var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
      function request(input, options, callback) {
        if (isURL(input)) {
          input = spreadUrlObject(input);
        } else if (isString2(input)) {
          input = spreadUrlObject(parseUrl(input));
        } else {
          callback = options;
          options = validateUrl(input);
          input = { protocol };
        }
        if (isFunction2(options)) {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports2.maxRedirects,
          maxBodyLength: exports2.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        if (!isString2(options.host) && !isString2(options.hostname)) {
          options.hostname = "::1";
        }
        assert.equal(options.protocol, protocol, "protocol mismatch");
        debug("options", options);
        return new RedirectableRequest(options, callback);
      }
      function get(input, options, callback) {
        var wrappedRequest = wrappedProtocol.request(input, options, callback);
        wrappedRequest.end();
        return wrappedRequest;
      }
      Object.defineProperties(wrappedProtocol, {
        request: { value: request, configurable: true, enumerable: true, writable: true },
        get: { value: get, configurable: true, enumerable: true, writable: true }
      });
    });
    return exports2;
  }
  function noop2() {}
  function parseUrl(input) {
    var parsed;
    if (useNativeURL) {
      parsed = new URL2(input);
    } else {
      parsed = validateUrl(url2.parse(input));
      if (!isString2(parsed.protocol)) {
        throw new InvalidUrlError({ input });
      }
    }
    return parsed;
  }
  function resolveUrl(relative, base) {
    return useNativeURL ? new URL2(relative, base) : parseUrl(url2.resolve(base, relative));
  }
  function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    return input;
  }
  function spreadUrlObject(urlObject, target) {
    var spread = target || {};
    for (var key of preservedUrlFields) {
      spread[key] = urlObject[key];
    }
    if (spread.hostname.startsWith("[")) {
      spread.hostname = spread.hostname.slice(1, -1);
    }
    if (spread.port !== "") {
      spread.port = Number(spread.port);
    }
    spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
    return spread;
  }
  function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for (var header in headers) {
      if (regex.test(header)) {
        lastValue = headers[header];
        delete headers[header];
      }
    }
    return lastValue === null || typeof lastValue === "undefined" ? undefined : String(lastValue).trim();
  }
  function createErrorType(code, message, baseClass) {
    function CustomError(properties) {
      if (isFunction2(Error.captureStackTrace)) {
        Error.captureStackTrace(this, this.constructor);
      }
      Object.assign(this, properties || {});
      this.code = code;
      this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    CustomError.prototype = new (baseClass || Error);
    Object.defineProperties(CustomError.prototype, {
      constructor: {
        value: CustomError,
        enumerable: false
      },
      name: {
        value: "Error [" + code + "]",
        enumerable: false
      }
    });
    return CustomError;
  }
  function destroyRequest(request, error) {
    for (var event of events) {
      request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop2);
    request.destroy(error);
  }
  function isSubdomain(subdomain, domain) {
    assert(isString2(subdomain) && isString2(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
  }
  function isString2(value) {
    return typeof value === "string" || value instanceof String;
  }
  function isFunction2(value) {
    return typeof value === "function";
  }
  function isBuffer2(value) {
    return typeof value === "object" && "length" in value;
  }
  function isURL(value) {
    return URL2 && value instanceof URL2;
  }
  module.exports = wrap({ http, https });
  module.exports.wrap = wrap;
});

// ../../packages/db/generated/prisma/runtime/library.js
var require_library = __commonJS((exports, module) => {
  var __dirname = "/home/futabandit/the-projects/better-pogtime/packages/db/generated/prisma/runtime", __filename = "/home/futabandit/the-projects/better-pogtime/packages/db/generated/prisma/runtime/library.js";
  var bu = Object.create;
  var Vt = Object.defineProperty;
  var wu = Object.getOwnPropertyDescriptor;
  var xu = Object.getOwnPropertyNames;
  var vu = Object.getPrototypeOf;
  var Pu = Object.prototype.hasOwnProperty;
  var Oo = (e, r) => () => (e && (r = e(e = 0)), r);
  var ne = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
  var tr = (e, r) => {
    for (var t in r)
      Vt(e, t, { get: r[t], enumerable: true });
  };
  var _o = (e, r, t, n) => {
    if (r && typeof r == "object" || typeof r == "function")
      for (let i of xu(r))
        !Pu.call(e, i) && i !== t && Vt(e, i, { get: () => r[i], enumerable: !(n = wu(r, i)) || n.enumerable });
    return e;
  };
  var k = (e, r, t) => (t = e != null ? bu(vu(e)) : {}, _o(r || !e || !e.__esModule ? Vt(t, "default", { value: e, enumerable: true }) : t, e));
  var Tu = (e) => _o(Vt({}, "__esModule", { value: true }), e);
  var gi = ne((Ng, ss) => {
    ss.exports = (e, r = process.argv) => {
      let t = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = r.indexOf(t + e), i = r.indexOf("--");
      return n !== -1 && (i === -1 || n < i);
    };
  });
  var us = ne((Lg, ls) => {
    var $c = __require("os"), as = __require("tty"), de = gi(), { env: G } = process, Qe;
    de("no-color") || de("no-colors") || de("color=false") || de("color=never") ? Qe = 0 : (de("color") || de("colors") || de("color=true") || de("color=always")) && (Qe = 1);
    "FORCE_COLOR" in G && (G.FORCE_COLOR === "true" ? Qe = 1 : G.FORCE_COLOR === "false" ? Qe = 0 : Qe = G.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(G.FORCE_COLOR, 10), 3));
    function hi(e) {
      return e === 0 ? false : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 };
    }
    function yi(e, r) {
      if (Qe === 0)
        return 0;
      if (de("color=16m") || de("color=full") || de("color=truecolor"))
        return 3;
      if (de("color=256"))
        return 2;
      if (e && !r && Qe === undefined)
        return 0;
      let t = Qe || 0;
      if (G.TERM === "dumb")
        return t;
      if (process.platform === "win32") {
        let n = $c.release().split(".");
        return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? Number(n[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in G)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n) => (n in G)) || G.CI_NAME === "codeship" ? 1 : t;
      if ("TEAMCITY_VERSION" in G)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(G.TEAMCITY_VERSION) ? 1 : 0;
      if (G.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in G) {
        let n = parseInt((G.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (G.TERM_PROGRAM) {
          case "iTerm.app":
            return n >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(G.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(G.TERM) || ("COLORTERM" in G) ? 1 : t;
    }
    function qc(e) {
      let r = yi(e, e && e.isTTY);
      return hi(r);
    }
    ls.exports = { supportsColor: qc, stdout: hi(yi(true, as.isatty(1))), stderr: hi(yi(true, as.isatty(2))) };
  });
  var ds = ne((Fg, ps) => {
    var jc = us(), Er = gi();
    function cs(e) {
      if (/^\d{3,4}$/.test(e)) {
        let t = /(\d{1,2})(\d{2})/.exec(e) || [];
        return { major: 0, minor: parseInt(t[1], 10), patch: parseInt(t[2], 10) };
      }
      let r = (e || "").split(".").map((t) => parseInt(t, 10));
      return { major: r[0], minor: r[1], patch: r[2] };
    }
    function Ei(e) {
      let { CI: r, FORCE_HYPERLINK: t, NETLIFY: n, TEAMCITY_VERSION: i, TERM_PROGRAM: o, TERM_PROGRAM_VERSION: s, VTE_VERSION: a, TERM: l } = process.env;
      if (t)
        return !(t.length > 0 && parseInt(t, 10) === 0);
      if (Er("no-hyperlink") || Er("no-hyperlinks") || Er("hyperlink=false") || Er("hyperlink=never"))
        return false;
      if (Er("hyperlink=true") || Er("hyperlink=always") || n)
        return true;
      if (!jc.supportsColor(e) || e && !e.isTTY)
        return false;
      if ("WT_SESSION" in process.env)
        return true;
      if (process.platform === "win32" || r || i)
        return false;
      if (o) {
        let u = cs(s || "");
        switch (o) {
          case "iTerm.app":
            return u.major === 3 ? u.minor >= 1 : u.major > 3;
          case "WezTerm":
            return u.major >= 20200620;
          case "vscode":
            return u.major > 1 || u.major === 1 && u.minor >= 72;
          case "ghostty":
            return true;
        }
      }
      if (a) {
        if (a === "0.50.0")
          return false;
        let u = cs(a);
        return u.major > 0 || u.minor >= 50;
      }
      switch (l) {
        case "alacritty":
          return true;
      }
      return false;
    }
    ps.exports = { supportsHyperlink: Ei, stdout: Ei(process.stdout), stderr: Ei(process.stderr) };
  });
  var ms = ne((Kg, Vc) => {
    Vc.exports = { name: "@prisma/internals", version: "6.11.1", description: "This package is intended for Prisma's internal use", main: "dist/index.js", types: "dist/index.d.ts", repository: { type: "git", url: "https://github.com/prisma/prisma.git", directory: "packages/internals" }, homepage: "https://www.prisma.io", author: "Tim Suchanek <suchanek@prisma.io>", bugs: "https://github.com/prisma/prisma/issues", license: "Apache-2.0", scripts: { dev: "DEV=true tsx helpers/build.ts", build: "tsx helpers/build.ts", test: "dotenv -e ../../.db.env -- jest --silent", prepublishOnly: "pnpm run build" }, files: ["README.md", "dist", "!**/libquery_engine*", "!dist/get-generators/engines/*", "scripts"], devDependencies: { "@babel/helper-validator-identifier": "7.25.9", "@opentelemetry/api": "1.9.0", "@swc/core": "1.11.5", "@swc/jest": "0.2.37", "@types/babel__helper-validator-identifier": "7.15.2", "@types/jest": "29.5.14", "@types/node": "18.19.76", "@types/resolve": "1.20.6", archiver: "6.0.2", "checkpoint-client": "1.1.33", "cli-truncate": "4.0.0", dotenv: "16.5.0", esbuild: "0.25.1", "escape-string-regexp": "5.0.0", execa: "5.1.1", "fast-glob": "3.3.3", "find-up": "7.0.0", "fp-ts": "2.16.9", "fs-extra": "11.3.0", "fs-jetpack": "5.1.0", "global-dirs": "4.0.0", globby: "11.1.0", "identifier-regex": "1.0.0", "indent-string": "4.0.0", "is-windows": "1.0.2", "is-wsl": "3.1.0", jest: "29.7.0", "jest-junit": "16.0.0", kleur: "4.1.5", "mock-stdin": "1.0.0", "new-github-issue-url": "0.2.1", "node-fetch": "3.3.2", "npm-packlist": "5.1.3", open: "7.4.2", "p-map": "4.0.0", "read-package-up": "11.0.0", resolve: "1.22.10", "string-width": "7.2.0", "strip-ansi": "6.0.1", "strip-indent": "4.0.0", "temp-dir": "2.0.0", tempy: "1.0.1", "terminal-link": "4.0.0", tmp: "0.2.3", "ts-node": "10.9.2", "ts-pattern": "5.6.2", "ts-toolbelt": "9.6.0", typescript: "5.4.5", yarn: "1.22.22" }, dependencies: { "@prisma/config": "workspace:*", "@prisma/debug": "workspace:*", "@prisma/dmmf": "workspace:*", "@prisma/driver-adapter-utils": "workspace:*", "@prisma/engines": "workspace:*", "@prisma/fetch-engine": "workspace:*", "@prisma/generator": "workspace:*", "@prisma/generator-helper": "workspace:*", "@prisma/get-platform": "workspace:*", "@prisma/prisma-schema-wasm": "6.11.1-1.f40f79ec31188888a2e33acda0ecc8fd10a853a9", "@prisma/schema-engine-wasm": "6.11.1-1.f40f79ec31188888a2e33acda0ecc8fd10a853a9", "@prisma/schema-files-loader": "workspace:*", arg: "5.0.2", prompts: "2.4.2" }, peerDependencies: { typescript: ">=5.1.0" }, peerDependenciesMeta: { typescript: { optional: true } }, sideEffects: false };
  });
  var xi = ne((th, Qc) => {
    Qc.exports = { name: "@prisma/engines-version", version: "6.11.1-1.f40f79ec31188888a2e33acda0ecc8fd10a853a9", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "f40f79ec31188888a2e33acda0ecc8fd10a853a9" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.19.76", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
  });
  var vi = ne((rn) => {
    Object.defineProperty(rn, "__esModule", { value: true });
    rn.enginesVersion = undefined;
    rn.enginesVersion = xi().prisma.enginesVersion;
  });
  var ys = ne((hh, hs) => {
    hs.exports = (e) => {
      let r = e.match(/^[ \t]*(?=\S)/gm);
      return r ? r.reduce((t, n) => Math.min(t, n.length), 1 / 0) : 0;
    };
  });
  var Ai = ne((bh, ws) => {
    ws.exports = (e, r = 1, t) => {
      if (t = { indent: " ", includeEmptyLines: false, ...t }, typeof e != "string")
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);
      if (typeof r != "number")
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof r}\``);
      if (typeof t.indent != "string")
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof t.indent}\``);
      if (r === 0)
        return e;
      let n = t.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return e.replace(n, t.indent.repeat(r));
    };
  });
  var Ts = ne((vh, Ps) => {
    Ps.exports = ({ onlyFirst: e = false } = {}) => {
      let r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(r, e ? undefined : "g");
    };
  });
  var Oi = ne((Ph, Ss) => {
    var rp = Ts();
    Ss.exports = (e) => typeof e == "string" ? e.replace(rp(), "") : e;
  });
  var Rs = ne((Ch, tp) => {
    tp.exports = { name: "dotenv", version: "16.5.0", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { types: "./lib/main.d.ts", require: "./lib/main.js", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", pretest: "npm run lint && npm run dts-check", test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000", "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, homepage: "https://github.com/motdotla/dotenv#readme", funding: "https://dotenvx.com", keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^18.11.3", decache: "^4.6.2", sinon: "^14.0.1", standard: "^17.0.0", "standard-version": "^9.5.0", tap: "^19.2.0", typescript: "^4.8.4" }, engines: { node: ">=12" }, browser: { fs: false } };
  });
  var Ds = ne((Ah, Ne) => {
    var Ni = __require("fs"), Li = __require("path"), np = __require("os"), ip = __require("crypto"), op = Rs(), As = op.version, sp = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function ap(e) {
      let r = {}, t = e.toString();
      t = t.replace(/\r\n?/mg, `
`);
      let n;
      for (;(n = sp.exec(t)) != null; ) {
        let i = n[1], o = n[2] || "";
        o = o.trim();
        let s = o[0];
        o = o.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (o = o.replace(/\\n/g, `
`), o = o.replace(/\\r/g, "\r")), r[i] = o;
      }
      return r;
    }
    function lp(e) {
      let r = ks(e), t = B.configDotenv({ path: r });
      if (!t.parsed) {
        let s = new Error(`MISSING_DATA: Cannot parse ${r} for an unknown reason`);
        throw s.code = "MISSING_DATA", s;
      }
      let n = Is(e).split(","), i = n.length, o;
      for (let s = 0;s < i; s++)
        try {
          let a = n[s].trim(), l = cp(t, a);
          o = B.decrypt(l.ciphertext, l.key);
          break;
        } catch (a) {
          if (s + 1 >= i)
            throw a;
        }
      return B.parse(o);
    }
    function up(e) {
      console.log(`[dotenv@${As}][WARN] ${e}`);
    }
    function it(e) {
      console.log(`[dotenv@${As}][DEBUG] ${e}`);
    }
    function Is(e) {
      return e && e.DOTENV_KEY && e.DOTENV_KEY.length > 0 ? e.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
    }
    function cp(e, r) {
      let t;
      try {
        t = new URL(r);
      } catch (a) {
        if (a.code === "ERR_INVALID_URL") {
          let l = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          throw l.code = "INVALID_DOTENV_KEY", l;
        }
        throw a;
      }
      let n = t.password;
      if (!n) {
        let a = new Error("INVALID_DOTENV_KEY: Missing key part");
        throw a.code = "INVALID_DOTENV_KEY", a;
      }
      let i = t.searchParams.get("environment");
      if (!i) {
        let a = new Error("INVALID_DOTENV_KEY: Missing environment part");
        throw a.code = "INVALID_DOTENV_KEY", a;
      }
      let o = `DOTENV_VAULT_${i.toUpperCase()}`, s = e.parsed[o];
      if (!s) {
        let a = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o} in your .env.vault file.`);
        throw a.code = "NOT_FOUND_DOTENV_ENVIRONMENT", a;
      }
      return { ciphertext: s, key: n };
    }
    function ks(e) {
      let r = null;
      if (e && e.path && e.path.length > 0)
        if (Array.isArray(e.path))
          for (let t of e.path)
            Ni.existsSync(t) && (r = t.endsWith(".vault") ? t : `${t}.vault`);
        else
          r = e.path.endsWith(".vault") ? e.path : `${e.path}.vault`;
      else
        r = Li.resolve(process.cwd(), ".env.vault");
      return Ni.existsSync(r) ? r : null;
    }
    function Cs(e) {
      return e[0] === "~" ? Li.join(np.homedir(), e.slice(1)) : e;
    }
    function pp(e) {
      !!(e && e.debug) && it("Loading env from encrypted .env.vault");
      let t = B._parseVault(e), n = process.env;
      return e && e.processEnv != null && (n = e.processEnv), B.populate(n, t, e), { parsed: t };
    }
    function dp(e) {
      let r = Li.resolve(process.cwd(), ".env"), t = "utf8", n = !!(e && e.debug);
      e && e.encoding ? t = e.encoding : n && it("No encoding is specified. UTF-8 is used by default");
      let i = [r];
      if (e && e.path)
        if (!Array.isArray(e.path))
          i = [Cs(e.path)];
        else {
          i = [];
          for (let l of e.path)
            i.push(Cs(l));
        }
      let o, s = {};
      for (let l of i)
        try {
          let u = B.parse(Ni.readFileSync(l, { encoding: t }));
          B.populate(s, u, e);
        } catch (u) {
          n && it(`Failed to load ${l} ${u.message}`), o = u;
        }
      let a = process.env;
      return e && e.processEnv != null && (a = e.processEnv), B.populate(a, s, e), o ? { parsed: s, error: o } : { parsed: s };
    }
    function mp(e) {
      if (Is(e).length === 0)
        return B.configDotenv(e);
      let r = ks(e);
      return r ? B._configVault(e) : (up(`You set DOTENV_KEY but you are missing a .env.vault file at ${r}. Did you forget to build it?`), B.configDotenv(e));
    }
    function fp(e, r) {
      let t = Buffer.from(r.slice(-64), "hex"), n = Buffer.from(e, "base64"), i = n.subarray(0, 12), o = n.subarray(-16);
      n = n.subarray(12, -16);
      try {
        let s = ip.createDecipheriv("aes-256-gcm", t, i);
        return s.setAuthTag(o), `${s.update(n)}${s.final()}`;
      } catch (s) {
        let a = s instanceof RangeError, l = s.message === "Invalid key length", u = s.message === "Unsupported state or unable to authenticate data";
        if (a || l) {
          let c = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          throw c.code = "INVALID_DOTENV_KEY", c;
        } else if (u) {
          let c = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          throw c.code = "DECRYPTION_FAILED", c;
        } else
          throw s;
      }
    }
    function gp(e, r, t = {}) {
      let n = !!(t && t.debug), i = !!(t && t.override);
      if (typeof r != "object") {
        let o = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        throw o.code = "OBJECT_REQUIRED", o;
      }
      for (let o of Object.keys(r))
        Object.prototype.hasOwnProperty.call(e, o) ? (i === true && (e[o] = r[o]), n && it(i === true ? `"${o}" is already defined and WAS overwritten` : `"${o}" is already defined and was NOT overwritten`)) : e[o] = r[o];
    }
    var B = { configDotenv: dp, _configVault: pp, _parseVault: lp, config: mp, decrypt: fp, parse: ap, populate: gp };
    Ne.exports.configDotenv = B.configDotenv;
    Ne.exports._configVault = B._configVault;
    Ne.exports._parseVault = B._parseVault;
    Ne.exports.config = B.config;
    Ne.exports.decrypt = B.decrypt;
    Ne.exports.parse = B.parse;
    Ne.exports.populate = B.populate;
    Ne.exports = B;
  });
  var Ls = ne((Nh, an) => {
    an.exports = (e = {}) => {
      let r;
      if (e.repoUrl)
        r = e.repoUrl;
      else if (e.user && e.repo)
        r = `https://github.com/${e.user}/${e.repo}`;
      else
        throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
      let t = new URL(`${r}/issues/new`), n = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
      for (let i of n) {
        let o = e[i];
        if (o !== undefined) {
          if (i === "labels" || i === "projects") {
            if (!Array.isArray(o))
              throw new TypeError(`The \`${i}\` option should be an array`);
            o = o.join(",");
          }
          t.searchParams.set(i, o);
        }
      }
      return t.toString();
    };
    an.exports.default = an.exports;
  });
  var Wi = ne((pE, ia) => {
    ia.exports = function() {
      function e(r, t, n, i, o) {
        return r < t || n < t ? r > n ? n + 1 : r + 1 : i === o ? t : t + 1;
      }
      return function(r, t) {
        if (r === t)
          return 0;
        if (r.length > t.length) {
          var n = r;
          r = t, t = n;
        }
        for (var i = r.length, o = t.length;i > 0 && r.charCodeAt(i - 1) === t.charCodeAt(o - 1); )
          i--, o--;
        for (var s = 0;s < i && r.charCodeAt(s) === t.charCodeAt(s); )
          s++;
        if (i -= s, o -= s, i === 0 || o < 3)
          return o;
        var a = 0, l, u, c, p, d, f, h, g, S, P, R, E, D = [];
        for (l = 0;l < i; l++)
          D.push(l + 1), D.push(r.charCodeAt(s + l));
        for (var me = D.length - 1;a < o - 3; )
          for (S = t.charCodeAt(s + (u = a)), P = t.charCodeAt(s + (c = a + 1)), R = t.charCodeAt(s + (p = a + 2)), E = t.charCodeAt(s + (d = a + 3)), f = a += 4, l = 0;l < me; l += 2)
            h = D[l], g = D[l + 1], u = e(h, u, c, S, g), c = e(u, c, p, P, g), p = e(c, p, d, R, g), f = e(p, d, f, E, g), D[l] = f, d = p, p = c, c = u, u = h;
        for (;a < o; )
          for (S = t.charCodeAt(s + (u = a)), f = ++a, l = 0;l < me; l += 2)
            h = D[l], D[l] = f = e(h, u, f, S, D[l + 1]), u = h;
        return f;
      };
    }();
  });
  var ua = Oo(() => {});
  var ca = Oo(() => {});
  var Bf = {};
  tr(Bf, { DMMF: () => ut, Debug: () => N, Decimal: () => ve, Extensions: () => ti, MetricsClient: () => Lr, PrismaClientInitializationError: () => T, PrismaClientKnownRequestError: () => z, PrismaClientRustPanicError: () => le, PrismaClientUnknownRequestError: () => j, PrismaClientValidationError: () => Z, Public: () => ni, Sql: () => oe, createParam: () => Ra, defineDmmfProperty: () => Oa, deserializeJsonResponse: () => Tr, deserializeRawResult: () => Zn, dmmfToRuntimeDataModel: () => Zs, empty: () => La, getPrismaClient: () => hu, getRuntime: () => Vn, join: () => Na, makeStrictEnum: () => yu, makeTypedQueryFactory: () => _a, objectEnumValues: () => Cn, raw: () => ro, serializeJsonQuery: () => Nn, skip: () => _n, sqltag: () => to, warnEnvConflicts: () => Eu, warnOnce: () => st });
  module.exports = Tu(Bf);
  var ti = {};
  tr(ti, { defineExtension: () => No, getExtensionContext: () => Lo });
  function No(e) {
    return typeof e == "function" ? e : (r) => r.$extends(e);
  }
  function Lo(e) {
    return e;
  }
  var ni = {};
  tr(ni, { validator: () => Fo });
  function Fo(...e) {
    return (r) => r;
  }
  var Bt = {};
  tr(Bt, { $: () => Vo, bgBlack: () => Nu, bgBlue: () => $u, bgCyan: () => ju, bgGreen: () => Fu, bgMagenta: () => qu, bgRed: () => Lu, bgWhite: () => Vu, bgYellow: () => Mu, black: () => ku, blue: () => nr, bold: () => W, cyan: () => De, dim: () => Ie, gray: () => Hr, green: () => qe, grey: () => _u, hidden: () => Au, inverse: () => Cu, italic: () => Ru, magenta: () => Du, red: () => ce, reset: () => Su, strikethrough: () => Iu, underline: () => Y, white: () => Ou, yellow: () => ke });
  var ii;
  var Mo;
  var $o;
  var qo;
  var jo = true;
  typeof process < "u" && ({ FORCE_COLOR: ii, NODE_DISABLE_COLORS: Mo, NO_COLOR: $o, TERM: qo } = process.env || {}, jo = process.stdout && process.stdout.isTTY);
  var Vo = { enabled: !Mo && $o == null && qo !== "dumb" && (ii != null && ii !== "0" || jo) };
  function F(e, r) {
    let t = new RegExp(`\\x1b\\[${r}m`, "g"), n = `\x1B[${e}m`, i = `\x1B[${r}m`;
    return function(o) {
      return !Vo.enabled || o == null ? o : n + (~("" + o).indexOf(i) ? o.replace(t, i + n) : o) + i;
    };
  }
  var Su = F(0, 0);
  var W = F(1, 22);
  var Ie = F(2, 22);
  var Ru = F(3, 23);
  var Y = F(4, 24);
  var Cu = F(7, 27);
  var Au = F(8, 28);
  var Iu = F(9, 29);
  var ku = F(30, 39);
  var ce = F(31, 39);
  var qe = F(32, 39);
  var ke = F(33, 39);
  var nr = F(34, 39);
  var Du = F(35, 39);
  var De = F(36, 39);
  var Ou = F(37, 39);
  var Hr = F(90, 39);
  var _u = F(90, 39);
  var Nu = F(40, 49);
  var Lu = F(41, 49);
  var Fu = F(42, 49);
  var Mu = F(43, 49);
  var $u = F(44, 49);
  var qu = F(45, 49);
  var ju = F(46, 49);
  var Vu = F(47, 49);
  var Bu = 100;
  var Bo = ["green", "yellow", "blue", "magenta", "cyan", "red"];
  var Kr = [];
  var Uo = Date.now();
  var Uu = 0;
  var oi = typeof process < "u" ? process.env : {};
  globalThis.DEBUG ??= oi.DEBUG ?? "";
  globalThis.DEBUG_COLORS ??= oi.DEBUG_COLORS ? oi.DEBUG_COLORS === "true" : true;
  var Yr = { enable(e) {
    typeof e == "string" && (globalThis.DEBUG = e);
  }, disable() {
    let e = globalThis.DEBUG;
    return globalThis.DEBUG = "", e;
  }, enabled(e) {
    let r = globalThis.DEBUG.split(",").map((i) => i.replace(/[.+?^${}()|[\]\\]/g, "\\$&")), t = r.some((i) => i === "" || i[0] === "-" ? false : e.match(RegExp(i.split("*").join(".*") + "$"))), n = r.some((i) => i === "" || i[0] !== "-" ? false : e.match(RegExp(i.slice(1).split("*").join(".*") + "$")));
    return t && !n;
  }, log: (...e) => {
    let [r, t, ...n] = e;
    (console.warn ?? console.log)(`${r} ${t}`, ...n);
  }, formatters: {} };
  function Gu(e) {
    let r = { color: Bo[Uu++ % Bo.length], enabled: Yr.enabled(e), namespace: e, log: Yr.log, extend: () => {} }, t = (...n) => {
      let { enabled: i, namespace: o, color: s, log: a } = r;
      if (n.length !== 0 && Kr.push([o, ...n]), Kr.length > Bu && Kr.shift(), Yr.enabled(o) || i) {
        let l = n.map((c) => typeof c == "string" ? c : Qu(c)), u = `+${Date.now() - Uo}ms`;
        Uo = Date.now(), globalThis.DEBUG_COLORS ? a(Bt[s](W(o)), ...l, Bt[s](u)) : a(o, ...l, u);
      }
    };
    return new Proxy(t, { get: (n, i) => r[i], set: (n, i, o) => r[i] = o });
  }
  var N = new Proxy(Gu, { get: (e, r) => Yr[r], set: (e, r, t) => Yr[r] = t });
  function Qu(e, r = 2) {
    let t = new Set;
    return JSON.stringify(e, (n, i) => {
      if (typeof i == "object" && i !== null) {
        if (t.has(i))
          return "[Circular *]";
        t.add(i);
      } else if (typeof i == "bigint")
        return i.toString();
      return i;
    }, r);
  }
  function Go(e = 7500) {
    let r = Kr.map(([t, ...n]) => `${t} ${n.map((i) => typeof i == "string" ? i : JSON.stringify(i)).join(" ")}`).join(`
`);
    return r.length < e ? r : r.slice(-e);
  }
  function Qo() {
    Kr.length = 0;
  }
  var gr = N;
  var Wo = k(__require("fs"));
  function si() {
    let e = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
    if (!(e && Wo.default.existsSync(e)) && process.arch === "ia32")
      throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
  }
  var ai = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "freebsd14", "freebsd15", "openbsd", "netbsd", "arm"];
  var Ut = "libquery_engine";
  function Gt(e, r) {
    let t = r === "url";
    return e.includes("windows") ? t ? "query_engine.dll.node" : `query_engine-${e}.dll.node` : e.includes("darwin") ? t ? `${Ut}.dylib.node` : `${Ut}-${e}.dylib.node` : t ? `${Ut}.so.node` : `${Ut}-${e}.so.node`;
  }
  var Yo = k(__require("child_process"));
  var di = k(__require("fs/promises"));
  var Kt = k(__require("os"));
  var Oe = Symbol.for("@ts-pattern/matcher");
  var Wu = Symbol.for("@ts-pattern/isVariadic");
  var Wt = "@ts-pattern/anonymous-select-key";
  var li = (e) => !!(e && typeof e == "object");
  var Qt = (e) => e && !!e[Oe];
  var be = (e, r, t) => {
    if (Qt(e)) {
      let n = e[Oe](), { matched: i, selections: o } = n.match(r);
      return i && o && Object.keys(o).forEach((s) => t(s, o[s])), i;
    }
    if (li(e)) {
      if (!li(r))
        return false;
      if (Array.isArray(e)) {
        if (!Array.isArray(r))
          return false;
        let n = [], i = [], o = [];
        for (let s of e.keys()) {
          let a = e[s];
          Qt(a) && a[Wu] ? o.push(a) : o.length ? i.push(a) : n.push(a);
        }
        if (o.length) {
          if (o.length > 1)
            throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");
          if (r.length < n.length + i.length)
            return false;
          let s = r.slice(0, n.length), a = i.length === 0 ? [] : r.slice(-i.length), l = r.slice(n.length, i.length === 0 ? 1 / 0 : -i.length);
          return n.every((u, c) => be(u, s[c], t)) && i.every((u, c) => be(u, a[c], t)) && (o.length === 0 || be(o[0], l, t));
        }
        return e.length === r.length && e.every((s, a) => be(s, r[a], t));
      }
      return Reflect.ownKeys(e).every((n) => {
        let i = e[n];
        return ((n in r) || Qt(o = i) && o[Oe]().matcherType === "optional") && be(i, r[n], t);
        var o;
      });
    }
    return Object.is(r, e);
  };
  var Ge = (e) => {
    var r, t, n;
    return li(e) ? Qt(e) ? (r = (t = (n = e[Oe]()).getSelectionKeys) == null ? undefined : t.call(n)) != null ? r : [] : Array.isArray(e) ? zr(e, Ge) : zr(Object.values(e), Ge) : [];
  };
  var zr = (e, r) => e.reduce((t, n) => t.concat(r(n)), []);
  function pe(e) {
    return Object.assign(e, { optional: () => Ju(e), and: (r) => q(e, r), or: (r) => Hu(e, r), select: (r) => r === undefined ? Jo(e) : Jo(r, e) });
  }
  function Ju(e) {
    return pe({ [Oe]: () => ({ match: (r) => {
      let t = {}, n = (i, o) => {
        t[i] = o;
      };
      return r === undefined ? (Ge(e).forEach((i) => n(i, undefined)), { matched: true, selections: t }) : { matched: be(e, r, n), selections: t };
    }, getSelectionKeys: () => Ge(e), matcherType: "optional" }) });
  }
  function q(...e) {
    return pe({ [Oe]: () => ({ match: (r) => {
      let t = {}, n = (i, o) => {
        t[i] = o;
      };
      return { matched: e.every((i) => be(i, r, n)), selections: t };
    }, getSelectionKeys: () => zr(e, Ge), matcherType: "and" }) });
  }
  function Hu(...e) {
    return pe({ [Oe]: () => ({ match: (r) => {
      let t = {}, n = (i, o) => {
        t[i] = o;
      };
      return zr(e, Ge).forEach((i) => n(i, undefined)), { matched: e.some((i) => be(i, r, n)), selections: t };
    }, getSelectionKeys: () => zr(e, Ge), matcherType: "or" }) });
  }
  function A(e) {
    return { [Oe]: () => ({ match: (r) => ({ matched: !!e(r) }) }) };
  }
  function Jo(...e) {
    let r = typeof e[0] == "string" ? e[0] : undefined, t = e.length === 2 ? e[1] : typeof e[0] == "string" ? undefined : e[0];
    return pe({ [Oe]: () => ({ match: (n) => {
      let i = { [r ?? Wt]: n };
      return { matched: t === undefined || be(t, n, (o, s) => {
        i[o] = s;
      }), selections: i };
    }, getSelectionKeys: () => [r ?? Wt].concat(t === undefined ? [] : Ge(t)) }) });
  }
  function ye(e) {
    return typeof e == "number";
  }
  function je(e) {
    return typeof e == "string";
  }
  function Ve(e) {
    return typeof e == "bigint";
  }
  var rg = pe(A(function(e) {
    return true;
  }));
  var Be = (e) => Object.assign(pe(e), { startsWith: (r) => {
    return Be(q(e, (t = r, A((n) => je(n) && n.startsWith(t)))));
    var t;
  }, endsWith: (r) => {
    return Be(q(e, (t = r, A((n) => je(n) && n.endsWith(t)))));
    var t;
  }, minLength: (r) => Be(q(e, ((t) => A((n) => je(n) && n.length >= t))(r))), length: (r) => Be(q(e, ((t) => A((n) => je(n) && n.length === t))(r))), maxLength: (r) => Be(q(e, ((t) => A((n) => je(n) && n.length <= t))(r))), includes: (r) => {
    return Be(q(e, (t = r, A((n) => je(n) && n.includes(t)))));
    var t;
  }, regex: (r) => {
    return Be(q(e, (t = r, A((n) => je(n) && !!n.match(t)))));
    var t;
  } });
  var tg = Be(A(je));
  var Ee = (e) => Object.assign(pe(e), { between: (r, t) => Ee(q(e, ((n, i) => A((o) => ye(o) && n <= o && i >= o))(r, t))), lt: (r) => Ee(q(e, ((t) => A((n) => ye(n) && n < t))(r))), gt: (r) => Ee(q(e, ((t) => A((n) => ye(n) && n > t))(r))), lte: (r) => Ee(q(e, ((t) => A((n) => ye(n) && n <= t))(r))), gte: (r) => Ee(q(e, ((t) => A((n) => ye(n) && n >= t))(r))), int: () => Ee(q(e, A((r) => ye(r) && Number.isInteger(r)))), finite: () => Ee(q(e, A((r) => ye(r) && Number.isFinite(r)))), positive: () => Ee(q(e, A((r) => ye(r) && r > 0))), negative: () => Ee(q(e, A((r) => ye(r) && r < 0))) });
  var ng = Ee(A(ye));
  var Ue = (e) => Object.assign(pe(e), { between: (r, t) => Ue(q(e, ((n, i) => A((o) => Ve(o) && n <= o && i >= o))(r, t))), lt: (r) => Ue(q(e, ((t) => A((n) => Ve(n) && n < t))(r))), gt: (r) => Ue(q(e, ((t) => A((n) => Ve(n) && n > t))(r))), lte: (r) => Ue(q(e, ((t) => A((n) => Ve(n) && n <= t))(r))), gte: (r) => Ue(q(e, ((t) => A((n) => Ve(n) && n >= t))(r))), positive: () => Ue(q(e, A((r) => Ve(r) && r > 0))), negative: () => Ue(q(e, A((r) => Ve(r) && r < 0))) });
  var ig = Ue(A(Ve));
  var og = pe(A(function(e) {
    return typeof e == "boolean";
  }));
  var sg = pe(A(function(e) {
    return typeof e == "symbol";
  }));
  var ag = pe(A(function(e) {
    return e == null;
  }));
  var lg = pe(A(function(e) {
    return e != null;
  }));
  var ui = class extends Error {
    constructor(r) {
      let t;
      try {
        t = JSON.stringify(r);
      } catch {
        t = r;
      }
      super(`Pattern matching error: no pattern matches value ${t}`), this.input = undefined, this.input = r;
    }
  };
  var ci = { matched: false, value: undefined };
  function hr(e) {
    return new pi(e, ci);
  }
  var pi = class e {
    constructor(r, t) {
      this.input = undefined, this.state = undefined, this.input = r, this.state = t;
    }
    with(...r) {
      if (this.state.matched)
        return this;
      let t = r[r.length - 1], n = [r[0]], i;
      r.length === 3 && typeof r[1] == "function" ? i = r[1] : r.length > 2 && n.push(...r.slice(1, r.length - 1));
      let o = false, s = {}, a = (u, c) => {
        o = true, s[u] = c;
      }, l = !n.some((u) => be(u, this.input, a)) || i && !i(this.input) ? ci : { matched: true, value: t(o ? Wt in s ? s[Wt] : s : this.input, this.input) };
      return new e(this.input, l);
    }
    when(r, t) {
      if (this.state.matched)
        return this;
      let n = !!r(this.input);
      return new e(this.input, n ? { matched: true, value: t(this.input, this.input) } : ci);
    }
    otherwise(r) {
      return this.state.matched ? this.state.value : r(this.input);
    }
    exhaustive() {
      if (this.state.matched)
        return this.state.value;
      throw new ui(this.input);
    }
    run() {
      return this.exhaustive();
    }
    returnType() {
      return this;
    }
  };
  var zo = __require("util");
  var Ku = { warn: ke("prisma:warn") };
  var Yu = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  function Jt(e, ...r) {
    Yu.warn() && console.warn(`${Ku.warn} ${e}`, ...r);
  }
  var zu = (0, zo.promisify)(Yo.default.exec);
  var ee = gr("prisma:get-platform");
  var Zu = ["1.0.x", "1.1.x", "3.0.x"];
  async function Zo() {
    let e = Kt.default.platform(), r = process.arch;
    if (e === "freebsd") {
      let s = await Yt("freebsd-version");
      if (s && s.trim().length > 0) {
        let l = /^(\d+)\.?/.exec(s);
        if (l)
          return { platform: "freebsd", targetDistro: `freebsd${l[1]}`, arch: r };
      }
    }
    if (e !== "linux")
      return { platform: e, arch: r };
    let t = await ec(), n = await lc(), i = tc({ arch: r, archFromUname: n, familyDistro: t.familyDistro }), { libssl: o } = await nc(i);
    return { platform: "linux", libssl: o, arch: r, archFromUname: n, ...t };
  }
  function Xu(e) {
    let r = /^ID="?([^"\n]*)"?$/im, t = /^ID_LIKE="?([^"\n]*)"?$/im, n = r.exec(e), i = n && n[1] && n[1].toLowerCase() || "", o = t.exec(e), s = o && o[1] && o[1].toLowerCase() || "", a = hr({ id: i, idLike: s }).with({ id: "alpine" }, ({ id: l }) => ({ targetDistro: "musl", familyDistro: l, originalDistro: l })).with({ id: "raspbian" }, ({ id: l }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l })).with({ id: "nixos" }, ({ id: l }) => ({ targetDistro: "nixos", originalDistro: l, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).when(({ idLike: l }) => l.includes("debian") || l.includes("ubuntu"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).when(({ idLike: l }) => i === "arch" || l.includes("arch"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l })).when(({ idLike: l }) => l.includes("centos") || l.includes("fedora") || l.includes("rhel") || l.includes("suse"), ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).otherwise(({ id: l }) => ({ targetDistro: undefined, familyDistro: undefined, originalDistro: l }));
    return ee(`Found distro info:
${JSON.stringify(a, null, 2)}`), a;
  }
  async function ec() {
    let e = "/etc/os-release";
    try {
      let r = await di.default.readFile(e, { encoding: "utf-8" });
      return Xu(r);
    } catch {
      return { targetDistro: undefined, familyDistro: undefined, originalDistro: undefined };
    }
  }
  function rc(e) {
    let r = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);
    if (r) {
      let t = `${r[1]}.x`;
      return Xo(t);
    }
  }
  function Ho(e) {
    let r = /libssl\.so\.(\d)(\.\d)?/.exec(e);
    if (r) {
      let t = `${r[1]}${r[2] ?? ".0"}.x`;
      return Xo(t);
    }
  }
  function Xo(e) {
    let r = (() => {
      if (rs(e))
        return e;
      let t = e.split(".");
      return t[1] = "0", t.join(".");
    })();
    if (Zu.includes(r))
      return r;
  }
  function tc(e) {
    return hr(e).with({ familyDistro: "musl" }, () => (ee('Trying platform-specific paths for "alpine"'), ["/lib", "/usr/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: r }) => (ee('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${r}-linux-gnu`, `/lib/${r}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (ee('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: r, arch: t, archFromUname: n }) => (ee(`Don't know any platform-specific paths for "${r}" on ${t} (${n})`), []));
  }
  async function nc(e) {
    let r = 'grep -v "libssl.so.0"', t = await Ko(e);
    if (t) {
      ee(`Found libssl.so file using platform-specific paths: ${t}`);
      let o = Ho(t);
      if (ee(`The parsed libssl version is: ${o}`), o)
        return { libssl: o, strategy: "libssl-specific-path" };
    }
    ee('Falling back to "ldconfig" and other generic paths');
    let n = await Yt(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${r}`);
    if (n || (n = await Ko(["/lib64", "/usr/lib64", "/lib", "/usr/lib"])), n) {
      ee(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);
      let o = Ho(n);
      if (ee(`The parsed libssl version is: ${o}`), o)
        return { libssl: o, strategy: "ldconfig" };
    }
    let i = await Yt("openssl version -v");
    if (i) {
      ee(`Found openssl binary with version: ${i}`);
      let o = rc(i);
      if (ee(`The parsed openssl version is: ${o}`), o)
        return { libssl: o, strategy: "openssl-binary" };
    }
    return ee("Couldn't find any version of libssl or OpenSSL in the system"), {};
  }
  async function Ko(e) {
    for (let r of e) {
      let t = await ic(r);
      if (t)
        return t;
    }
  }
  async function ic(e) {
    try {
      return (await di.default.readdir(e)).find((t) => t.startsWith("libssl.so.") && !t.startsWith("libssl.so.0"));
    } catch (r) {
      if (r.code === "ENOENT")
        return;
      throw r;
    }
  }
  async function ir() {
    let { binaryTarget: e } = await es();
    return e;
  }
  function oc(e) {
    return e.binaryTarget !== undefined;
  }
  async function mi() {
    let { memoized: e, ...r } = await es();
    return r;
  }
  var Ht = {};
  async function es() {
    if (oc(Ht))
      return Promise.resolve({ ...Ht, memoized: true });
    let e = await Zo(), r = sc(e);
    return Ht = { ...e, binaryTarget: r }, { ...Ht, memoized: false };
  }
  function sc(e) {
    let { platform: r, arch: t, archFromUname: n, libssl: i, targetDistro: o, familyDistro: s, originalDistro: a } = e;
    r === "linux" && !["x64", "arm64"].includes(t) && Jt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${t}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);
    let l = "1.1.x";
    if (r === "linux" && i === undefined) {
      let c = hr({ familyDistro: s }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
      Jt(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".
${c}`);
    }
    let u = "debian";
    if (r === "linux" && o === undefined && ee(`Distro is "${a}". Falling back to Prisma engines built for "${u}".`), r === "darwin" && t === "arm64")
      return "darwin-arm64";
    if (r === "darwin")
      return "darwin";
    if (r === "win32")
      return "windows";
    if (r === "freebsd")
      return o;
    if (r === "openbsd")
      return "openbsd";
    if (r === "netbsd")
      return "netbsd";
    if (r === "linux" && o === "nixos")
      return "linux-nixos";
    if (r === "linux" && t === "arm64")
      return `${o === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i || l}`;
    if (r === "linux" && t === "arm")
      return `linux-arm-openssl-${i || l}`;
    if (r === "linux" && o === "musl") {
      let c = "linux-musl";
      return !i || rs(i) ? c : `${c}-openssl-${i}`;
    }
    return r === "linux" && o && i ? `${o}-openssl-${i}` : (r !== "linux" && Jt(`Prisma detected unknown OS "${r}" and may not work as expected. Defaulting to "linux".`), i ? `${u}-openssl-${i}` : o ? `${o}-openssl-${l}` : `${u}-openssl-${l}`);
  }
  async function ac(e) {
    try {
      return await e();
    } catch {
      return;
    }
  }
  function Yt(e) {
    return ac(async () => {
      let r = await zu(e);
      return ee(`Command "${e}" successfully returned "${r.stdout}"`), r.stdout;
    });
  }
  async function lc() {
    return typeof Kt.default.machine == "function" ? Kt.default.machine() : (await Yt("uname -m"))?.trim();
  }
  function rs(e) {
    return e.startsWith("1.");
  }
  var Xt = {};
  tr(Xt, { beep: () => Nc, clearScreen: () => kc, clearTerminal: () => Dc, cursorBackward: () => gc, cursorDown: () => mc, cursorForward: () => fc, cursorGetPosition: () => Ec, cursorHide: () => xc, cursorLeft: () => is, cursorMove: () => dc, cursorNextLine: () => bc, cursorPrevLine: () => wc, cursorRestorePosition: () => yc, cursorSavePosition: () => hc, cursorShow: () => vc, cursorTo: () => pc, cursorUp: () => ns, enterAlternativeScreen: () => Oc, eraseDown: () => Rc, eraseEndLine: () => Tc, eraseLine: () => os, eraseLines: () => Pc, eraseScreen: () => fi, eraseStartLine: () => Sc, eraseUp: () => Cc, exitAlternativeScreen: () => _c, iTerm: () => Mc, image: () => Fc, link: () => Lc, scrollDown: () => Ic, scrollUp: () => Ac });
  var Zt = k(__require("process"), 1);
  var zt = globalThis.window?.document !== undefined;
  var hg = globalThis.process?.versions?.node !== undefined;
  var yg = globalThis.process?.versions?.bun !== undefined;
  var Eg = globalThis.Deno?.version?.deno !== undefined;
  var bg = globalThis.process?.versions?.electron !== undefined;
  var wg = globalThis.navigator?.userAgent?.includes("jsdom") === true;
  var xg = typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
  var vg = typeof DedicatedWorkerGlobalScope < "u" && globalThis instanceof DedicatedWorkerGlobalScope;
  var Pg = typeof SharedWorkerGlobalScope < "u" && globalThis instanceof SharedWorkerGlobalScope;
  var Tg = typeof ServiceWorkerGlobalScope < "u" && globalThis instanceof ServiceWorkerGlobalScope;
  var Zr = globalThis.navigator?.userAgentData?.platform;
  var Sg = Zr === "macOS" || globalThis.navigator?.platform === "MacIntel" || globalThis.navigator?.userAgent?.includes(" Mac ") === true || globalThis.process?.platform === "darwin";
  var Rg = Zr === "Windows" || globalThis.navigator?.platform === "Win32" || globalThis.process?.platform === "win32";
  var Cg = Zr === "Linux" || globalThis.navigator?.platform?.startsWith("Linux") === true || globalThis.navigator?.userAgent?.includes(" Linux ") === true || globalThis.process?.platform === "linux";
  var Ag = Zr === "iOS" || globalThis.navigator?.platform === "MacIntel" && globalThis.navigator?.maxTouchPoints > 1 || /iPad|iPhone|iPod/.test(globalThis.navigator?.platform);
  var Ig = Zr === "Android" || globalThis.navigator?.platform === "Android" || globalThis.navigator?.userAgent?.includes(" Android ") === true || globalThis.process?.platform === "android";
  var I = "\x1B[";
  var et = "\x1B]";
  var yr = "\x07";
  var Xr = ";";
  var ts = !zt && Zt.default.env.TERM_PROGRAM === "Apple_Terminal";
  var uc = !zt && Zt.default.platform === "win32";
  var cc = zt ? () => {
    throw new Error("`process.cwd()` only works in Node.js, not the browser.");
  } : Zt.default.cwd;
  var pc = (e, r) => {
    if (typeof e != "number")
      throw new TypeError("The `x` argument is required");
    return typeof r != "number" ? I + (e + 1) + "G" : I + (r + 1) + Xr + (e + 1) + "H";
  };
  var dc = (e, r) => {
    if (typeof e != "number")
      throw new TypeError("The `x` argument is required");
    let t = "";
    return e < 0 ? t += I + -e + "D" : e > 0 && (t += I + e + "C"), r < 0 ? t += I + -r + "A" : r > 0 && (t += I + r + "B"), t;
  };
  var ns = (e = 1) => I + e + "A";
  var mc = (e = 1) => I + e + "B";
  var fc = (e = 1) => I + e + "C";
  var gc = (e = 1) => I + e + "D";
  var is = I + "G";
  var hc = ts ? "\x1B7" : I + "s";
  var yc = ts ? "\x1B8" : I + "u";
  var Ec = I + "6n";
  var bc = I + "E";
  var wc = I + "F";
  var xc = I + "?25l";
  var vc = I + "?25h";
  var Pc = (e) => {
    let r = "";
    for (let t = 0;t < e; t++)
      r += os + (t < e - 1 ? ns() : "");
    return e && (r += is), r;
  };
  var Tc = I + "K";
  var Sc = I + "1K";
  var os = I + "2K";
  var Rc = I + "J";
  var Cc = I + "1J";
  var fi = I + "2J";
  var Ac = I + "S";
  var Ic = I + "T";
  var kc = "\x1Bc";
  var Dc = uc ? `${fi}${I}0f` : `${fi}${I}3J${I}H`;
  var Oc = I + "?1049h";
  var _c = I + "?1049l";
  var Nc = yr;
  var Lc = (e, r) => [et, "8", Xr, Xr, r, yr, e, et, "8", Xr, Xr, yr].join("");
  var Fc = (e, r = {}) => {
    let t = `${et}1337;File=inline=1`;
    return r.width && (t += `;width=${r.width}`), r.height && (t += `;height=${r.height}`), r.preserveAspectRatio === false && (t += ";preserveAspectRatio=0"), t + ":" + Buffer.from(e).toString("base64") + yr;
  };
  var Mc = { setCwd: (e = cc()) => `${et}50;CurrentDir=${e}${yr}`, annotation(e, r = {}) {
    let t = `${et}1337;`, n = r.x !== undefined, i = r.y !== undefined;
    if ((n || i) && !(n && i && r.length !== undefined))
      throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
    return e = e.replaceAll("|", ""), t += r.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", r.length > 0 ? t += (n ? [e, r.length, r.x, r.y] : [r.length, e]).join("|") : t += e, t + yr;
  } };
  var en = k(ds(), 1);
  function or(e, r, { target: t = "stdout", ...n } = {}) {
    return en.default[t] ? Xt.link(e, r) : n.fallback === false ? e : typeof n.fallback == "function" ? n.fallback(e, r) : `${e} (\u200B${r}\u200B)`;
  }
  or.isSupported = en.default.stdout;
  or.stderr = (e, r, t = {}) => or(e, r, { target: "stderr", ...t });
  or.stderr.isSupported = en.default.stderr;
  function bi(e) {
    return or(e, e, { fallback: Y });
  }
  var Bc = ms();
  var wi = Bc.version;
  function br(e) {
    let r = Uc();
    return r || (e?.config.engineType === "library" ? "library" : e?.config.engineType === "binary" ? "binary" : e?.config.engineType === "client" ? "client" : Gc(e));
  }
  function Uc() {
    let e = process.env.PRISMA_CLIENT_ENGINE_TYPE;
    return e === "library" ? "library" : e === "binary" ? "binary" : e === "client" ? "client" : undefined;
  }
  function Gc(e) {
    return e?.previewFeatures.includes("queryCompiler") ? "client" : "library";
  }
  var Wc = k(vi());
  var M = k(__require("path"));
  var Jc = k(vi());
  var ah = N("prisma:engines");
  function fs() {
    return M.default.join(__dirname, "../");
  }
  M.default.join(__dirname, "../query-engine-darwin");
  M.default.join(__dirname, "../query-engine-darwin-arm64");
  M.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
  M.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
  M.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
  M.default.join(__dirname, "../query-engine-linux-static-x64");
  M.default.join(__dirname, "../query-engine-linux-static-arm64");
  M.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
  M.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
  M.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
  M.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
  M.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
  M.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
  M.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
  M.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
  M.default.join(__dirname, "../query_engine-windows.dll.node");
  var Pi = k(__require("fs"));
  var gs = gr("chmodPlusX");
  function Ti(e) {
    if (process.platform === "win32")
      return;
    let r = Pi.default.statSync(e), t = r.mode | 64 | 8 | 1;
    if (r.mode === t) {
      gs(`Execution permissions of ${e} are fine`);
      return;
    }
    let n = t.toString(8).slice(-3);
    gs(`Have to call chmodPlusX on ${e}`), Pi.default.chmodSync(e, n);
  }
  function Si(e) {
    let r = e.e, t = (a) => `Prisma cannot find the required \`${a}\` system library in your system`, n = r.message.includes("cannot open shared object file"), i = `Please refer to the documentation about Prisma's system requirements: ${bi("https://pris.ly/d/system-requirements")}`, o = `Unable to require(\`${Ie(e.id)}\`).`, s = hr({ message: r.message, code: r.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a }) => n && a.includes("libz"), () => `${t("libz")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libgcc_s"), () => `${t("libgcc_s")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libssl"), () => {
      let a = e.platformInfo.libssl ? `openssl-${e.platformInfo.libssl}` : "openssl";
      return `${t("libssl")}. Please install ${a} and try again.`;
    }).when(({ message: a }) => a.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({ message: a }) => e.platformInfo.platform === "linux" && a.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i}`);
    return `${o}
${s}

Details: ${r.message}`;
  }
  var Es = k(ys(), 1);
  function Ri(e) {
    let r = (0, Es.default)(e);
    if (r === 0)
      return e;
    let t = new RegExp(`^[ \\t]{${r}}`, "gm");
    return e.replace(t, "");
  }
  var bs = "prisma+postgres";
  var tn = `${bs}:`;
  function nn(e) {
    return e?.toString().startsWith(`${tn}//`) ?? false;
  }
  function Ci(e) {
    if (!nn(e))
      return false;
    let { host: r } = new URL(e);
    return r.includes("localhost") || r.includes("127.0.0.1");
  }
  var xs = k(Ai());
  function ki(e) {
    return String(new Ii(e));
  }
  var Ii = class {
    constructor(r) {
      this.config = r;
    }
    toString() {
      let { config: r } = this, t = r.provider.fromEnvVar ? `env("${r.provider.fromEnvVar}")` : r.provider.value, n = JSON.parse(JSON.stringify({ provider: t, binaryTargets: Hc(r.binaryTargets) }));
      return `generator ${r.name} {
${(0, xs.default)(Kc(n), 2)}
}`;
    }
  };
  function Hc(e) {
    let r;
    if (e.length > 0) {
      let t = e.find((n) => n.fromEnvVar !== null);
      t ? r = `env("${t.fromEnvVar}")` : r = e.map((n) => n.native ? "native" : n.value);
    } else
      r = undefined;
    return r;
  }
  function Kc(e) {
    let r = Object.keys(e).reduce((t, n) => Math.max(t, n.length), 0);
    return Object.entries(e).map(([t, n]) => `${t.padEnd(r)} = ${Yc(n)}`).join(`
`);
  }
  function Yc(e) {
    return JSON.parse(JSON.stringify(e, (r, t) => Array.isArray(t) ? `[${t.map((n) => JSON.stringify(n)).join(", ")}]` : JSON.stringify(t)));
  }
  var tt = {};
  tr(tt, { error: () => Xc, info: () => Zc, log: () => zc, query: () => ep, should: () => vs, tags: () => rt, warn: () => Di });
  var rt = { error: ce("prisma:error"), warn: ke("prisma:warn"), info: De("prisma:info"), query: nr("prisma:query") };
  var vs = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  function zc(...e) {
    console.log(...e);
  }
  function Di(e, ...r) {
    vs.warn() && console.warn(`${rt.warn} ${e}`, ...r);
  }
  function Zc(e, ...r) {
    console.info(`${rt.info} ${e}`, ...r);
  }
  function Xc(e, ...r) {
    console.error(`${rt.error} ${e}`, ...r);
  }
  function ep(e, ...r) {
    console.log(`${rt.query} ${e}`, ...r);
  }
  function on(e, r) {
    if (!e)
      throw new Error(`${r}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`);
  }
  function _e(e, r) {
    throw new Error(r);
  }
  var nt = k(__require("path"));
  function _i(e) {
    return nt.default.sep === nt.default.posix.sep ? e : e.split(nt.default.sep).join(nt.default.posix.sep);
  }
  var Mi = k(Ds());
  var sn = k(__require("fs"));
  var wr = k(__require("path"));
  function Os(e) {
    let r = e.ignoreProcessEnv ? {} : process.env, t = (n) => n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o, s) {
      let a = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);
      if (!a)
        return o;
      let l = a[1], u, c;
      if (l === "\\")
        c = a[0], u = c.replace("\\$", "$");
      else {
        let p = a[2];
        c = a[0].substring(l.length), u = Object.hasOwnProperty.call(r, p) ? r[p] : e.parsed[p] || "", u = t(u);
      }
      return o.replace(c, u);
    }, n) ?? n;
    for (let n in e.parsed) {
      let i = Object.hasOwnProperty.call(r, n) ? r[n] : e.parsed[n];
      e.parsed[n] = t(i);
    }
    for (let n in e.parsed)
      r[n] = e.parsed[n];
    return e;
  }
  var Fi = gr("prisma:tryLoadEnv");
  function ot({ rootEnvPath: e, schemaEnvPath: r }, t = { conflictCheck: "none" }) {
    let n = _s(e);
    t.conflictCheck !== "none" && hp(n, r, t.conflictCheck);
    let i = null;
    return Ns(n?.path, r) || (i = _s(r)), !n && !i && Fi("No Environment variables loaded"), i?.dotenvResult.error ? console.error(ce(W("Schema Env Error: ")) + i.dotenvResult.error) : { message: [n?.message, i?.message].filter(Boolean).join(`
`), parsed: { ...n?.dotenvResult?.parsed, ...i?.dotenvResult?.parsed } };
  }
  function hp(e, r, t) {
    let n = e?.dotenvResult.parsed, i = !Ns(e?.path, r);
    if (n && r && i && sn.default.existsSync(r)) {
      let o = Mi.default.parse(sn.default.readFileSync(r)), s = [];
      for (let a in o)
        n[a] === o[a] && s.push(a);
      if (s.length > 0) {
        let a = wr.default.relative(process.cwd(), e.path), l = wr.default.relative(process.cwd(), r);
        if (t === "error") {
          let u = `There is a conflict between env var${s.length > 1 ? "s" : ""} in ${Y(a)} and ${Y(l)}
Conflicting env vars:
${s.map((c) => `  ${W(c)}`).join(`
`)}

We suggest to move the contents of ${Y(l)} to ${Y(a)} to consolidate your env vars.
`;
          throw new Error(u);
        } else if (t === "warn") {
          let u = `Conflict for env var${s.length > 1 ? "s" : ""} ${s.map((c) => W(c)).join(", ")} in ${Y(a)} and ${Y(l)}
Env vars from ${Y(l)} overwrite the ones from ${Y(a)}
      `;
          console.warn(`${ke("warn(prisma)")} ${u}`);
        }
      }
    }
  }
  function _s(e) {
    if (yp(e)) {
      Fi(`Environment variables loaded from ${e}`);
      let r = Mi.default.config({ path: e, debug: process.env.DOTENV_CONFIG_DEBUG ? true : undefined });
      return { dotenvResult: Os(r), message: Ie(`Environment variables loaded from ${wr.default.relative(process.cwd(), e)}`), path: e };
    } else
      Fi(`Environment variables not found at ${e}`);
    return null;
  }
  function Ns(e, r) {
    return e && r && wr.default.resolve(e) === wr.default.resolve(r);
  }
  function yp(e) {
    return !!(e && sn.default.existsSync(e));
  }
  function $i(e, r) {
    return Object.prototype.hasOwnProperty.call(e, r);
  }
  function xr(e, r) {
    let t = {};
    for (let n of Object.keys(e))
      t[n] = r(e[n], n);
    return t;
  }
  function qi(e, r) {
    if (e.length === 0)
      return;
    let t = e[0];
    for (let n = 1;n < e.length; n++)
      r(t, e[n]) < 0 && (t = e[n]);
    return t;
  }
  function x(e, r) {
    Object.defineProperty(e, "name", { value: r, configurable: true });
  }
  var Fs = new Set;
  var st = (e, r, ...t) => {
    Fs.has(e) || (Fs.add(e), Di(r, ...t));
  };
  var T = class e extends Error {
    clientVersion;
    errorCode;
    retryable;
    constructor(r, t, n) {
      super(r), this.name = "PrismaClientInitializationError", this.clientVersion = t, this.errorCode = n, Error.captureStackTrace(e);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
  x(T, "PrismaClientInitializationError");
  var z = class extends Error {
    code;
    meta;
    clientVersion;
    batchRequestIdx;
    constructor(r, { code: t, clientVersion: n, meta: i, batchRequestIdx: o }) {
      super(r), this.name = "PrismaClientKnownRequestError", this.code = t, this.clientVersion = n, this.meta = i, Object.defineProperty(this, "batchRequestIdx", { value: o, enumerable: false, writable: true });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
  x(z, "PrismaClientKnownRequestError");
  var le = class extends Error {
    clientVersion;
    constructor(r, t) {
      super(r), this.name = "PrismaClientRustPanicError", this.clientVersion = t;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
  x(le, "PrismaClientRustPanicError");
  var j = class extends Error {
    clientVersion;
    batchRequestIdx;
    constructor(r, { clientVersion: t, batchRequestIdx: n }) {
      super(r), this.name = "PrismaClientUnknownRequestError", this.clientVersion = t, Object.defineProperty(this, "batchRequestIdx", { value: n, writable: true, enumerable: false });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
  x(j, "PrismaClientUnknownRequestError");
  var Z = class extends Error {
    name = "PrismaClientValidationError";
    clientVersion;
    constructor(r, { clientVersion: t }) {
      super(r), this.clientVersion = t;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientValidationError";
    }
  };
  x(Z, "PrismaClientValidationError");
  var vr = 9000000000000000;
  var Ke = 1e9;
  var ji = "0123456789abcdef";
  var pn = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var dn = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var Vi = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -vr, maxE: vr, crypto: false };
  var js;
  var Le;
  var w = true;
  var fn = "[DecimalError] ";
  var He = fn + "Invalid argument: ";
  var Vs = fn + "Precision limit exceeded";
  var Bs = fn + "crypto unavailable";
  var Us = "[object Decimal]";
  var X = Math.floor;
  var U = Math.pow;
  var Ep = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var bp = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var wp = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var Gs = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var fe = 1e7;
  var b = 7;
  var xp = 9007199254740991;
  var vp = pn.length - 1;
  var Bi = dn.length - 1;
  var m = { toStringTag: Us };
  m.absoluteValue = m.abs = function() {
    var e = new this.constructor(this);
    return e.s < 0 && (e.s = 1), y(e);
  };
  m.ceil = function() {
    return y(new this.constructor(this), this.e + 1, 2);
  };
  m.clampedTo = m.clamp = function(e, r) {
    var t, n = this, i = n.constructor;
    if (e = new i(e), r = new i(r), !e.s || !r.s)
      return new i(NaN);
    if (e.gt(r))
      throw Error(He + r);
    return t = n.cmp(e), t < 0 ? e : n.cmp(r) > 0 ? r : new i(n);
  };
  m.comparedTo = m.cmp = function(e) {
    var r, t, n, i, o = this, s = o.d, a = (e = new o.constructor(e)).d, l = o.s, u = e.s;
    if (!s || !a)
      return !l || !u ? NaN : l !== u ? l : s === a ? 0 : !s ^ l < 0 ? 1 : -1;
    if (!s[0] || !a[0])
      return s[0] ? l : a[0] ? -u : 0;
    if (l !== u)
      return l;
    if (o.e !== e.e)
      return o.e > e.e ^ l < 0 ? 1 : -1;
    for (n = s.length, i = a.length, r = 0, t = n < i ? n : i;r < t; ++r)
      if (s[r] !== a[r])
        return s[r] > a[r] ^ l < 0 ? 1 : -1;
    return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
  };
  m.cosine = m.cos = function() {
    var e, r, t = this, n = t.constructor;
    return t.d ? t.d[0] ? (e = n.precision, r = n.rounding, n.precision = e + Math.max(t.e, t.sd()) + b, n.rounding = 1, t = Pp(n, Ks(n, t)), n.precision = e, n.rounding = r, y(Le == 2 || Le == 3 ? t.neg() : t, e, r, true)) : new n(1) : new n(NaN);
  };
  m.cubeRoot = m.cbrt = function() {
    var e, r, t, n, i, o, s, a, l, u, c = this, p = c.constructor;
    if (!c.isFinite() || c.isZero())
      return new p(c);
    for (w = false, o = c.s * U(c.s * c, 1 / 3), !o || Math.abs(o) == 1 / 0 ? (t = J(c.d), e = c.e, (o = (e - t.length + 1) % 3) && (t += o == 1 || o == -2 ? "0" : "00"), o = U(t, 1 / 3), e = X((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), o == 1 / 0 ? t = "5e" + e : (t = o.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + e), n = new p(t), n.s = c.s) : n = new p(o.toString()), s = (e = p.precision) + 3;; )
      if (a = n, l = a.times(a).times(a), u = l.plus(c), n = L(u.plus(c).times(a), u.plus(l), s + 2, 1), J(a.d).slice(0, s) === (t = J(n.d)).slice(0, s))
        if (t = t.slice(s - 3, s + 1), t == "9999" || !i && t == "4999") {
          if (!i && (y(a, e + 1, 0), a.times(a).times(a).eq(c))) {
            n = a;
            break;
          }
          s += 4, i = 1;
        } else {
          (!+t || !+t.slice(1) && t.charAt(0) == "5") && (y(n, e + 1, 1), r = !n.times(n).times(n).eq(c));
          break;
        }
    return w = true, y(n, e, p.rounding, r);
  };
  m.decimalPlaces = m.dp = function() {
    var e, r = this.d, t = NaN;
    if (r) {
      if (e = r.length - 1, t = (e - X(this.e / b)) * b, e = r[e], e)
        for (;e % 10 == 0; e /= 10)
          t--;
      t < 0 && (t = 0);
    }
    return t;
  };
  m.dividedBy = m.div = function(e) {
    return L(this, new this.constructor(e));
  };
  m.dividedToIntegerBy = m.divToInt = function(e) {
    var r = this, t = r.constructor;
    return y(L(r, new t(e), 0, 1, 1), t.precision, t.rounding);
  };
  m.equals = m.eq = function(e) {
    return this.cmp(e) === 0;
  };
  m.floor = function() {
    return y(new this.constructor(this), this.e + 1, 3);
  };
  m.greaterThan = m.gt = function(e) {
    return this.cmp(e) > 0;
  };
  m.greaterThanOrEqualTo = m.gte = function(e) {
    var r = this.cmp(e);
    return r == 1 || r === 0;
  };
  m.hyperbolicCosine = m.cosh = function() {
    var e, r, t, n, i, o = this, s = o.constructor, a = new s(1);
    if (!o.isFinite())
      return new s(o.s ? 1 / 0 : NaN);
    if (o.isZero())
      return a;
    t = s.precision, n = s.rounding, s.precision = t + Math.max(o.e, o.sd()) + 4, s.rounding = 1, i = o.d.length, i < 32 ? (e = Math.ceil(i / 3), r = (1 / hn(4, e)).toString()) : (e = 16, r = "2.3283064365386962890625e-10"), o = Pr(s, 1, o.times(r), new s(1), true);
    for (var l, u = e, c = new s(8);u--; )
      l = o.times(o), o = a.minus(l.times(c.minus(l.times(c))));
    return y(o, s.precision = t, s.rounding = n, true);
  };
  m.hyperbolicSine = m.sinh = function() {
    var e, r, t, n, i = this, o = i.constructor;
    if (!i.isFinite() || i.isZero())
      return new o(i);
    if (r = o.precision, t = o.rounding, o.precision = r + Math.max(i.e, i.sd()) + 4, o.rounding = 1, n = i.d.length, n < 3)
      i = Pr(o, 2, i, i, true);
    else {
      e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, i = i.times(1 / hn(5, e)), i = Pr(o, 2, i, i, true);
      for (var s, a = new o(5), l = new o(16), u = new o(20);e--; )
        s = i.times(i), i = i.times(a.plus(s.times(l.times(s).plus(u))));
    }
    return o.precision = r, o.rounding = t, y(i, r, t, true);
  };
  m.hyperbolicTangent = m.tanh = function() {
    var e, r, t = this, n = t.constructor;
    return t.isFinite() ? t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + 7, n.rounding = 1, L(t.sinh(), t.cosh(), n.precision = e, n.rounding = r)) : new n(t.s);
  };
  m.inverseCosine = m.acos = function() {
    var e = this, r = e.constructor, t = e.abs().cmp(1), n = r.precision, i = r.rounding;
    return t !== -1 ? t === 0 ? e.isNeg() ? we(r, n, i) : new r(0) : new r(NaN) : e.isZero() ? we(r, n + 4, i).times(0.5) : (r.precision = n + 6, r.rounding = 1, e = new r(1).minus(e).div(e.plus(1)).sqrt().atan(), r.precision = n, r.rounding = i, e.times(2));
  };
  m.inverseHyperbolicCosine = m.acosh = function() {
    var e, r, t = this, n = t.constructor;
    return t.lte(1) ? new n(t.eq(1) ? 0 : NaN) : t.isFinite() ? (e = n.precision, r = n.rounding, n.precision = e + Math.max(Math.abs(t.e), t.sd()) + 4, n.rounding = 1, w = false, t = t.times(t).minus(1).sqrt().plus(t), w = true, n.precision = e, n.rounding = r, t.ln()) : new n(t);
  };
  m.inverseHyperbolicSine = m.asinh = function() {
    var e, r, t = this, n = t.constructor;
    return !t.isFinite() || t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + 2 * Math.max(Math.abs(t.e), t.sd()) + 6, n.rounding = 1, w = false, t = t.times(t).plus(1).sqrt().plus(t), w = true, n.precision = e, n.rounding = r, t.ln());
  };
  m.inverseHyperbolicTangent = m.atanh = function() {
    var e, r, t, n, i = this, o = i.constructor;
    return i.isFinite() ? i.e >= 0 ? new o(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = o.precision, r = o.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? y(new o(i), e, r, true) : (o.precision = t = n - i.e, i = L(i.plus(1), new o(1).minus(i), t + e, 1), o.precision = e + 4, o.rounding = 1, i = i.ln(), o.precision = e, o.rounding = r, i.times(0.5))) : new o(NaN);
  };
  m.inverseSine = m.asin = function() {
    var e, r, t, n, i = this, o = i.constructor;
    return i.isZero() ? new o(i) : (r = i.abs().cmp(1), t = o.precision, n = o.rounding, r !== -1 ? r === 0 ? (e = we(o, t + 4, n).times(0.5), e.s = i.s, e) : new o(NaN) : (o.precision = t + 6, o.rounding = 1, i = i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(), o.precision = t, o.rounding = n, i.times(2)));
  };
  m.inverseTangent = m.atan = function() {
    var e, r, t, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding;
    if (u.isFinite()) {
      if (u.isZero())
        return new c(u);
      if (u.abs().eq(1) && p + 4 <= Bi)
        return s = we(c, p + 4, d).times(0.25), s.s = u.s, s;
    } else {
      if (!u.s)
        return new c(NaN);
      if (p + 4 <= Bi)
        return s = we(c, p + 4, d).times(0.5), s.s = u.s, s;
    }
    for (c.precision = a = p + 10, c.rounding = 1, t = Math.min(28, a / b + 2 | 0), e = t;e; --e)
      u = u.div(u.times(u).plus(1).sqrt().plus(1));
    for (w = false, r = Math.ceil(a / b), n = 1, l = u.times(u), s = new c(u), i = u;e !== -1; )
      if (i = i.times(l), o = s.minus(i.div(n += 2)), i = i.times(l), s = o.plus(i.div(n += 2)), s.d[r] !== undefined)
        for (e = r;s.d[e] === o.d[e] && e--; )
          ;
    return t && (s = s.times(2 << t - 1)), w = true, y(s, c.precision = p, c.rounding = d, true);
  };
  m.isFinite = function() {
    return !!this.d;
  };
  m.isInteger = m.isInt = function() {
    return !!this.d && X(this.e / b) > this.d.length - 2;
  };
  m.isNaN = function() {
    return !this.s;
  };
  m.isNegative = m.isNeg = function() {
    return this.s < 0;
  };
  m.isPositive = m.isPos = function() {
    return this.s > 0;
  };
  m.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  m.lessThan = m.lt = function(e) {
    return this.cmp(e) < 0;
  };
  m.lessThanOrEqualTo = m.lte = function(e) {
    return this.cmp(e) < 1;
  };
  m.logarithm = m.log = function(e) {
    var r, t, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding, f = 5;
    if (e == null)
      e = new c(10), r = true;
    else {
      if (e = new c(e), t = e.d, e.s < 0 || !t || !t[0] || e.eq(1))
        return new c(NaN);
      r = e.eq(10);
    }
    if (t = u.d, u.s < 0 || !t || !t[0] || u.eq(1))
      return new c(t && !t[0] ? -1 / 0 : u.s != 1 ? NaN : t ? 0 : 1 / 0);
    if (r)
      if (t.length > 1)
        o = true;
      else {
        for (i = t[0];i % 10 === 0; )
          i /= 10;
        o = i !== 1;
      }
    if (w = false, a = p + f, s = Je(u, a), n = r ? mn(c, a + 10) : Je(e, a), l = L(s, n, a, 1), at(l.d, i = p, d))
      do
        if (a += 10, s = Je(u, a), n = r ? mn(c, a + 10) : Je(e, a), l = L(s, n, a, 1), !o) {
          +J(l.d).slice(i + 1, i + 15) + 1 == 100000000000000 && (l = y(l, p + 1, 0));
          break;
        }
      while (at(l.d, i += 10, d));
    return w = true, y(l, p, d);
  };
  m.minus = m.sub = function(e) {
    var r, t, n, i, o, s, a, l, u, c, p, d, f = this, h = f.constructor;
    if (e = new h(e), !f.d || !e.d)
      return !f.s || !e.s ? e = new h(NaN) : f.d ? e.s = -e.s : e = new h(e.d || f.s !== e.s ? f : NaN), e;
    if (f.s != e.s)
      return e.s = -e.s, f.plus(e);
    if (u = f.d, d = e.d, a = h.precision, l = h.rounding, !u[0] || !d[0]) {
      if (d[0])
        e.s = -e.s;
      else if (u[0])
        e = new h(f);
      else
        return new h(l === 3 ? -0 : 0);
      return w ? y(e, a, l) : e;
    }
    if (t = X(e.e / b), c = X(f.e / b), u = u.slice(), o = c - t, o) {
      for (p = o < 0, p ? (r = u, o = -o, s = d.length) : (r = d, t = c, s = u.length), n = Math.max(Math.ceil(a / b), s) + 2, o > n && (o = n, r.length = 1), r.reverse(), n = o;n--; )
        r.push(0);
      r.reverse();
    } else {
      for (n = u.length, s = d.length, p = n < s, p && (s = n), n = 0;n < s; n++)
        if (u[n] != d[n]) {
          p = u[n] < d[n];
          break;
        }
      o = 0;
    }
    for (p && (r = u, u = d, d = r, e.s = -e.s), s = u.length, n = d.length - s;n > 0; --n)
      u[s++] = 0;
    for (n = d.length;n > o; ) {
      if (u[--n] < d[n]) {
        for (i = n;i && u[--i] === 0; )
          u[i] = fe - 1;
        --u[i], u[n] += fe;
      }
      u[n] -= d[n];
    }
    for (;u[--s] === 0; )
      u.pop();
    for (;u[0] === 0; u.shift())
      --t;
    return u[0] ? (e.d = u, e.e = gn(u, t), w ? y(e, a, l) : e) : new h(l === 3 ? -0 : 0);
  };
  m.modulo = m.mod = function(e) {
    var r, t = this, n = t.constructor;
    return e = new n(e), !t.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || t.d && !t.d[0] ? y(new n(t), n.precision, n.rounding) : (w = false, n.modulo == 9 ? (r = L(t, e.abs(), 0, 3, 1), r.s *= e.s) : r = L(t, e, 0, n.modulo, 1), r = r.times(e), w = true, t.minus(r));
  };
  m.naturalExponential = m.exp = function() {
    return Ui(this);
  };
  m.naturalLogarithm = m.ln = function() {
    return Je(this);
  };
  m.negated = m.neg = function() {
    var e = new this.constructor(this);
    return e.s = -e.s, y(e);
  };
  m.plus = m.add = function(e) {
    var r, t, n, i, o, s, a, l, u, c, p = this, d = p.constructor;
    if (e = new d(e), !p.d || !e.d)
      return !p.s || !e.s ? e = new d(NaN) : p.d || (e = new d(e.d || p.s === e.s ? p : NaN)), e;
    if (p.s != e.s)
      return e.s = -e.s, p.minus(e);
    if (u = p.d, c = e.d, a = d.precision, l = d.rounding, !u[0] || !c[0])
      return c[0] || (e = new d(p)), w ? y(e, a, l) : e;
    if (o = X(p.e / b), n = X(e.e / b), u = u.slice(), i = o - n, i) {
      for (i < 0 ? (t = u, i = -i, s = c.length) : (t = c, n = o, s = u.length), o = Math.ceil(a / b), s = o > s ? o + 1 : s + 1, i > s && (i = s, t.length = 1), t.reverse();i--; )
        t.push(0);
      t.reverse();
    }
    for (s = u.length, i = c.length, s - i < 0 && (i = s, t = c, c = u, u = t), r = 0;i; )
      r = (u[--i] = u[i] + c[i] + r) / fe | 0, u[i] %= fe;
    for (r && (u.unshift(r), ++n), s = u.length;u[--s] == 0; )
      u.pop();
    return e.d = u, e.e = gn(u, n), w ? y(e, a, l) : e;
  };
  m.precision = m.sd = function(e) {
    var r, t = this;
    if (e !== undefined && e !== !!e && e !== 1 && e !== 0)
      throw Error(He + e);
    return t.d ? (r = Qs(t.d), e && t.e + 1 > r && (r = t.e + 1)) : r = NaN, r;
  };
  m.round = function() {
    var e = this, r = e.constructor;
    return y(new r(e), e.e + 1, r.rounding);
  };
  m.sine = m.sin = function() {
    var e, r, t = this, n = t.constructor;
    return t.isFinite() ? t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + Math.max(t.e, t.sd()) + b, n.rounding = 1, t = Sp(n, Ks(n, t)), n.precision = e, n.rounding = r, y(Le > 2 ? t.neg() : t, e, r, true)) : new n(NaN);
  };
  m.squareRoot = m.sqrt = function() {
    var e, r, t, n, i, o, s = this, a = s.d, l = s.e, u = s.s, c = s.constructor;
    if (u !== 1 || !a || !a[0])
      return new c(!u || u < 0 && (!a || a[0]) ? NaN : a ? s : 1 / 0);
    for (w = false, u = Math.sqrt(+s), u == 0 || u == 1 / 0 ? (r = J(a), (r.length + l) % 2 == 0 && (r += "0"), u = Math.sqrt(r), l = X((l + 1) / 2) - (l < 0 || l % 2), u == 1 / 0 ? r = "5e" + l : (r = u.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + l), n = new c(r)) : n = new c(u.toString()), t = (l = c.precision) + 3;; )
      if (o = n, n = o.plus(L(s, o, t + 2, 1)).times(0.5), J(o.d).slice(0, t) === (r = J(n.d)).slice(0, t))
        if (r = r.slice(t - 3, t + 1), r == "9999" || !i && r == "4999") {
          if (!i && (y(o, l + 1, 0), o.times(o).eq(s))) {
            n = o;
            break;
          }
          t += 4, i = 1;
        } else {
          (!+r || !+r.slice(1) && r.charAt(0) == "5") && (y(n, l + 1, 1), e = !n.times(n).eq(s));
          break;
        }
    return w = true, y(n, l, c.rounding, e);
  };
  m.tangent = m.tan = function() {
    var e, r, t = this, n = t.constructor;
    return t.isFinite() ? t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + 10, n.rounding = 1, t = t.sin(), t.s = 1, t = L(t, new n(1).minus(t.times(t)).sqrt(), e + 10, 0), n.precision = e, n.rounding = r, y(Le == 2 || Le == 4 ? t.neg() : t, e, r, true)) : new n(NaN);
  };
  m.times = m.mul = function(e) {
    var r, t, n, i, o, s, a, l, u, c = this, p = c.constructor, d = c.d, f = (e = new p(e)).d;
    if (e.s *= c.s, !d || !d[0] || !f || !f[0])
      return new p(!e.s || d && !d[0] && !f || f && !f[0] && !d ? NaN : !d || !f ? e.s / 0 : e.s * 0);
    for (t = X(c.e / b) + X(e.e / b), l = d.length, u = f.length, l < u && (o = d, d = f, f = o, s = l, l = u, u = s), o = [], s = l + u, n = s;n--; )
      o.push(0);
    for (n = u;--n >= 0; ) {
      for (r = 0, i = l + n;i > n; )
        a = o[i] + f[n] * d[i - n - 1] + r, o[i--] = a % fe | 0, r = a / fe | 0;
      o[i] = (o[i] + r) % fe | 0;
    }
    for (;!o[--s]; )
      o.pop();
    return r ? ++t : o.shift(), e.d = o, e.e = gn(o, t), w ? y(e, p.precision, p.rounding) : e;
  };
  m.toBinary = function(e, r) {
    return Gi(this, 2, e, r);
  };
  m.toDecimalPlaces = m.toDP = function(e, r) {
    var t = this, n = t.constructor;
    return t = new n(t), e === undefined ? t : (ie(e, 0, Ke), r === undefined ? r = n.rounding : ie(r, 0, 8), y(t, e + t.e + 1, r));
  };
  m.toExponential = function(e, r) {
    var t, n = this, i = n.constructor;
    return e === undefined ? t = xe(n, true) : (ie(e, 0, Ke), r === undefined ? r = i.rounding : ie(r, 0, 8), n = y(new i(n), e + 1, r), t = xe(n, true, e + 1)), n.isNeg() && !n.isZero() ? "-" + t : t;
  };
  m.toFixed = function(e, r) {
    var t, n, i = this, o = i.constructor;
    return e === undefined ? t = xe(i) : (ie(e, 0, Ke), r === undefined ? r = o.rounding : ie(r, 0, 8), n = y(new o(i), e + i.e + 1, r), t = xe(n, false, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + t : t;
  };
  m.toFraction = function(e) {
    var r, t, n, i, o, s, a, l, u, c, p, d, f = this, h = f.d, g = f.constructor;
    if (!h)
      return new g(f);
    if (u = t = new g(1), n = l = new g(0), r = new g(n), o = r.e = Qs(h) - f.e - 1, s = o % b, r.d[0] = U(10, s < 0 ? b + s : s), e == null)
      e = o > 0 ? r : u;
    else {
      if (a = new g(e), !a.isInt() || a.lt(u))
        throw Error(He + a);
      e = a.gt(r) ? o > 0 ? r : u : a;
    }
    for (w = false, a = new g(J(h)), c = g.precision, g.precision = o = h.length * b * 2;p = L(a, r, 0, 1, 1), i = t.plus(p.times(n)), i.cmp(e) != 1; )
      t = n, n = i, i = u, u = l.plus(p.times(i)), l = i, i = r, r = a.minus(p.times(i)), a = i;
    return i = L(e.minus(t), n, 0, 1, 1), l = l.plus(i.times(u)), t = t.plus(i.times(n)), l.s = u.s = f.s, d = L(u, n, o, 1).minus(f).abs().cmp(L(l, t, o, 1).minus(f).abs()) < 1 ? [u, n] : [l, t], g.precision = c, w = true, d;
  };
  m.toHexadecimal = m.toHex = function(e, r) {
    return Gi(this, 16, e, r);
  };
  m.toNearest = function(e, r) {
    var t = this, n = t.constructor;
    if (t = new n(t), e == null) {
      if (!t.d)
        return t;
      e = new n(1), r = n.rounding;
    } else {
      if (e = new n(e), r === undefined ? r = n.rounding : ie(r, 0, 8), !t.d)
        return e.s ? t : e;
      if (!e.d)
        return e.s && (e.s = t.s), e;
    }
    return e.d[0] ? (w = false, t = L(t, e, 0, r, 1).times(e), w = true, y(t)) : (e.s = t.s, t = e), t;
  };
  m.toNumber = function() {
    return +this;
  };
  m.toOctal = function(e, r) {
    return Gi(this, 8, e, r);
  };
  m.toPower = m.pow = function(e) {
    var r, t, n, i, o, s, a = this, l = a.constructor, u = +(e = new l(e));
    if (!a.d || !e.d || !a.d[0] || !e.d[0])
      return new l(U(+a, u));
    if (a = new l(a), a.eq(1))
      return a;
    if (n = l.precision, o = l.rounding, e.eq(1))
      return y(a, n, o);
    if (r = X(e.e / b), r >= e.d.length - 1 && (t = u < 0 ? -u : u) <= xp)
      return i = Ws(l, a, t, n), e.s < 0 ? new l(1).div(i) : y(i, n, o);
    if (s = a.s, s < 0) {
      if (r < e.d.length - 1)
        return new l(NaN);
      if ((e.d[r] & 1) == 0 && (s = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
        return a.s = s, a;
    }
    return t = U(+a, u), r = t == 0 || !isFinite(t) ? X(u * (Math.log("0." + J(a.d)) / Math.LN10 + a.e + 1)) : new l(t + "").e, r > l.maxE + 1 || r < l.minE - 1 ? new l(r > 0 ? s / 0 : 0) : (w = false, l.rounding = a.s = 1, t = Math.min(12, (r + "").length), i = Ui(e.times(Je(a, n + t)), n), i.d && (i = y(i, n + 5, 1), at(i.d, n, o) && (r = n + 10, i = y(Ui(e.times(Je(a, r + t)), r), r + 5, 1), +J(i.d).slice(n + 1, n + 15) + 1 == 100000000000000 && (i = y(i, n + 1, 0)))), i.s = s, w = true, l.rounding = o, y(i, n, o));
  };
  m.toPrecision = function(e, r) {
    var t, n = this, i = n.constructor;
    return e === undefined ? t = xe(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (ie(e, 1, Ke), r === undefined ? r = i.rounding : ie(r, 0, 8), n = y(new i(n), e, r), t = xe(n, e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + t : t;
  };
  m.toSignificantDigits = m.toSD = function(e, r) {
    var t = this, n = t.constructor;
    return e === undefined ? (e = n.precision, r = n.rounding) : (ie(e, 1, Ke), r === undefined ? r = n.rounding : ie(r, 0, 8)), y(new n(t), e, r);
  };
  m.toString = function() {
    var e = this, r = e.constructor, t = xe(e, e.e <= r.toExpNeg || e.e >= r.toExpPos);
    return e.isNeg() && !e.isZero() ? "-" + t : t;
  };
  m.truncated = m.trunc = function() {
    return y(new this.constructor(this), this.e + 1, 1);
  };
  m.valueOf = m.toJSON = function() {
    var e = this, r = e.constructor, t = xe(e, e.e <= r.toExpNeg || e.e >= r.toExpPos);
    return e.isNeg() ? "-" + t : t;
  };
  function J(e) {
    var r, t, n, i = e.length - 1, o = "", s = e[0];
    if (i > 0) {
      for (o += s, r = 1;r < i; r++)
        n = e[r] + "", t = b - n.length, t && (o += We(t)), o += n;
      s = e[r], n = s + "", t = b - n.length, t && (o += We(t));
    } else if (s === 0)
      return "0";
    for (;s % 10 === 0; )
      s /= 10;
    return o + s;
  }
  function ie(e, r, t) {
    if (e !== ~~e || e < r || e > t)
      throw Error(He + e);
  }
  function at(e, r, t, n) {
    var i, o, s, a;
    for (o = e[0];o >= 10; o /= 10)
      --r;
    return --r < 0 ? (r += b, i = 0) : (i = Math.ceil((r + 1) / b), r %= b), o = U(10, b - r), a = e[i] % o | 0, n == null ? r < 3 ? (r == 0 ? a = a / 100 | 0 : r == 1 && (a = a / 10 | 0), s = t < 4 && a == 99999 || t > 3 && a == 49999 || a == 50000 || a == 0) : s = (t < 4 && a + 1 == o || t > 3 && a + 1 == o / 2) && (e[i + 1] / o / 100 | 0) == U(10, r - 2) - 1 || (a == o / 2 || a == 0) && (e[i + 1] / o / 100 | 0) == 0 : r < 4 ? (r == 0 ? a = a / 1000 | 0 : r == 1 ? a = a / 100 | 0 : r == 2 && (a = a / 10 | 0), s = (n || t < 4) && a == 9999 || !n && t > 3 && a == 4999) : s = ((n || t < 4) && a + 1 == o || !n && t > 3 && a + 1 == o / 2) && (e[i + 1] / o / 1000 | 0) == U(10, r - 3) - 1, s;
  }
  function un(e, r, t) {
    for (var n, i = [0], o, s = 0, a = e.length;s < a; ) {
      for (o = i.length;o--; )
        i[o] *= r;
      for (i[0] += ji.indexOf(e.charAt(s++)), n = 0;n < i.length; n++)
        i[n] > t - 1 && (i[n + 1] === undefined && (i[n + 1] = 0), i[n + 1] += i[n] / t | 0, i[n] %= t);
    }
    return i.reverse();
  }
  function Pp(e, r) {
    var t, n, i;
    if (r.isZero())
      return r;
    n = r.d.length, n < 32 ? (t = Math.ceil(n / 3), i = (1 / hn(4, t)).toString()) : (t = 16, i = "2.3283064365386962890625e-10"), e.precision += t, r = Pr(e, 1, r.times(i), new e(1));
    for (var o = t;o--; ) {
      var s = r.times(r);
      r = s.times(s).minus(s).times(8).plus(1);
    }
    return e.precision -= t, r;
  }
  var L = function() {
    function e(n, i, o) {
      var s, a = 0, l = n.length;
      for (n = n.slice();l--; )
        s = n[l] * i + a, n[l] = s % o | 0, a = s / o | 0;
      return a && n.unshift(a), n;
    }
    function r(n, i, o, s) {
      var a, l;
      if (o != s)
        l = o > s ? 1 : -1;
      else
        for (a = l = 0;a < o; a++)
          if (n[a] != i[a]) {
            l = n[a] > i[a] ? 1 : -1;
            break;
          }
      return l;
    }
    function t(n, i, o, s) {
      for (var a = 0;o--; )
        n[o] -= a, a = n[o] < i[o] ? 1 : 0, n[o] = a * s + n[o] - i[o];
      for (;!n[0] && n.length > 1; )
        n.shift();
    }
    return function(n, i, o, s, a, l) {
      var u, c, p, d, f, h, g, S, P, R, E, D, me, ae, Jr, V, te, Ae, H, fr, jt = n.constructor, ri = n.s == i.s ? 1 : -1, K = n.d, _ = i.d;
      if (!K || !K[0] || !_ || !_[0])
        return new jt(!n.s || !i.s || (K ? _ && K[0] == _[0] : !_) ? NaN : K && K[0] == 0 || !_ ? ri * 0 : ri / 0);
      for (l ? (f = 1, c = n.e - i.e) : (l = fe, f = b, c = X(n.e / f) - X(i.e / f)), H = _.length, te = K.length, P = new jt(ri), R = P.d = [], p = 0;_[p] == (K[p] || 0); p++)
        ;
      if (_[p] > (K[p] || 0) && c--, o == null ? (ae = o = jt.precision, s = jt.rounding) : a ? ae = o + (n.e - i.e) + 1 : ae = o, ae < 0)
        R.push(1), h = true;
      else {
        if (ae = ae / f + 2 | 0, p = 0, H == 1) {
          for (d = 0, _ = _[0], ae++;(p < te || d) && ae--; p++)
            Jr = d * l + (K[p] || 0), R[p] = Jr / _ | 0, d = Jr % _ | 0;
          h = d || p < te;
        } else {
          for (d = l / (_[0] + 1) | 0, d > 1 && (_ = e(_, d, l), K = e(K, d, l), H = _.length, te = K.length), V = H, E = K.slice(0, H), D = E.length;D < H; )
            E[D++] = 0;
          fr = _.slice(), fr.unshift(0), Ae = _[0], _[1] >= l / 2 && ++Ae;
          do
            d = 0, u = r(_, E, H, D), u < 0 ? (me = E[0], H != D && (me = me * l + (E[1] || 0)), d = me / Ae | 0, d > 1 ? (d >= l && (d = l - 1), g = e(_, d, l), S = g.length, D = E.length, u = r(g, E, S, D), u == 1 && (d--, t(g, H < S ? fr : _, S, l))) : (d == 0 && (u = d = 1), g = _.slice()), S = g.length, S < D && g.unshift(0), t(E, g, D, l), u == -1 && (D = E.length, u = r(_, E, H, D), u < 1 && (d++, t(E, H < D ? fr : _, D, l))), D = E.length) : u === 0 && (d++, E = [0]), R[p++] = d, u && E[0] ? E[D++] = K[V] || 0 : (E = [K[V]], D = 1);
          while ((V++ < te || E[0] !== undefined) && ae--);
          h = E[0] !== undefined;
        }
        R[0] || R.shift();
      }
      if (f == 1)
        P.e = c, js = h;
      else {
        for (p = 1, d = R[0];d >= 10; d /= 10)
          p++;
        P.e = p + c * f - 1, y(P, a ? o + P.e + 1 : o, s, h);
      }
      return P;
    };
  }();
  function y(e, r, t, n) {
    var i, o, s, a, l, u, c, p, d, f = e.constructor;
    e:
      if (r != null) {
        if (p = e.d, !p)
          return e;
        for (i = 1, a = p[0];a >= 10; a /= 10)
          i++;
        if (o = r - i, o < 0)
          o += b, s = r, c = p[d = 0], l = c / U(10, i - s - 1) % 10 | 0;
        else if (d = Math.ceil((o + 1) / b), a = p.length, d >= a)
          if (n) {
            for (;a++ <= d; )
              p.push(0);
            c = l = 0, i = 1, o %= b, s = o - b + 1;
          } else
            break e;
        else {
          for (c = a = p[d], i = 1;a >= 10; a /= 10)
            i++;
          o %= b, s = o - b + i, l = s < 0 ? 0 : c / U(10, i - s - 1) % 10 | 0;
        }
        if (n = n || r < 0 || p[d + 1] !== undefined || (s < 0 ? c : c % U(10, i - s - 1)), u = t < 4 ? (l || n) && (t == 0 || t == (e.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (t == 4 || n || t == 6 && (o > 0 ? s > 0 ? c / U(10, i - s) : 0 : p[d - 1]) % 10 & 1 || t == (e.s < 0 ? 8 : 7)), r < 1 || !p[0])
          return p.length = 0, u ? (r -= e.e + 1, p[0] = U(10, (b - r % b) % b), e.e = -r || 0) : p[0] = e.e = 0, e;
        if (o == 0 ? (p.length = d, a = 1, d--) : (p.length = d + 1, a = U(10, b - o), p[d] = s > 0 ? (c / U(10, i - s) % U(10, s) | 0) * a : 0), u)
          for (;; )
            if (d == 0) {
              for (o = 1, s = p[0];s >= 10; s /= 10)
                o++;
              for (s = p[0] += a, a = 1;s >= 10; s /= 10)
                a++;
              o != a && (e.e++, p[0] == fe && (p[0] = 1));
              break;
            } else {
              if (p[d] += a, p[d] != fe)
                break;
              p[d--] = 0, a = 1;
            }
        for (o = p.length;p[--o] === 0; )
          p.pop();
      }
    return w && (e.e > f.maxE ? (e.d = null, e.e = NaN) : e.e < f.minE && (e.e = 0, e.d = [0])), e;
  }
  function xe(e, r, t) {
    if (!e.isFinite())
      return Hs(e);
    var n, i = e.e, o = J(e.d), s = o.length;
    return r ? (t && (n = t - s) > 0 ? o = o.charAt(0) + "." + o.slice(1) + We(n) : s > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (o = "0." + We(-i - 1) + o, t && (n = t - s) > 0 && (o += We(n))) : i >= s ? (o += We(i + 1 - s), t && (n = t - i - 1) > 0 && (o = o + "." + We(n))) : ((n = i + 1) < s && (o = o.slice(0, n) + "." + o.slice(n)), t && (n = t - s) > 0 && (i + 1 === s && (o += "."), o += We(n))), o;
  }
  function gn(e, r) {
    var t = e[0];
    for (r *= b;t >= 10; t /= 10)
      r++;
    return r;
  }
  function mn(e, r, t) {
    if (r > vp)
      throw w = true, t && (e.precision = t), Error(Vs);
    return y(new e(pn), r, 1, true);
  }
  function we(e, r, t) {
    if (r > Bi)
      throw Error(Vs);
    return y(new e(dn), r, t, true);
  }
  function Qs(e) {
    var r = e.length - 1, t = r * b + 1;
    if (r = e[r], r) {
      for (;r % 10 == 0; r /= 10)
        t--;
      for (r = e[0];r >= 10; r /= 10)
        t++;
    }
    return t;
  }
  function We(e) {
    for (var r = "";e--; )
      r += "0";
    return r;
  }
  function Ws(e, r, t, n) {
    var i, o = new e(1), s = Math.ceil(n / b + 4);
    for (w = false;; ) {
      if (t % 2 && (o = o.times(r), $s(o.d, s) && (i = true)), t = X(t / 2), t === 0) {
        t = o.d.length - 1, i && o.d[t] === 0 && ++o.d[t];
        break;
      }
      r = r.times(r), $s(r.d, s);
    }
    return w = true, o;
  }
  function Ms(e) {
    return e.d[e.d.length - 1] & 1;
  }
  function Js(e, r, t) {
    for (var n, i, o = new e(r[0]), s = 0;++s < r.length; ) {
      if (i = new e(r[s]), !i.s) {
        o = i;
        break;
      }
      n = o.cmp(i), (n === t || n === 0 && o.s === t) && (o = i);
    }
    return o;
  }
  function Ui(e, r) {
    var t, n, i, o, s, a, l, u = 0, c = 0, p = 0, d = e.constructor, f = d.rounding, h = d.precision;
    if (!e.d || !e.d[0] || e.e > 17)
      return new d(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : NaN);
    for (r == null ? (w = false, l = h) : l = r, a = new d(0.03125);e.e > -2; )
      e = e.times(a), p += 5;
    for (n = Math.log(U(2, p)) / Math.LN10 * 2 + 5 | 0, l += n, t = o = s = new d(1), d.precision = l;; ) {
      if (o = y(o.times(e), l, 1), t = t.times(++c), a = s.plus(L(o, t, l, 1)), J(a.d).slice(0, l) === J(s.d).slice(0, l)) {
        for (i = p;i--; )
          s = y(s.times(s), l, 1);
        if (r == null)
          if (u < 3 && at(s.d, l - n, f, u))
            d.precision = l += 10, t = o = a = new d(1), c = 0, u++;
          else
            return y(s, d.precision = h, f, w = true);
        else
          return d.precision = h, s;
      }
      s = a;
    }
  }
  function Je(e, r) {
    var t, n, i, o, s, a, l, u, c, p, d, f = 1, h = 10, g = e, S = g.d, P = g.constructor, R = P.rounding, E = P.precision;
    if (g.s < 0 || !S || !S[0] || !g.e && S[0] == 1 && S.length == 1)
      return new P(S && !S[0] ? -1 / 0 : g.s != 1 ? NaN : S ? 0 : g);
    if (r == null ? (w = false, c = E) : c = r, P.precision = c += h, t = J(S), n = t.charAt(0), Math.abs(o = g.e) < 1500000000000000) {
      for (;n < 7 && n != 1 || n == 1 && t.charAt(1) > 3; )
        g = g.times(e), t = J(g.d), n = t.charAt(0), f++;
      o = g.e, n > 1 ? (g = new P("0." + t), o++) : g = new P(n + "." + t.slice(1));
    } else
      return u = mn(P, c + 2, E).times(o + ""), g = Je(new P(n + "." + t.slice(1)), c - h).plus(u), P.precision = E, r == null ? y(g, E, R, w = true) : g;
    for (p = g, l = s = g = L(g.minus(1), g.plus(1), c, 1), d = y(g.times(g), c, 1), i = 3;; ) {
      if (s = y(s.times(d), c, 1), u = l.plus(L(s, new P(i), c, 1)), J(u.d).slice(0, c) === J(l.d).slice(0, c))
        if (l = l.times(2), o !== 0 && (l = l.plus(mn(P, c + 2, E).times(o + ""))), l = L(l, new P(f), c, 1), r == null)
          if (at(l.d, c - h, R, a))
            P.precision = c += h, u = s = g = L(p.minus(1), p.plus(1), c, 1), d = y(g.times(g), c, 1), i = a = 1;
          else
            return y(l, P.precision = E, R, w = true);
        else
          return P.precision = E, l;
      l = u, i += 2;
    }
  }
  function Hs(e) {
    return String(e.s * e.s / 0);
  }
  function cn(e, r) {
    var t, n, i;
    for ((t = r.indexOf(".")) > -1 && (r = r.replace(".", "")), (n = r.search(/e/i)) > 0 ? (t < 0 && (t = n), t += +r.slice(n + 1), r = r.substring(0, n)) : t < 0 && (t = r.length), n = 0;r.charCodeAt(n) === 48; n++)
      ;
    for (i = r.length;r.charCodeAt(i - 1) === 48; --i)
      ;
    if (r = r.slice(n, i), r) {
      if (i -= n, e.e = t = t - n - 1, e.d = [], n = (t + 1) % b, t < 0 && (n += b), n < i) {
        for (n && e.d.push(+r.slice(0, n)), i -= b;n < i; )
          e.d.push(+r.slice(n, n += b));
        r = r.slice(n), n = b - r.length;
      } else
        n -= i;
      for (;n--; )
        r += "0";
      e.d.push(+r), w && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
    } else
      e.e = 0, e.d = [0];
    return e;
  }
  function Tp(e, r) {
    var t, n, i, o, s, a, l, u, c;
    if (r.indexOf("_") > -1) {
      if (r = r.replace(/(\d)_(?=\d)/g, "$1"), Gs.test(r))
        return cn(e, r);
    } else if (r === "Infinity" || r === "NaN")
      return +r || (e.s = NaN), e.e = NaN, e.d = null, e;
    if (bp.test(r))
      t = 16, r = r.toLowerCase();
    else if (Ep.test(r))
      t = 2;
    else if (wp.test(r))
      t = 8;
    else
      throw Error(He + r);
    for (o = r.search(/p/i), o > 0 ? (l = +r.slice(o + 1), r = r.substring(2, o)) : r = r.slice(2), o = r.indexOf("."), s = o >= 0, n = e.constructor, s && (r = r.replace(".", ""), a = r.length, o = a - o, i = Ws(n, new n(t), o, o * 2)), u = un(r, t, fe), c = u.length - 1, o = c;u[o] === 0; --o)
      u.pop();
    return o < 0 ? new n(e.s * 0) : (e.e = gn(u, c), e.d = u, w = false, s && (e = L(e, i, a * 4)), l && (e = e.times(Math.abs(l) < 54 ? U(2, l) : sr.pow(2, l))), w = true, e);
  }
  function Sp(e, r) {
    var t, n = r.d.length;
    if (n < 3)
      return r.isZero() ? r : Pr(e, 2, r, r);
    t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, r = r.times(1 / hn(5, t)), r = Pr(e, 2, r, r);
    for (var i, o = new e(5), s = new e(16), a = new e(20);t--; )
      i = r.times(r), r = r.times(o.plus(i.times(s.times(i).minus(a))));
    return r;
  }
  function Pr(e, r, t, n, i) {
    var o, s, a, l, u = 1, c = e.precision, p = Math.ceil(c / b);
    for (w = false, l = t.times(t), a = new e(n);; ) {
      if (s = L(a.times(l), new e(r++ * r++), c, 1), a = i ? n.plus(s) : n.minus(s), n = L(s.times(l), new e(r++ * r++), c, 1), s = a.plus(n), s.d[p] !== undefined) {
        for (o = p;s.d[o] === a.d[o] && o--; )
          ;
        if (o == -1)
          break;
      }
      o = a, a = n, n = s, s = o, u++;
    }
    return w = true, s.d.length = p + 1, s;
  }
  function hn(e, r) {
    for (var t = e;--r; )
      t *= e;
    return t;
  }
  function Ks(e, r) {
    var t, n = r.s < 0, i = we(e, e.precision, 1), o = i.times(0.5);
    if (r = r.abs(), r.lte(o))
      return Le = n ? 4 : 1, r;
    if (t = r.divToInt(i), t.isZero())
      Le = n ? 3 : 2;
    else {
      if (r = r.minus(t.times(i)), r.lte(o))
        return Le = Ms(t) ? n ? 2 : 3 : n ? 4 : 1, r;
      Le = Ms(t) ? n ? 1 : 4 : n ? 3 : 2;
    }
    return r.minus(i).abs();
  }
  function Gi(e, r, t, n) {
    var i, o, s, a, l, u, c, p, d, f = e.constructor, h = t !== undefined;
    if (h ? (ie(t, 1, Ke), n === undefined ? n = f.rounding : ie(n, 0, 8)) : (t = f.precision, n = f.rounding), !e.isFinite())
      c = Hs(e);
    else {
      for (c = xe(e), s = c.indexOf("."), h ? (i = 2, r == 16 ? t = t * 4 - 3 : r == 8 && (t = t * 3 - 2)) : i = r, s >= 0 && (c = c.replace(".", ""), d = new f(1), d.e = c.length - s, d.d = un(xe(d), 10, i), d.e = d.d.length), p = un(c, 10, i), o = l = p.length;p[--l] == 0; )
        p.pop();
      if (!p[0])
        c = h ? "0p+0" : "0";
      else {
        if (s < 0 ? o-- : (e = new f(e), e.d = p, e.e = o, e = L(e, d, t, n, 0, i), p = e.d, o = e.e, u = js), s = p[t], a = i / 2, u = u || p[t + 1] !== undefined, u = n < 4 ? (s !== undefined || u) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : s > a || s === a && (n === 4 || u || n === 6 && p[t - 1] & 1 || n === (e.s < 0 ? 8 : 7)), p.length = t, u)
          for (;++p[--t] > i - 1; )
            p[t] = 0, t || (++o, p.unshift(1));
        for (l = p.length;!p[l - 1]; --l)
          ;
        for (s = 0, c = "";s < l; s++)
          c += ji.charAt(p[s]);
        if (h) {
          if (l > 1)
            if (r == 16 || r == 8) {
              for (s = r == 16 ? 4 : 3, --l;l % s; l++)
                c += "0";
              for (p = un(c, i, r), l = p.length;!p[l - 1]; --l)
                ;
              for (s = 1, c = "1.";s < l; s++)
                c += ji.charAt(p[s]);
            } else
              c = c.charAt(0) + "." + c.slice(1);
          c = c + (o < 0 ? "p" : "p+") + o;
        } else if (o < 0) {
          for (;++o; )
            c = "0" + c;
          c = "0." + c;
        } else if (++o > l)
          for (o -= l;o--; )
            c += "0";
        else
          o < l && (c = c.slice(0, o) + "." + c.slice(o));
      }
      c = (r == 16 ? "0x" : r == 2 ? "0b" : r == 8 ? "0o" : "") + c;
    }
    return e.s < 0 ? "-" + c : c;
  }
  function $s(e, r) {
    if (e.length > r)
      return e.length = r, true;
  }
  function Rp(e) {
    return new this(e).abs();
  }
  function Cp(e) {
    return new this(e).acos();
  }
  function Ap(e) {
    return new this(e).acosh();
  }
  function Ip(e, r) {
    return new this(e).plus(r);
  }
  function kp(e) {
    return new this(e).asin();
  }
  function Dp(e) {
    return new this(e).asinh();
  }
  function Op(e) {
    return new this(e).atan();
  }
  function _p(e) {
    return new this(e).atanh();
  }
  function Np(e, r) {
    e = new this(e), r = new this(r);
    var t, n = this.precision, i = this.rounding, o = n + 4;
    return !e.s || !r.s ? t = new this(NaN) : !e.d && !r.d ? (t = we(this, o, 1).times(r.s > 0 ? 0.25 : 0.75), t.s = e.s) : !r.d || e.isZero() ? (t = r.s < 0 ? we(this, n, i) : new this(0), t.s = e.s) : !e.d || r.isZero() ? (t = we(this, o, 1).times(0.5), t.s = e.s) : r.s < 0 ? (this.precision = o, this.rounding = 1, t = this.atan(L(e, r, o, 1)), r = we(this, o, 1), this.precision = n, this.rounding = i, t = e.s < 0 ? t.minus(r) : t.plus(r)) : t = this.atan(L(e, r, o, 1)), t;
  }
  function Lp(e) {
    return new this(e).cbrt();
  }
  function Fp(e) {
    return y(e = new this(e), e.e + 1, 2);
  }
  function Mp(e, r, t) {
    return new this(e).clamp(r, t);
  }
  function $p(e) {
    if (!e || typeof e != "object")
      throw Error(fn + "Object expected");
    var r, t, n, i = e.defaults === true, o = ["precision", 1, Ke, "rounding", 0, 8, "toExpNeg", -vr, 0, "toExpPos", 0, vr, "maxE", 0, vr, "minE", -vr, 0, "modulo", 0, 9];
    for (r = 0;r < o.length; r += 3)
      if (t = o[r], i && (this[t] = Vi[t]), (n = e[t]) !== undefined)
        if (X(n) === n && n >= o[r + 1] && n <= o[r + 2])
          this[t] = n;
        else
          throw Error(He + t + ": " + n);
    if (t = "crypto", i && (this[t] = Vi[t]), (n = e[t]) !== undefined)
      if (n === true || n === false || n === 0 || n === 1)
        if (n)
          if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
            this[t] = true;
          else
            throw Error(Bs);
        else
          this[t] = false;
      else
        throw Error(He + t + ": " + n);
    return this;
  }
  function qp(e) {
    return new this(e).cos();
  }
  function jp(e) {
    return new this(e).cosh();
  }
  function Ys(e) {
    var r, t, n;
    function i(o) {
      var s, a, l, u = this;
      if (!(u instanceof i))
        return new i(o);
      if (u.constructor = i, qs(o)) {
        u.s = o.s, w ? !o.d || o.e > i.maxE ? (u.e = NaN, u.d = null) : o.e < i.minE ? (u.e = 0, u.d = [0]) : (u.e = o.e, u.d = o.d.slice()) : (u.e = o.e, u.d = o.d ? o.d.slice() : o.d);
        return;
      }
      if (l = typeof o, l === "number") {
        if (o === 0) {
          u.s = 1 / o < 0 ? -1 : 1, u.e = 0, u.d = [0];
          return;
        }
        if (o < 0 ? (o = -o, u.s = -1) : u.s = 1, o === ~~o && o < 1e7) {
          for (s = 0, a = o;a >= 10; a /= 10)
            s++;
          w ? s > i.maxE ? (u.e = NaN, u.d = null) : s < i.minE ? (u.e = 0, u.d = [0]) : (u.e = s, u.d = [o]) : (u.e = s, u.d = [o]);
          return;
        }
        if (o * 0 !== 0) {
          o || (u.s = NaN), u.e = NaN, u.d = null;
          return;
        }
        return cn(u, o.toString());
      }
      if (l === "string")
        return (a = o.charCodeAt(0)) === 45 ? (o = o.slice(1), u.s = -1) : (a === 43 && (o = o.slice(1)), u.s = 1), Gs.test(o) ? cn(u, o) : Tp(u, o);
      if (l === "bigint")
        return o < 0 ? (o = -o, u.s = -1) : u.s = 1, cn(u, o.toString());
      throw Error(He + o);
    }
    if (i.prototype = m, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = $p, i.clone = Ys, i.isDecimal = qs, i.abs = Rp, i.acos = Cp, i.acosh = Ap, i.add = Ip, i.asin = kp, i.asinh = Dp, i.atan = Op, i.atanh = _p, i.atan2 = Np, i.cbrt = Lp, i.ceil = Fp, i.clamp = Mp, i.cos = qp, i.cosh = jp, i.div = Vp, i.exp = Bp, i.floor = Up, i.hypot = Gp, i.ln = Qp, i.log = Wp, i.log10 = Hp, i.log2 = Jp, i.max = Kp, i.min = Yp, i.mod = zp, i.mul = Zp, i.pow = Xp, i.random = ed, i.round = rd, i.sign = td, i.sin = nd, i.sinh = id, i.sqrt = od, i.sub = sd, i.sum = ad, i.tan = ld, i.tanh = ud, i.trunc = cd, e === undefined && (e = {}), e && e.defaults !== true)
      for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], r = 0;r < n.length; )
        e.hasOwnProperty(t = n[r++]) || (e[t] = this[t]);
    return i.config(e), i;
  }
  function Vp(e, r) {
    return new this(e).div(r);
  }
  function Bp(e) {
    return new this(e).exp();
  }
  function Up(e) {
    return y(e = new this(e), e.e + 1, 3);
  }
  function Gp() {
    var e, r, t = new this(0);
    for (w = false, e = 0;e < arguments.length; )
      if (r = new this(arguments[e++]), r.d)
        t.d && (t = t.plus(r.times(r)));
      else {
        if (r.s)
          return w = true, new this(1 / 0);
        t = r;
      }
    return w = true, t.sqrt();
  }
  function qs(e) {
    return e instanceof sr || e && e.toStringTag === Us || false;
  }
  function Qp(e) {
    return new this(e).ln();
  }
  function Wp(e, r) {
    return new this(e).log(r);
  }
  function Jp(e) {
    return new this(e).log(2);
  }
  function Hp(e) {
    return new this(e).log(10);
  }
  function Kp() {
    return Js(this, arguments, -1);
  }
  function Yp() {
    return Js(this, arguments, 1);
  }
  function zp(e, r) {
    return new this(e).mod(r);
  }
  function Zp(e, r) {
    return new this(e).mul(r);
  }
  function Xp(e, r) {
    return new this(e).pow(r);
  }
  function ed(e) {
    var r, t, n, i, o = 0, s = new this(1), a = [];
    if (e === undefined ? e = this.precision : ie(e, 1, Ke), n = Math.ceil(e / b), this.crypto)
      if (crypto.getRandomValues)
        for (r = crypto.getRandomValues(new Uint32Array(n));o < n; )
          i = r[o], i >= 4290000000 ? r[o] = crypto.getRandomValues(new Uint32Array(1))[0] : a[o++] = i % 1e7;
      else if (crypto.randomBytes) {
        for (r = crypto.randomBytes(n *= 4);o < n; )
          i = r[o] + (r[o + 1] << 8) + (r[o + 2] << 16) + ((r[o + 3] & 127) << 24), i >= 2140000000 ? crypto.randomBytes(4).copy(r, o) : (a.push(i % 1e7), o += 4);
        o = n / 4;
      } else
        throw Error(Bs);
    else
      for (;o < n; )
        a[o++] = Math.random() * 1e7 | 0;
    for (n = a[--o], e %= b, n && e && (i = U(10, b - e), a[o] = (n / i | 0) * i);a[o] === 0; o--)
      a.pop();
    if (o < 0)
      t = 0, a = [0];
    else {
      for (t = -1;a[0] === 0; t -= b)
        a.shift();
      for (n = 1, i = a[0];i >= 10; i /= 10)
        n++;
      n < b && (t -= b - n);
    }
    return s.e = t, s.d = a, s;
  }
  function rd(e) {
    return y(e = new this(e), e.e + 1, this.rounding);
  }
  function td(e) {
    return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
  }
  function nd(e) {
    return new this(e).sin();
  }
  function id(e) {
    return new this(e).sinh();
  }
  function od(e) {
    return new this(e).sqrt();
  }
  function sd(e, r) {
    return new this(e).sub(r);
  }
  function ad() {
    var e = 0, r = arguments, t = new this(r[e]);
    for (w = false;t.s && ++e < r.length; )
      t = t.plus(r[e]);
    return w = true, y(t, this.precision, this.rounding);
  }
  function ld(e) {
    return new this(e).tan();
  }
  function ud(e) {
    return new this(e).tanh();
  }
  function cd(e) {
    return y(e = new this(e), e.e + 1, 1);
  }
  m[Symbol.for("nodejs.util.inspect.custom")] = m.toString;
  m[Symbol.toStringTag] = "Decimal";
  var sr = m.constructor = Ys(Vi);
  pn = new sr(pn);
  dn = new sr(dn);
  var ve = sr;
  function Tr(e) {
    return e === null ? e : Array.isArray(e) ? e.map(Tr) : typeof e == "object" ? pd(e) ? dd(e) : e.constructor !== null && e.constructor.name !== "Object" ? e : xr(e, Tr) : e;
  }
  function pd(e) {
    return e !== null && typeof e == "object" && typeof e.$type == "string";
  }
  function dd({ $type: e, value: r }) {
    switch (e) {
      case "BigInt":
        return BigInt(r);
      case "Bytes": {
        let { buffer: t, byteOffset: n, byteLength: i } = Buffer.from(r, "base64");
        return new Uint8Array(t, n, i);
      }
      case "DateTime":
        return new Date(r);
      case "Decimal":
        return new ve(r);
      case "Json":
        return JSON.parse(r);
      default:
        _e(r, "Unknown tagged value");
    }
  }
  var Pe = class {
    _map = new Map;
    get(r) {
      return this._map.get(r)?.value;
    }
    set(r, t) {
      this._map.set(r, { value: t });
    }
    getOrCreate(r, t) {
      let n = this._map.get(r);
      if (n)
        return n.value;
      let i = t();
      return this.set(r, i), i;
    }
  };
  function Ye(e) {
    return e.substring(0, 1).toLowerCase() + e.substring(1);
  }
  function zs(e, r) {
    let t = {};
    for (let n of e) {
      let i = n[r];
      t[i] = n;
    }
    return t;
  }
  function lt(e) {
    let r;
    return { get() {
      return r || (r = { value: e() }), r.value;
    } };
  }
  function Zs(e) {
    return { models: Qi(e.models), enums: Qi(e.enums), types: Qi(e.types) };
  }
  function Qi(e) {
    let r = {};
    for (let { name: t, ...n } of e)
      r[t] = n;
    return r;
  }
  function Sr(e) {
    return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
  }
  function yn(e) {
    return e.toString() !== "Invalid Date";
  }
  function Rr(e) {
    return sr.isDecimal(e) ? true : e !== null && typeof e == "object" && typeof e.s == "number" && typeof e.e == "number" && typeof e.toFixed == "function" && Array.isArray(e.d);
  }
  var ut = {};
  tr(ut, { ModelAction: () => Cr, datamodelEnumToSchemaEnum: () => md });
  function md(e) {
    return { name: e.name, values: e.values.map((r) => r.name) };
  }
  var Cr = ((E) => (E.findUnique = "findUnique", E.findUniqueOrThrow = "findUniqueOrThrow", E.findFirst = "findFirst", E.findFirstOrThrow = "findFirstOrThrow", E.findMany = "findMany", E.create = "create", E.createMany = "createMany", E.createManyAndReturn = "createManyAndReturn", E.update = "update", E.updateMany = "updateMany", E.updateManyAndReturn = "updateManyAndReturn", E.upsert = "upsert", E.delete = "delete", E.deleteMany = "deleteMany", E.groupBy = "groupBy", E.count = "count", E.aggregate = "aggregate", E.findRaw = "findRaw", E.aggregateRaw = "aggregateRaw", E))(Cr || {});
  var na = k(Ai());
  var ta = k(__require("fs"));
  var Xs = { keyword: De, entity: De, value: (e) => W(nr(e)), punctuation: nr, directive: De, function: De, variable: (e) => W(nr(e)), string: (e) => W(qe(e)), boolean: ke, number: De, comment: Hr };
  var fd = (e) => e;
  var En = {};
  var gd = 0;
  var v = { manual: En.Prism && En.Prism.manual, disableWorkerMessageHandler: En.Prism && En.Prism.disableWorkerMessageHandler, util: { encode: function(e) {
    if (e instanceof ge) {
      let r = e;
      return new ge(r.type, v.util.encode(r.content), r.alias);
    } else
      return Array.isArray(e) ? e.map(v.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
  }, type: function(e) {
    return Object.prototype.toString.call(e).slice(8, -1);
  }, objId: function(e) {
    return e.__id || Object.defineProperty(e, "__id", { value: ++gd }), e.__id;
  }, clone: function e(r, t) {
    let n, i, o = v.util.type(r);
    switch (t = t || {}, o) {
      case "Object":
        if (i = v.util.objId(r), t[i])
          return t[i];
        n = {}, t[i] = n;
        for (let s in r)
          r.hasOwnProperty(s) && (n[s] = e(r[s], t));
        return n;
      case "Array":
        return i = v.util.objId(r), t[i] ? t[i] : (n = [], t[i] = n, r.forEach(function(s, a) {
          n[a] = e(s, t);
        }), n);
      default:
        return r;
    }
  } }, languages: { extend: function(e, r) {
    let t = v.util.clone(v.languages[e]);
    for (let n in r)
      t[n] = r[n];
    return t;
  }, insertBefore: function(e, r, t, n) {
    n = n || v.languages;
    let i = n[e], o = {};
    for (let a in i)
      if (i.hasOwnProperty(a)) {
        if (a == r)
          for (let l in t)
            t.hasOwnProperty(l) && (o[l] = t[l]);
        t.hasOwnProperty(a) || (o[a] = i[a]);
      }
    let s = n[e];
    return n[e] = o, v.languages.DFS(v.languages, function(a, l) {
      l === s && a != e && (this[a] = o);
    }), o;
  }, DFS: function e(r, t, n, i) {
    i = i || {};
    let o = v.util.objId;
    for (let s in r)
      if (r.hasOwnProperty(s)) {
        t.call(r, s, r[s], n || s);
        let a = r[s], l = v.util.type(a);
        l === "Object" && !i[o(a)] ? (i[o(a)] = true, e(a, t, null, i)) : l === "Array" && !i[o(a)] && (i[o(a)] = true, e(a, t, s, i));
      }
  } }, plugins: {}, highlight: function(e, r, t) {
    let n = { code: e, grammar: r, language: t };
    return v.hooks.run("before-tokenize", n), n.tokens = v.tokenize(n.code, n.grammar), v.hooks.run("after-tokenize", n), ge.stringify(v.util.encode(n.tokens), n.language);
  }, matchGrammar: function(e, r, t, n, i, o, s) {
    for (let g in t) {
      if (!t.hasOwnProperty(g) || !t[g])
        continue;
      if (g == s)
        return;
      let S = t[g];
      S = v.util.type(S) === "Array" ? S : [S];
      for (let P = 0;P < S.length; ++P) {
        let R = S[P], E = R.inside, D = !!R.lookbehind, me = !!R.greedy, ae = 0, Jr = R.alias;
        if (me && !R.pattern.global) {
          let V = R.pattern.toString().match(/[imuy]*$/)[0];
          R.pattern = RegExp(R.pattern.source, V + "g");
        }
        R = R.pattern || R;
        for (let V = n, te = i;V < r.length; te += r[V].length, ++V) {
          let Ae = r[V];
          if (r.length > e.length)
            return;
          if (Ae instanceof ge)
            continue;
          if (me && V != r.length - 1) {
            R.lastIndex = te;
            var p = R.exec(e);
            if (!p)
              break;
            var c = p.index + (D ? p[1].length : 0), d = p.index + p[0].length, a = V, l = te;
            for (let _ = r.length;a < _ && (l < d || !r[a].type && !r[a - 1].greedy); ++a)
              l += r[a].length, c >= l && (++V, te = l);
            if (r[V] instanceof ge)
              continue;
            u = a - V, Ae = e.slice(te, l), p.index -= te;
          } else {
            R.lastIndex = 0;
            var p = R.exec(Ae), u = 1;
          }
          if (!p) {
            if (o)
              break;
            continue;
          }
          D && (ae = p[1] ? p[1].length : 0);
          var c = p.index + ae, p = p[0].slice(ae), d = c + p.length, f = Ae.slice(0, c), h = Ae.slice(d);
          let H = [V, u];
          f && (++V, te += f.length, H.push(f));
          let fr = new ge(g, E ? v.tokenize(p, E) : p, Jr, p, me);
          if (H.push(fr), h && H.push(h), Array.prototype.splice.apply(r, H), u != 1 && v.matchGrammar(e, r, t, V, te, true, g), o)
            break;
        }
      }
    }
  }, tokenize: function(e, r) {
    let t = [e], n = r.rest;
    if (n) {
      for (let i in n)
        r[i] = n[i];
      delete r.rest;
    }
    return v.matchGrammar(e, t, r, 0, 0, false), t;
  }, hooks: { all: {}, add: function(e, r) {
    let t = v.hooks.all;
    t[e] = t[e] || [], t[e].push(r);
  }, run: function(e, r) {
    let t = v.hooks.all[e];
    if (!(!t || !t.length))
      for (var n = 0, i;i = t[n++]; )
        i(r);
  } }, Token: ge };
  v.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
  v.languages.javascript = v.languages.extend("clike", { "class-name": [v.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
  v.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  v.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: v.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: v.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: v.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: v.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
  v.languages.markup && v.languages.markup.tag.addInlined("script", "javascript");
  v.languages.js = v.languages.javascript;
  v.languages.typescript = v.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
  v.languages.ts = v.languages.typescript;
  function ge(e, r, t, n, i) {
    this.type = e, this.content = r, this.alias = t, this.length = (n || "").length | 0, this.greedy = !!i;
  }
  ge.stringify = function(e, r) {
    return typeof e == "string" ? e : Array.isArray(e) ? e.map(function(t) {
      return ge.stringify(t, r);
    }).join("") : hd(e.type)(e.content);
  };
  function hd(e) {
    return Xs[e] || fd;
  }
  function ea(e) {
    return yd(e, v.languages.javascript);
  }
  function yd(e, r) {
    return v.tokenize(e, r).map((n) => ge.stringify(n)).join("");
  }
  function ra(e) {
    return Ri(e);
  }
  var bn = class e {
    firstLineNumber;
    lines;
    static read(r) {
      let t;
      try {
        t = ta.default.readFileSync(r, "utf-8");
      } catch {
        return null;
      }
      return e.fromContent(t);
    }
    static fromContent(r) {
      let t = r.split(/\r?\n/);
      return new e(1, t);
    }
    constructor(r, t) {
      this.firstLineNumber = r, this.lines = t;
    }
    get lastLineNumber() {
      return this.firstLineNumber + this.lines.length - 1;
    }
    mapLineAt(r, t) {
      if (r < this.firstLineNumber || r > this.lines.length + this.firstLineNumber)
        return this;
      let n = r - this.firstLineNumber, i = [...this.lines];
      return i[n] = t(i[n]), new e(this.firstLineNumber, i);
    }
    mapLines(r) {
      return new e(this.firstLineNumber, this.lines.map((t, n) => r(t, this.firstLineNumber + n)));
    }
    lineAt(r) {
      return this.lines[r - this.firstLineNumber];
    }
    prependSymbolAt(r, t) {
      return this.mapLines((n, i) => i === r ? `${t} ${n}` : `  ${n}`);
    }
    slice(r, t) {
      let n = this.lines.slice(r - 1, t).join(`
`);
      return new e(r, ra(n).split(`
`));
    }
    highlight() {
      let r = ea(this.toString());
      return new e(this.firstLineNumber, r.split(`
`));
    }
    toString() {
      return this.lines.join(`
`);
    }
  };
  var Ed = { red: ce, gray: Hr, dim: Ie, bold: W, underline: Y, highlightSource: (e) => e.highlight() };
  var bd = { red: (e) => e, gray: (e) => e, dim: (e) => e, bold: (e) => e, underline: (e) => e, highlightSource: (e) => e };
  function wd({ message: e, originalMethod: r, isPanic: t, callArguments: n }) {
    return { functionName: `prisma.${r}()`, message: e, isPanic: t ?? false, callArguments: n };
  }
  function xd({ callsite: e, message: r, originalMethod: t, isPanic: n, callArguments: i }, o) {
    let s = wd({ message: r, originalMethod: t, isPanic: n, callArguments: i });
    if (!e || typeof window < "u" || false)
      return s;
    let a = e.getLocation();
    if (!a || !a.lineNumber || !a.columnNumber)
      return s;
    let l = Math.max(1, a.lineNumber - 3), u = bn.read(a.fileName)?.slice(l, a.lineNumber), c = u?.lineAt(a.lineNumber);
    if (u && c) {
      let p = Pd(c), d = vd(c);
      if (!d)
        return s;
      s.functionName = `${d.code})`, s.location = a, n || (u = u.mapLineAt(a.lineNumber, (h) => h.slice(0, d.openingBraceIndex))), u = o.highlightSource(u);
      let f = String(u.lastLineNumber).length;
      if (s.contextLines = u.mapLines((h, g) => o.gray(String(g).padStart(f)) + " " + h).mapLines((h) => o.dim(h)).prependSymbolAt(a.lineNumber, o.bold(o.red("\u2192"))), i) {
        let h = p + f + 1;
        h += 2, s.callArguments = (0, na.default)(i, h).slice(h);
      }
    }
    return s;
  }
  function vd(e) {
    let r = Object.keys(Cr).join("|"), n = new RegExp(String.raw`\.(${r})\(`).exec(e);
    if (n) {
      let i = n.index + n[0].length, o = e.lastIndexOf(" ", n.index) + 1;
      return { code: e.slice(o, i), openingBraceIndex: i };
    }
    return null;
  }
  function Pd(e) {
    let r = 0;
    for (let t = 0;t < e.length; t++) {
      if (e.charAt(t) !== " ")
        return r;
      r++;
    }
    return r;
  }
  function Td({ functionName: e, location: r, message: t, isPanic: n, contextLines: i, callArguments: o }, s) {
    let a = [""], l = r ? " in" : ":";
    if (n ? (a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)), a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))) : a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)), r && a.push(s.underline(Sd(r))), i) {
      a.push("");
      let u = [i.toString()];
      o && (u.push(o), u.push(s.dim(")"))), a.push(u.join("")), o && a.push("");
    } else
      a.push(""), o && a.push(o), a.push("");
    return a.push(t), a.join(`
`);
  }
  function Sd(e) {
    let r = [e.fileName];
    return e.lineNumber && r.push(String(e.lineNumber)), e.columnNumber && r.push(String(e.columnNumber)), r.join(":");
  }
  function wn(e) {
    let r = e.showColors ? Ed : bd, t;
    return t = xd(e, r), Td(t, r);
  }
  var da = k(Wi());
  function aa(e, r, t) {
    let n = la(e), i = Rd(n), o = Ad(i);
    o ? xn(o, r, t) : r.addErrorMessage(() => "Unknown error");
  }
  function la(e) {
    return e.errors.flatMap((r) => r.kind === "Union" ? la(r) : [r]);
  }
  function Rd(e) {
    let r = new Map, t = [];
    for (let n of e) {
      if (n.kind !== "InvalidArgumentType") {
        t.push(n);
        continue;
      }
      let i = `${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`, o = r.get(i);
      o ? r.set(i, { ...n, argument: { ...n.argument, typeNames: Cd(o.argument.typeNames, n.argument.typeNames) } }) : r.set(i, n);
    }
    return t.push(...r.values()), t;
  }
  function Cd(e, r) {
    return [...new Set(e.concat(r))];
  }
  function Ad(e) {
    return qi(e, (r, t) => {
      let n = oa(r), i = oa(t);
      return n !== i ? n - i : sa(r) - sa(t);
    });
  }
  function oa(e) {
    let r = 0;
    return Array.isArray(e.selectionPath) && (r += e.selectionPath.length), Array.isArray(e.argumentPath) && (r += e.argumentPath.length), r;
  }
  function sa(e) {
    switch (e.kind) {
      case "InvalidArgumentValue":
      case "ValueTooLarge":
        return 20;
      case "InvalidArgumentType":
        return 10;
      case "RequiredArgumentMissing":
        return -10;
      default:
        return 0;
    }
  }
  var ue = class {
    constructor(r, t) {
      this.name = r;
      this.value = t;
    }
    isRequired = false;
    makeRequired() {
      return this.isRequired = true, this;
    }
    write(r) {
      let { colors: { green: t } } = r.context;
      r.addMarginSymbol(t(this.isRequired ? "+" : "?")), r.write(t(this.name)), this.isRequired || r.write(t("?")), r.write(t(": ")), typeof this.value == "string" ? r.write(t(this.value)) : r.write(this.value);
    }
  };
  ca();
  var Ar = class {
    constructor(r = 0, t) {
      this.context = t;
      this.currentIndent = r;
    }
    lines = [];
    currentLine = "";
    currentIndent = 0;
    marginSymbol;
    afterNextNewLineCallback;
    write(r) {
      return typeof r == "string" ? this.currentLine += r : r.write(this), this;
    }
    writeJoined(r, t, n = (i, o) => o.write(i)) {
      let i = t.length - 1;
      for (let o = 0;o < t.length; o++)
        n(t[o], this), o !== i && this.write(r);
      return this;
    }
    writeLine(r) {
      return this.write(r).newLine();
    }
    newLine() {
      this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = undefined;
      let r = this.afterNextNewLineCallback;
      return this.afterNextNewLineCallback = undefined, r?.(), this;
    }
    withIndent(r) {
      return this.indent(), r(this), this.unindent(), this;
    }
    afterNextNewline(r) {
      return this.afterNextNewLineCallback = r, this;
    }
    indent() {
      return this.currentIndent++, this;
    }
    unindent() {
      return this.currentIndent > 0 && this.currentIndent--, this;
    }
    addMarginSymbol(r) {
      return this.marginSymbol = r, this;
    }
    toString() {
      return this.lines.concat(this.indentedCurrentLine()).join(`
`);
    }
    getCurrentLineLength() {
      return this.currentLine.length;
    }
    indentedCurrentLine() {
      let r = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
      return this.marginSymbol ? this.marginSymbol + r.slice(1) : r;
    }
  };
  ua();
  var vn = class {
    constructor(r) {
      this.value = r;
    }
    write(r) {
      r.write(this.value);
    }
    markAsError() {
      this.value.markAsError();
    }
  };
  var Pn = (e) => e;
  var Tn = { bold: Pn, red: Pn, green: Pn, dim: Pn, enabled: false };
  var pa = { bold: W, red: ce, green: qe, dim: Ie, enabled: true };
  var Ir = { write(e) {
    e.writeLine(",");
  } };
  var Te = class {
    constructor(r) {
      this.contents = r;
    }
    isUnderlined = false;
    color = (r) => r;
    underline() {
      return this.isUnderlined = true, this;
    }
    setColor(r) {
      return this.color = r, this;
    }
    write(r) {
      let t = r.getCurrentLineLength();
      r.write(this.color(this.contents)), this.isUnderlined && r.afterNextNewline(() => {
        r.write(" ".repeat(t)).writeLine(this.color("~".repeat(this.contents.length)));
      });
    }
  };
  var ze = class {
    hasError = false;
    markAsError() {
      return this.hasError = true, this;
    }
  };
  var kr = class extends ze {
    items = [];
    addItem(r) {
      return this.items.push(new vn(r)), this;
    }
    getField(r) {
      return this.items[r];
    }
    getPrintWidth() {
      return this.items.length === 0 ? 2 : Math.max(...this.items.map((t) => t.value.getPrintWidth())) + 2;
    }
    write(r) {
      if (this.items.length === 0) {
        this.writeEmpty(r);
        return;
      }
      this.writeWithItems(r);
    }
    writeEmpty(r) {
      let t = new Te("[]");
      this.hasError && t.setColor(r.context.colors.red).underline(), r.write(t);
    }
    writeWithItems(r) {
      let { colors: t } = r.context;
      r.writeLine("[").withIndent(() => r.writeJoined(Ir, this.items).newLine()).write("]"), this.hasError && r.afterNextNewline(() => {
        r.writeLine(t.red("~".repeat(this.getPrintWidth())));
      });
    }
    asObject() {}
  };
  var Dr = class e extends ze {
    fields = {};
    suggestions = [];
    addField(r) {
      this.fields[r.name] = r;
    }
    addSuggestion(r) {
      this.suggestions.push(r);
    }
    getField(r) {
      return this.fields[r];
    }
    getDeepField(r) {
      let [t, ...n] = r, i = this.getField(t);
      if (!i)
        return;
      let o = i;
      for (let s of n) {
        let a;
        if (o.value instanceof e ? a = o.value.getField(s) : o.value instanceof kr && (a = o.value.getField(Number(s))), !a)
          return;
        o = a;
      }
      return o;
    }
    getDeepFieldValue(r) {
      return r.length === 0 ? this : this.getDeepField(r)?.value;
    }
    hasField(r) {
      return !!this.getField(r);
    }
    removeAllFields() {
      this.fields = {};
    }
    removeField(r) {
      delete this.fields[r];
    }
    getFields() {
      return this.fields;
    }
    isEmpty() {
      return Object.keys(this.fields).length === 0;
    }
    getFieldValue(r) {
      return this.getField(r)?.value;
    }
    getDeepSubSelectionValue(r) {
      let t = this;
      for (let n of r) {
        if (!(t instanceof e))
          return;
        let i = t.getSubSelectionValue(n);
        if (!i)
          return;
        t = i;
      }
      return t;
    }
    getDeepSelectionParent(r) {
      let t = this.getSelectionParent();
      if (!t)
        return;
      let n = t;
      for (let i of r) {
        let o = n.value.getFieldValue(i);
        if (!o || !(o instanceof e))
          return;
        let s = o.getSelectionParent();
        if (!s)
          return;
        n = s;
      }
      return n;
    }
    getSelectionParent() {
      let r = this.getField("select")?.value.asObject();
      if (r)
        return { kind: "select", value: r };
      let t = this.getField("include")?.value.asObject();
      if (t)
        return { kind: "include", value: t };
    }
    getSubSelectionValue(r) {
      return this.getSelectionParent()?.value.fields[r].value;
    }
    getPrintWidth() {
      let r = Object.values(this.fields);
      return r.length == 0 ? 2 : Math.max(...r.map((n) => n.getPrintWidth())) + 2;
    }
    write(r) {
      let t = Object.values(this.fields);
      if (t.length === 0 && this.suggestions.length === 0) {
        this.writeEmpty(r);
        return;
      }
      this.writeWithContents(r, t);
    }
    asObject() {
      return this;
    }
    writeEmpty(r) {
      let t = new Te("{}");
      this.hasError && t.setColor(r.context.colors.red).underline(), r.write(t);
    }
    writeWithContents(r, t) {
      r.writeLine("{").withIndent(() => {
        r.writeJoined(Ir, [...t, ...this.suggestions]).newLine();
      }), r.write("}"), this.hasError && r.afterNextNewline(() => {
        r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var Q = class extends ze {
    constructor(t) {
      super();
      this.text = t;
    }
    getPrintWidth() {
      return this.text.length;
    }
    write(t) {
      let n = new Te(this.text);
      this.hasError && n.underline().setColor(t.context.colors.red), t.write(n);
    }
    asObject() {}
  };
  var ct = class {
    fields = [];
    addField(r, t) {
      return this.fields.push({ write(n) {
        let { green: i, dim: o } = n.context.colors;
        n.write(i(o(`${r}: ${t}`))).addMarginSymbol(i(o("+")));
      } }), this;
    }
    write(r) {
      let { colors: { green: t } } = r.context;
      r.writeLine(t("{")).withIndent(() => {
        r.writeJoined(Ir, this.fields).newLine();
      }).write(t("}")).addMarginSymbol(t("+"));
    }
  };
  function xn(e, r, t) {
    switch (e.kind) {
      case "MutuallyExclusiveFields":
        Id(e, r);
        break;
      case "IncludeOnScalar":
        kd(e, r);
        break;
      case "EmptySelection":
        Dd(e, r, t);
        break;
      case "UnknownSelectionField":
        Ld(e, r);
        break;
      case "InvalidSelectionValue":
        Fd(e, r);
        break;
      case "UnknownArgument":
        Md(e, r);
        break;
      case "UnknownInputField":
        $d(e, r);
        break;
      case "RequiredArgumentMissing":
        qd(e, r);
        break;
      case "InvalidArgumentType":
        jd(e, r);
        break;
      case "InvalidArgumentValue":
        Vd(e, r);
        break;
      case "ValueTooLarge":
        Bd(e, r);
        break;
      case "SomeFieldsMissing":
        Ud(e, r);
        break;
      case "TooManyFieldsGiven":
        Gd(e, r);
        break;
      case "Union":
        aa(e, r, t);
        break;
      default:
        throw new Error("not implemented: " + e.kind);
    }
  }
  function Id(e, r) {
    let t = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    t && (t.getField(e.firstField)?.markAsError(), t.getField(e.secondField)?.markAsError()), r.addErrorMessage((n) => `Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`);
  }
  function kd(e, r) {
    let [t, n] = pt(e.selectionPath), i = e.outputType, o = r.arguments.getDeepSelectionParent(t)?.value;
    if (o && (o.getField(n)?.markAsError(), i))
      for (let s of i.fields)
        s.isRelation && o.addSuggestion(new ue(s.name, "true"));
    r.addErrorMessage((s) => {
      let a = `Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;
      return i ? a += ` on model ${s.bold(i.name)}. ${dt(s)}` : a += ".", a += `
Note that ${s.bold("include")} statements only accept relation fields.`, a;
    });
  }
  function Dd(e, r, t) {
    let n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    if (n) {
      let i = n.getField("omit")?.value.asObject();
      if (i) {
        Od(e, r, i);
        return;
      }
      if (n.hasField("select")) {
        _d(e, r);
        return;
      }
    }
    if (t?.[Ye(e.outputType.name)]) {
      Nd(e, r);
      return;
    }
    r.addErrorMessage(() => `Unknown field at "${e.selectionPath.join(".")} selection"`);
  }
  function Od(e, r, t) {
    t.removeAllFields();
    for (let n of e.outputType.fields)
      t.addSuggestion(new ue(n.name, "false"));
    r.addErrorMessage((n) => `The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`);
  }
  function _d(e, r) {
    let t = e.outputType, n = r.arguments.getDeepSelectionParent(e.selectionPath)?.value, i = n?.isEmpty() ?? false;
    n && (n.removeAllFields(), ga(n, t)), r.addErrorMessage((o) => i ? `The ${o.red("`select`")} statement for type ${o.bold(t.name)} must not be empty. ${dt(o)}` : `The ${o.red("`select`")} statement for type ${o.bold(t.name)} needs ${o.bold("at least one truthy value")}.`);
  }
  function Nd(e, r) {
    let t = new ct;
    for (let i of e.outputType.fields)
      i.isRelation || t.addField(i.name, "false");
    let n = new ue("omit", t).makeRequired();
    if (e.selectionPath.length === 0)
      r.arguments.addSuggestion(n);
    else {
      let [i, o] = pt(e.selectionPath), a = r.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);
      if (a) {
        let l = a?.value.asObject() ?? new Dr;
        l.addSuggestion(n), a.value = l;
      }
    }
    r.addErrorMessage((i) => `The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`);
  }
  function Ld(e, r) {
    let t = ha(e.selectionPath, r);
    if (t.parentKind !== "unknown") {
      t.field.markAsError();
      let n = t.parent;
      switch (t.parentKind) {
        case "select":
          ga(n, e.outputType);
          break;
        case "include":
          Qd(n, e.outputType);
          break;
        case "omit":
          Wd(n, e.outputType);
          break;
      }
    }
    r.addErrorMessage((n) => {
      let i = [`Unknown field ${n.red(`\`${t.fieldName}\``)}`];
      return t.parentKind !== "unknown" && i.push(`for ${n.bold(t.parentKind)} statement`), i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`), i.push(dt(n)), i.join(" ");
    });
  }
  function Fd(e, r) {
    let t = ha(e.selectionPath, r);
    t.parentKind !== "unknown" && t.field.value.markAsError(), r.addErrorMessage((n) => `Invalid value for selection field \`${n.red(t.fieldName)}\`: ${e.underlyingError}`);
  }
  function Md(e, r) {
    let t = e.argumentPath[0], n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    n && (n.getField(t)?.markAsError(), Jd(n, e.arguments)), r.addErrorMessage((i) => ma(i, t, e.arguments.map((o) => o.name)));
  }
  function $d(e, r) {
    let [t, n] = pt(e.argumentPath), i = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    if (i) {
      i.getDeepField(e.argumentPath)?.markAsError();
      let o = i.getDeepFieldValue(t)?.asObject();
      o && ya(o, e.inputType);
    }
    r.addErrorMessage((o) => ma(o, n, e.inputType.fields.map((s) => s.name)));
  }
  function ma(e, r, t) {
    let n = [`Unknown argument \`${e.red(r)}\`.`], i = Kd(r, t);
    return i && n.push(`Did you mean \`${e.green(i)}\`?`), t.length > 0 && n.push(dt(e)), n.join(" ");
  }
  function qd(e, r) {
    let t;
    r.addErrorMessage((l) => t?.value instanceof Q && t.value.text === "null" ? `Argument \`${l.green(o)}\` must not be ${l.red("null")}.` : `Argument \`${l.green(o)}\` is missing.`);
    let n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    if (!n)
      return;
    let [i, o] = pt(e.argumentPath), s = new ct, a = n.getDeepFieldValue(i)?.asObject();
    if (a)
      if (t = a.getField(o), t && a.removeField(o), e.inputTypes.length === 1 && e.inputTypes[0].kind === "object") {
        for (let l of e.inputTypes[0].fields)
          s.addField(l.name, l.typeNames.join(" | "));
        a.addSuggestion(new ue(o, s).makeRequired());
      } else {
        let l = e.inputTypes.map(fa).join(" | ");
        a.addSuggestion(new ue(o, l).makeRequired());
      }
  }
  function fa(e) {
    return e.kind === "list" ? `${fa(e.elementType)}[]` : e.name;
  }
  function jd(e, r) {
    let t = e.argument.name, n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    n && n.getDeepFieldValue(e.argumentPath)?.markAsError(), r.addErrorMessage((i) => {
      let o = Sn("or", e.argument.typeNames.map((s) => i.green(s)));
      return `Argument \`${i.bold(t)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`;
    });
  }
  function Vd(e, r) {
    let t = e.argument.name, n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    n && n.getDeepFieldValue(e.argumentPath)?.markAsError(), r.addErrorMessage((i) => {
      let o = [`Invalid value for argument \`${i.bold(t)}\``];
      if (e.underlyingError && o.push(`: ${e.underlyingError}`), o.push("."), e.argument.typeNames.length > 0) {
        let s = Sn("or", e.argument.typeNames.map((a) => i.green(a)));
        o.push(` Expected ${s}.`);
      }
      return o.join("");
    });
  }
  function Bd(e, r) {
    let t = e.argument.name, n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(), i;
    if (n) {
      let s = n.getDeepField(e.argumentPath)?.value;
      s?.markAsError(), s instanceof Q && (i = s.text);
    }
    r.addErrorMessage((o) => {
      let s = ["Unable to fit value"];
      return i && s.push(o.red(i)), s.push(`into a 64-bit signed integer for field \`${o.bold(t)}\``), s.join(" ");
    });
  }
  function Ud(e, r) {
    let t = e.argumentPath[e.argumentPath.length - 1], n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    if (n) {
      let i = n.getDeepFieldValue(e.argumentPath)?.asObject();
      i && ya(i, e.inputType);
    }
    r.addErrorMessage((i) => {
      let o = [`Argument \`${i.bold(t)}\` of type ${i.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 ? e.constraints.requiredFields ? o.push(`${i.green("at least one of")} ${Sn("or", e.constraints.requiredFields.map((s) => `\`${i.bold(s)}\``))} arguments.`) : o.push(`${i.green("at least one")} argument.`) : o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`), o.push(dt(i)), o.join(" ");
    });
  }
  function Gd(e, r) {
    let t = e.argumentPath[e.argumentPath.length - 1], n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(), i = [];
    if (n) {
      let o = n.getDeepFieldValue(e.argumentPath)?.asObject();
      o && (o.markAsError(), i = Object.keys(o.getFields()));
    }
    r.addErrorMessage((o) => {
      let s = [`Argument \`${o.bold(t)}\` of type ${o.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 && e.constraints.maxFieldCount == 1 ? s.push(`${o.green("exactly one")} argument,`) : e.constraints.maxFieldCount == 1 ? s.push(`${o.green("at most one")} argument,`) : s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`), s.push(`but you provided ${Sn("and", i.map((a) => o.red(a)))}. Please choose`), e.constraints.maxFieldCount === 1 ? s.push("one.") : s.push(`${e.constraints.maxFieldCount}.`), s.join(" ");
    });
  }
  function ga(e, r) {
    for (let t of r.fields)
      e.hasField(t.name) || e.addSuggestion(new ue(t.name, "true"));
  }
  function Qd(e, r) {
    for (let t of r.fields)
      t.isRelation && !e.hasField(t.name) && e.addSuggestion(new ue(t.name, "true"));
  }
  function Wd(e, r) {
    for (let t of r.fields)
      !e.hasField(t.name) && !t.isRelation && e.addSuggestion(new ue(t.name, "true"));
  }
  function Jd(e, r) {
    for (let t of r)
      e.hasField(t.name) || e.addSuggestion(new ue(t.name, t.typeNames.join(" | ")));
  }
  function ha(e, r) {
    let [t, n] = pt(e), i = r.arguments.getDeepSubSelectionValue(t)?.asObject();
    if (!i)
      return { parentKind: "unknown", fieldName: n };
    let o = i.getFieldValue("select")?.asObject(), s = i.getFieldValue("include")?.asObject(), a = i.getFieldValue("omit")?.asObject(), l = o?.getField(n);
    return o && l ? { parentKind: "select", parent: o, field: l, fieldName: n } : (l = s?.getField(n), s && l ? { parentKind: "include", field: l, parent: s, fieldName: n } : (l = a?.getField(n), a && l ? { parentKind: "omit", field: l, parent: a, fieldName: n } : { parentKind: "unknown", fieldName: n }));
  }
  function ya(e, r) {
    if (r.kind === "object")
      for (let t of r.fields)
        e.hasField(t.name) || e.addSuggestion(new ue(t.name, t.typeNames.join(" | ")));
  }
  function pt(e) {
    let r = [...e], t = r.pop();
    if (!t)
      throw new Error("unexpected empty path");
    return [r, t];
  }
  function dt({ green: e, enabled: r }) {
    return "Available options are " + (r ? `listed in ${e("green")}` : "marked with ?") + ".";
  }
  function Sn(e, r) {
    if (r.length === 1)
      return r[0];
    let t = [...r], n = t.pop();
    return `${t.join(", ")} ${e} ${n}`;
  }
  var Hd = 3;
  function Kd(e, r) {
    let t = 1 / 0, n;
    for (let i of r) {
      let o = (0, da.default)(e, i);
      o > Hd || o < t && (t = o, n = i);
    }
    return n;
  }
  var mt = class {
    modelName;
    name;
    typeName;
    isList;
    isEnum;
    constructor(r, t, n, i, o) {
      this.modelName = r, this.name = t, this.typeName = n, this.isList = i, this.isEnum = o;
    }
    _toGraphQLInputType() {
      let r = this.isList ? "List" : "", t = this.isEnum ? "Enum" : "";
      return `${r}${t}${this.typeName}FieldRefInput<${this.modelName}>`;
    }
  };
  function Or(e) {
    return e instanceof mt;
  }
  var Rn = Symbol();
  var Hi = new WeakMap;
  var Fe = class {
    constructor(r) {
      r === Rn ? Hi.set(this, `Prisma.${this._getName()}`) : Hi.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
    }
    _getName() {
      return this.constructor.name;
    }
    toString() {
      return Hi.get(this);
    }
  };
  var ft = class extends Fe {
    _getNamespace() {
      return "NullTypes";
    }
  };
  var gt = class extends ft {
    #e;
  };
  Ki(gt, "DbNull");
  var ht = class extends ft {
    #e;
  };
  Ki(ht, "JsonNull");
  var yt = class extends ft {
    #e;
  };
  Ki(yt, "AnyNull");
  var Cn = { classes: { DbNull: gt, JsonNull: ht, AnyNull: yt }, instances: { DbNull: new gt(Rn), JsonNull: new ht(Rn), AnyNull: new yt(Rn) } };
  function Ki(e, r) {
    Object.defineProperty(e, "name", { value: r, configurable: true });
  }
  var Ea = ": ";
  var An = class {
    constructor(r, t) {
      this.name = r;
      this.value = t;
    }
    hasError = false;
    markAsError() {
      this.hasError = true;
    }
    getPrintWidth() {
      return this.name.length + this.value.getPrintWidth() + Ea.length;
    }
    write(r) {
      let t = new Te(this.name);
      this.hasError && t.underline().setColor(r.context.colors.red), r.write(t).write(Ea).write(this.value);
    }
  };
  var Yi = class {
    arguments;
    errorMessages = [];
    constructor(r) {
      this.arguments = r;
    }
    write(r) {
      r.write(this.arguments);
    }
    addErrorMessage(r) {
      this.errorMessages.push(r);
    }
    renderAllMessages(r) {
      return this.errorMessages.map((t) => t(r)).join(`
`);
    }
  };
  function _r(e) {
    return new Yi(ba(e));
  }
  function ba(e) {
    let r = new Dr;
    for (let [t, n] of Object.entries(e)) {
      let i = new An(t, wa(n));
      r.addField(i);
    }
    return r;
  }
  function wa(e) {
    if (typeof e == "string")
      return new Q(JSON.stringify(e));
    if (typeof e == "number" || typeof e == "boolean")
      return new Q(String(e));
    if (typeof e == "bigint")
      return new Q(`${e}n`);
    if (e === null)
      return new Q("null");
    if (e === undefined)
      return new Q("undefined");
    if (Rr(e))
      return new Q(`new Prisma.Decimal("${e.toFixed()}")`);
    if (e instanceof Uint8Array)
      return Buffer.isBuffer(e) ? new Q(`Buffer.alloc(${e.byteLength})`) : new Q(`new Uint8Array(${e.byteLength})`);
    if (e instanceof Date) {
      let r = yn(e) ? e.toISOString() : "Invalid Date";
      return new Q(`new Date("${r}")`);
    }
    return e instanceof Fe ? new Q(`Prisma.${e._getName()}`) : Or(e) ? new Q(`prisma.${Ye(e.modelName)}.$fields.${e.name}`) : Array.isArray(e) ? Yd(e) : typeof e == "object" ? ba(e) : new Q(Object.prototype.toString.call(e));
  }
  function Yd(e) {
    let r = new kr;
    for (let t of e)
      r.addItem(wa(t));
    return r;
  }
  function In(e, r) {
    let t = r === "pretty" ? pa : Tn, n = e.renderAllMessages(t), i = new Ar(0, { colors: t }).write(e).toString();
    return { message: n, args: i };
  }
  function kn({ args: e, errors: r, errorFormat: t, callsite: n, originalMethod: i, clientVersion: o, globalOmit: s }) {
    let a = _r(e);
    for (let p of r)
      xn(p, a, s);
    let { message: l, args: u } = In(a, t), c = wn({ message: l, callsite: n, originalMethod: i, showColors: t === "pretty", callArguments: u });
    throw new Z(c, { clientVersion: o });
  }
  function Se(e) {
    return e.replace(/^./, (r) => r.toLowerCase());
  }
  function va(e, r, t) {
    let n = Se(t);
    return !r.result || !(r.result.$allModels || r.result[n]) ? e : zd({ ...e, ...xa(r.name, e, r.result.$allModels), ...xa(r.name, e, r.result[n]) });
  }
  function zd(e) {
    let r = new Pe, t = (n, i) => r.getOrCreate(n, () => i.has(n) ? [n] : (i.add(n), e[n] ? e[n].needs.flatMap((o) => t(o, i)) : [n]));
    return xr(e, (n) => ({ ...n, needs: t(n.name, new Set) }));
  }
  function xa(e, r, t) {
    return t ? xr(t, ({ needs: n, compute: i }, o) => ({ name: o, needs: n ? Object.keys(n).filter((s) => n[s]) : [], compute: Zd(r, o, i) })) : {};
  }
  function Zd(e, r, t) {
    let n = e?.[r]?.compute;
    return n ? (i) => t({ ...i, [r]: n(i) }) : t;
  }
  function Pa(e, r) {
    if (!r)
      return e;
    let t = { ...e };
    for (let n of Object.values(r))
      if (e[n.name])
        for (let i of n.needs)
          t[i] = true;
    return t;
  }
  function Ta(e, r) {
    if (!r)
      return e;
    let t = { ...e };
    for (let n of Object.values(r))
      if (!e[n.name])
        for (let i of n.needs)
          delete t[i];
    return t;
  }
  var Dn = class {
    constructor(r, t) {
      this.extension = r;
      this.previous = t;
    }
    computedFieldsCache = new Pe;
    modelExtensionsCache = new Pe;
    queryCallbacksCache = new Pe;
    clientExtensions = lt(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
    batchCallbacks = lt(() => {
      let r = this.previous?.getAllBatchQueryCallbacks() ?? [], t = this.extension.query?.$__internalBatch;
      return t ? r.concat(t) : r;
    });
    getAllComputedFields(r) {
      return this.computedFieldsCache.getOrCreate(r, () => va(this.previous?.getAllComputedFields(r), this.extension, r));
    }
    getAllClientExtensions() {
      return this.clientExtensions.get();
    }
    getAllModelExtensions(r) {
      return this.modelExtensionsCache.getOrCreate(r, () => {
        let t = Se(r);
        return !this.extension.model || !(this.extension.model[t] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(r) : { ...this.previous?.getAllModelExtensions(r), ...this.extension.model.$allModels, ...this.extension.model[t] };
      });
    }
    getAllQueryCallbacks(r, t) {
      return this.queryCallbacksCache.getOrCreate(`${r}:${t}`, () => {
        let n = this.previous?.getAllQueryCallbacks(r, t) ?? [], i = [], o = this.extension.query;
        return !o || !(o[r] || o.$allModels || o[t] || o.$allOperations) ? n : (o[r] !== undefined && (o[r][t] !== undefined && i.push(o[r][t]), o[r].$allOperations !== undefined && i.push(o[r].$allOperations)), r !== "$none" && o.$allModels !== undefined && (o.$allModels[t] !== undefined && i.push(o.$allModels[t]), o.$allModels.$allOperations !== undefined && i.push(o.$allModels.$allOperations)), o[t] !== undefined && i.push(o[t]), o.$allOperations !== undefined && i.push(o.$allOperations), n.concat(i));
      });
    }
    getAllBatchQueryCallbacks() {
      return this.batchCallbacks.get();
    }
  };
  var Nr = class e {
    constructor(r) {
      this.head = r;
    }
    static empty() {
      return new e;
    }
    static single(r) {
      return new e(new Dn(r));
    }
    isEmpty() {
      return this.head === undefined;
    }
    append(r) {
      return new e(new Dn(r, this.head));
    }
    getAllComputedFields(r) {
      return this.head?.getAllComputedFields(r);
    }
    getAllClientExtensions() {
      return this.head?.getAllClientExtensions();
    }
    getAllModelExtensions(r) {
      return this.head?.getAllModelExtensions(r);
    }
    getAllQueryCallbacks(r, t) {
      return this.head?.getAllQueryCallbacks(r, t) ?? [];
    }
    getAllBatchQueryCallbacks() {
      return this.head?.getAllBatchQueryCallbacks() ?? [];
    }
  };
  var On = class {
    constructor(r) {
      this.name = r;
    }
  };
  function Sa(e) {
    return e instanceof On;
  }
  function Ra(e) {
    return new On(e);
  }
  var Ca = Symbol();
  var Et = class {
    constructor(r) {
      if (r !== Ca)
        throw new Error("Skip instance can not be constructed directly");
    }
    ifUndefined(r) {
      return r === undefined ? _n : r;
    }
  };
  var _n = new Et(Ca);
  function Re(e) {
    return e instanceof Et;
  }
  var Xd = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", createManyAndReturn: "createManyAndReturn", update: "updateOne", updateMany: "updateMany", updateManyAndReturn: "updateManyAndReturn", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
  var Aa = "explicitly `undefined` values are not allowed";
  function Nn({ modelName: e, action: r, args: t, runtimeDataModel: n, extensions: i = Nr.empty(), callsite: o, clientMethod: s, errorFormat: a, clientVersion: l, previewFeatures: u, globalOmit: c }) {
    let p = new zi({ runtimeDataModel: n, modelName: e, action: r, rootArgs: t, callsite: o, extensions: i, selectionPath: [], argumentPath: [], originalMethod: s, errorFormat: a, clientVersion: l, previewFeatures: u, globalOmit: c });
    return { modelName: e, action: Xd[r], query: bt(t, p) };
  }
  function bt({ select: e, include: r, ...t } = {}, n) {
    let i = t.omit;
    return delete t.omit, { arguments: ka(t, n), selection: em(e, r, i, n) };
  }
  function em(e, r, t, n) {
    return e ? (r ? n.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "include", secondField: "select", selectionPath: n.getSelectionPath() }) : t && n.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "omit", secondField: "select", selectionPath: n.getSelectionPath() }), im(e, n)) : rm(n, r, t);
  }
  function rm(e, r, t) {
    let n = {};
    return e.modelOrType && !e.isRawAction() && (n.$composites = true, n.$scalars = true), r && tm(n, r, e), nm(n, t, e), n;
  }
  function tm(e, r, t) {
    for (let [n, i] of Object.entries(r)) {
      if (Re(i))
        continue;
      let o = t.nestSelection(n);
      if (Zi(i, o), i === false || i === undefined) {
        e[n] = false;
        continue;
      }
      let s = t.findField(n);
      if (s && s.kind !== "object" && t.throwValidationError({ kind: "IncludeOnScalar", selectionPath: t.getSelectionPath().concat(n), outputType: t.getOutputTypeDescription() }), s) {
        e[n] = bt(i === true ? {} : i, o);
        continue;
      }
      if (i === true) {
        e[n] = true;
        continue;
      }
      e[n] = bt(i, o);
    }
  }
  function nm(e, r, t) {
    let n = t.getComputedFields(), i = { ...t.getGlobalOmit(), ...r }, o = Ta(i, n);
    for (let [s, a] of Object.entries(o)) {
      if (Re(a))
        continue;
      Zi(a, t.nestSelection(s));
      let l = t.findField(s);
      n?.[s] && !l || (e[s] = !a);
    }
  }
  function im(e, r) {
    let t = {}, n = r.getComputedFields(), i = Pa(e, n);
    for (let [o, s] of Object.entries(i)) {
      if (Re(s))
        continue;
      let a = r.nestSelection(o);
      Zi(s, a);
      let l = r.findField(o);
      if (!(n?.[o] && !l)) {
        if (s === false || s === undefined || Re(s)) {
          t[o] = false;
          continue;
        }
        if (s === true) {
          l?.kind === "object" ? t[o] = bt({}, a) : t[o] = true;
          continue;
        }
        t[o] = bt(s, a);
      }
    }
    return t;
  }
  function Ia(e, r) {
    if (e === null)
      return null;
    if (typeof e == "string" || typeof e == "number" || typeof e == "boolean")
      return e;
    if (typeof e == "bigint")
      return { $type: "BigInt", value: String(e) };
    if (Sr(e)) {
      if (yn(e))
        return { $type: "DateTime", value: e.toISOString() };
      r.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: r.getSelectionPath(), argumentPath: r.getArgumentPath(), argument: { name: r.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
    }
    if (Sa(e))
      return { $type: "Param", value: e.name };
    if (Or(e))
      return { $type: "FieldRef", value: { _ref: e.name, _container: e.modelName } };
    if (Array.isArray(e))
      return om(e, r);
    if (ArrayBuffer.isView(e)) {
      let { buffer: t, byteOffset: n, byteLength: i } = e;
      return { $type: "Bytes", value: Buffer.from(t, n, i).toString("base64") };
    }
    if (sm(e))
      return e.values;
    if (Rr(e))
      return { $type: "Decimal", value: e.toFixed() };
    if (e instanceof Fe) {
      if (e !== Cn.instances[e._getName()])
        throw new Error("Invalid ObjectEnumValue");
      return { $type: "Enum", value: e._getName() };
    }
    if (am(e))
      return e.toJSON();
    if (typeof e == "object")
      return ka(e, r);
    r.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: r.getSelectionPath(), argumentPath: r.getArgumentPath(), argument: { name: r.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
  }
  function ka(e, r) {
    if (e.$type)
      return { $type: "Raw", value: e };
    let t = {};
    for (let n in e) {
      let i = e[n], o = r.nestArgument(n);
      Re(i) || (i !== undefined ? t[n] = Ia(i, o) : r.isPreviewFeatureOn("strictUndefinedChecks") && r.throwValidationError({ kind: "InvalidArgumentValue", argumentPath: o.getArgumentPath(), selectionPath: r.getSelectionPath(), argument: { name: r.getArgumentName(), typeNames: [] }, underlyingError: Aa }));
    }
    return t;
  }
  function om(e, r) {
    let t = [];
    for (let n = 0;n < e.length; n++) {
      let i = r.nestArgument(String(n)), o = e[n];
      if (o === undefined || Re(o)) {
        let s = o === undefined ? "undefined" : "Prisma.skip";
        r.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i.getSelectionPath(), argumentPath: i.getArgumentPath(), argument: { name: `${r.getArgumentName()}[${n}]`, typeNames: [] }, underlyingError: `Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values` });
      }
      t.push(Ia(o, i));
    }
    return t;
  }
  function sm(e) {
    return typeof e == "object" && e !== null && e.__prismaRawParameters__ === true;
  }
  function am(e) {
    return typeof e == "object" && e !== null && typeof e.toJSON == "function";
  }
  function Zi(e, r) {
    e === undefined && r.isPreviewFeatureOn("strictUndefinedChecks") && r.throwValidationError({ kind: "InvalidSelectionValue", selectionPath: r.getSelectionPath(), underlyingError: Aa });
  }
  var zi = class e {
    constructor(r) {
      this.params = r;
      this.params.modelName && (this.modelOrType = this.params.runtimeDataModel.models[this.params.modelName] ?? this.params.runtimeDataModel.types[this.params.modelName]);
    }
    modelOrType;
    throwValidationError(r) {
      kn({ errors: [r], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion, globalOmit: this.params.globalOmit });
    }
    getSelectionPath() {
      return this.params.selectionPath;
    }
    getArgumentPath() {
      return this.params.argumentPath;
    }
    getArgumentName() {
      return this.params.argumentPath[this.params.argumentPath.length - 1];
    }
    getOutputTypeDescription() {
      if (!(!this.params.modelName || !this.modelOrType))
        return { name: this.params.modelName, fields: this.modelOrType.fields.map((r) => ({ name: r.name, typeName: "boolean", isRelation: r.kind === "object" })) };
    }
    isRawAction() {
      return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
    }
    isPreviewFeatureOn(r) {
      return this.params.previewFeatures.includes(r);
    }
    getComputedFields() {
      if (this.params.modelName)
        return this.params.extensions.getAllComputedFields(this.params.modelName);
    }
    findField(r) {
      return this.modelOrType?.fields.find((t) => t.name === r);
    }
    nestSelection(r) {
      let t = this.findField(r), n = t?.kind === "object" ? t.type : undefined;
      return new e({ ...this.params, modelName: n, selectionPath: this.params.selectionPath.concat(r) });
    }
    getGlobalOmit() {
      return this.params.modelName && this.shouldApplyGlobalOmit() ? this.params.globalOmit?.[Ye(this.params.modelName)] ?? {} : {};
    }
    shouldApplyGlobalOmit() {
      switch (this.params.action) {
        case "findFirst":
        case "findFirstOrThrow":
        case "findUniqueOrThrow":
        case "findMany":
        case "upsert":
        case "findUnique":
        case "createManyAndReturn":
        case "create":
        case "update":
        case "updateManyAndReturn":
        case "delete":
          return true;
        case "executeRaw":
        case "aggregateRaw":
        case "runCommandRaw":
        case "findRaw":
        case "createMany":
        case "deleteMany":
        case "groupBy":
        case "updateMany":
        case "count":
        case "aggregate":
        case "queryRaw":
          return false;
        default:
          _e(this.params.action, "Unknown action");
      }
    }
    nestArgument(r) {
      return new e({ ...this.params, argumentPath: this.params.argumentPath.concat(r) });
    }
  };
  function Da(e) {
    if (!e._hasPreviewFlag("metrics"))
      throw new Z("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: e._clientVersion });
  }
  var Lr = class {
    _client;
    constructor(r) {
      this._client = r;
    }
    prometheus(r) {
      return Da(this._client), this._client._engine.metrics({ format: "prometheus", ...r });
    }
    json(r) {
      return Da(this._client), this._client._engine.metrics({ format: "json", ...r });
    }
  };
  function Oa(e, r) {
    let t = lt(() => lm(r));
    Object.defineProperty(e, "dmmf", { get: () => t.get() });
  }
  function lm(e) {
    return { datamodel: { models: Xi(e.models), enums: Xi(e.enums), types: Xi(e.types) } };
  }
  function Xi(e) {
    return Object.entries(e).map(([r, t]) => ({ name: r, ...t }));
  }
  var eo = new WeakMap;
  var Ln = "$$PrismaTypedSql";
  var wt = class {
    constructor(r, t) {
      eo.set(this, { sql: r, values: t }), Object.defineProperty(this, Ln, { value: Ln });
    }
    get sql() {
      return eo.get(this).sql;
    }
    get values() {
      return eo.get(this).values;
    }
  };
  function _a(e) {
    return (...r) => new wt(e, r);
  }
  function Fn(e) {
    return e != null && e[Ln] === Ln;
  }
  var du = k(xi());
  var mu = __require("async_hooks");
  var fu = __require("events");
  var gu = k(__require("fs"));
  var ei = k(__require("path"));
  var oe = class e {
    constructor(r, t) {
      if (r.length - 1 !== t.length)
        throw r.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${r.length} strings to have ${r.length - 1} values`);
      let n = t.reduce((s, a) => s + (a instanceof e ? a.values.length : 1), 0);
      this.values = new Array(n), this.strings = new Array(n + 1), this.strings[0] = r[0];
      let i = 0, o = 0;
      for (;i < t.length; ) {
        let s = t[i++], a = r[i];
        if (s instanceof e) {
          this.strings[o] += s.strings[0];
          let l = 0;
          for (;l < s.values.length; )
            this.values[o++] = s.values[l++], this.strings[o] = s.strings[l];
          this.strings[o] += a;
        } else
          this.values[o++] = s, this.strings[o] = a;
      }
    }
    get sql() {
      let r = this.strings.length, t = 1, n = this.strings[0];
      for (;t < r; )
        n += `?${this.strings[t++]}`;
      return n;
    }
    get statement() {
      let r = this.strings.length, t = 1, n = this.strings[0];
      for (;t < r; )
        n += `:${t}${this.strings[t++]}`;
      return n;
    }
    get text() {
      let r = this.strings.length, t = 1, n = this.strings[0];
      for (;t < r; )
        n += `$${t}${this.strings[t++]}`;
      return n;
    }
    inspect() {
      return { sql: this.sql, statement: this.statement, text: this.text, values: this.values };
    }
  };
  function Na(e, r = ",", t = "", n = "") {
    if (e.length === 0)
      throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
    return new oe([t, ...Array(e.length - 1).fill(r), n], e);
  }
  function ro(e) {
    return new oe([e], []);
  }
  var La = ro("");
  function to(e, ...r) {
    return new oe(e, r);
  }
  function xt(e) {
    return { getKeys() {
      return Object.keys(e);
    }, getPropertyValue(r) {
      return e[r];
    } };
  }
  function re(e, r) {
    return { getKeys() {
      return [e];
    }, getPropertyValue() {
      return r();
    } };
  }
  function ar(e) {
    let r = new Pe;
    return { getKeys() {
      return e.getKeys();
    }, getPropertyValue(t) {
      return r.getOrCreate(t, () => e.getPropertyValue(t));
    }, getPropertyDescriptor(t) {
      return e.getPropertyDescriptor?.(t);
    } };
  }
  var Mn = { enumerable: true, configurable: true, writable: true };
  function $n(e) {
    let r = new Set(e);
    return { getPrototypeOf: () => Object.prototype, getOwnPropertyDescriptor: () => Mn, has: (t, n) => r.has(n), set: (t, n, i) => r.add(n) && Reflect.set(t, n, i), ownKeys: () => [...r] };
  }
  var Fa = Symbol.for("nodejs.util.inspect.custom");
  function he(e, r) {
    let t = um(r), n = new Set, i = new Proxy(e, { get(o, s) {
      if (n.has(s))
        return o[s];
      let a = t.get(s);
      return a ? a.getPropertyValue(s) : o[s];
    }, has(o, s) {
      if (n.has(s))
        return true;
      let a = t.get(s);
      return a ? a.has?.(s) ?? true : Reflect.has(o, s);
    }, ownKeys(o) {
      let s = Ma(Reflect.ownKeys(o), t), a = Ma(Array.from(t.keys()), t);
      return [...new Set([...s, ...a, ...n])];
    }, set(o, s, a) {
      return t.get(s)?.getPropertyDescriptor?.(s)?.writable === false ? false : (n.add(s), Reflect.set(o, s, a));
    }, getOwnPropertyDescriptor(o, s) {
      let a = Reflect.getOwnPropertyDescriptor(o, s);
      if (a && !a.configurable)
        return a;
      let l = t.get(s);
      return l ? l.getPropertyDescriptor ? { ...Mn, ...l?.getPropertyDescriptor(s) } : Mn : a;
    }, defineProperty(o, s, a) {
      return n.add(s), Reflect.defineProperty(o, s, a);
    }, getPrototypeOf: () => Object.prototype });
    return i[Fa] = function() {
      let o = { ...this };
      return delete o[Fa], o;
    }, i;
  }
  function um(e) {
    let r = new Map;
    for (let t of e) {
      let n = t.getKeys();
      for (let i of n)
        r.set(i, t);
    }
    return r;
  }
  function Ma(e, r) {
    return e.filter((t) => r.get(t)?.has?.(t) ?? true);
  }
  function Fr(e) {
    return { getKeys() {
      return e;
    }, has() {
      return false;
    }, getPropertyValue() {} };
  }
  function Mr(e, r) {
    return { batch: e, transaction: r?.kind === "batch" ? { isolationLevel: r.options.isolationLevel } : undefined };
  }
  function $a(e) {
    if (e === undefined)
      return "";
    let r = _r(e);
    return new Ar(0, { colors: Tn }).write(r).toString();
  }
  var cm = "P2037";
  function $r({ error: e, user_facing_error: r }, t, n) {
    return r.error_code ? new z(pm(r, n), { code: r.error_code, clientVersion: t, meta: r.meta, batchRequestIdx: r.batch_request_idx }) : new j(e, { clientVersion: t, batchRequestIdx: r.batch_request_idx });
  }
  function pm(e, r) {
    let t = e.message;
    return (r === "postgresql" || r === "postgres" || r === "mysql") && e.error_code === cm && (t += `
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`), t;
  }
  var vt = "<unknown>";
  function qa(e) {
    var r = e.split(`
`);
    return r.reduce(function(t, n) {
      var i = fm(n) || hm(n) || bm(n) || Pm(n) || xm(n);
      return i && t.push(i), t;
    }, []);
  }
  var dm = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var mm = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  function fm(e) {
    var r = dm.exec(e);
    if (!r)
      return null;
    var t = r[2] && r[2].indexOf("native") === 0, n = r[2] && r[2].indexOf("eval") === 0, i = mm.exec(r[2]);
    return n && i != null && (r[2] = i[1], r[3] = i[2], r[4] = i[3]), { file: t ? null : r[2], methodName: r[1] || vt, arguments: t ? [r[2]] : [], lineNumber: r[3] ? +r[3] : null, column: r[4] ? +r[4] : null };
  }
  var gm = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function hm(e) {
    var r = gm.exec(e);
    return r ? { file: r[2], methodName: r[1] || vt, arguments: [], lineNumber: +r[3], column: r[4] ? +r[4] : null } : null;
  }
  var ym = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var Em = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  function bm(e) {
    var r = ym.exec(e);
    if (!r)
      return null;
    var t = r[3] && r[3].indexOf(" > eval") > -1, n = Em.exec(r[3]);
    return t && n != null && (r[3] = n[1], r[4] = n[2], r[5] = null), { file: r[3], methodName: r[1] || vt, arguments: r[2] ? r[2].split(",") : [], lineNumber: r[4] ? +r[4] : null, column: r[5] ? +r[5] : null };
  }
  var wm = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  function xm(e) {
    var r = wm.exec(e);
    return r ? { file: r[3], methodName: r[1] || vt, arguments: [], lineNumber: +r[4], column: r[5] ? +r[5] : null } : null;
  }
  var vm = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function Pm(e) {
    var r = vm.exec(e);
    return r ? { file: r[2], methodName: r[1] || vt, arguments: [], lineNumber: +r[3], column: r[4] ? +r[4] : null } : null;
  }
  var no = class {
    getLocation() {
      return null;
    }
  };
  var io = class {
    _error;
    constructor() {
      this._error = new Error;
    }
    getLocation() {
      let r = this._error.stack;
      if (!r)
        return null;
      let n = qa(r).find((i) => {
        if (!i.file)
          return false;
        let o = _i(i.file);
        return o !== "<anonymous>" && !o.includes("@prisma") && !o.includes("/packages/client/src/runtime/") && !o.endsWith("/runtime/binary.js") && !o.endsWith("/runtime/library.js") && !o.endsWith("/runtime/edge.js") && !o.endsWith("/runtime/edge-esm.js") && !o.startsWith("internal/") && !i.methodName.includes("new ") && !i.methodName.includes("getCallSite") && !i.methodName.includes("Proxy.") && i.methodName.split(".").length < 4;
      });
      return !n || !n.file ? null : { fileName: n.file, lineNumber: n.lineNumber, columnNumber: n.column };
    }
  };
  function Ze(e) {
    return e === "minimal" ? typeof $EnabledCallSite == "function" && e !== "minimal" ? new $EnabledCallSite : new no : new io;
  }
  var ja = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
  function qr(e = {}) {
    let r = Sm(e);
    return Object.entries(r).reduce((n, [i, o]) => (ja[i] !== undefined ? n.select[i] = { select: o } : n[i] = o, n), { select: {} });
  }
  function Sm(e = {}) {
    return typeof e._count == "boolean" ? { ...e, _count: { _all: e._count } } : e;
  }
  function qn(e = {}) {
    return (r) => (typeof e._count == "boolean" && (r._count = r._count._all), r);
  }
  function Va(e, r) {
    let t = qn(e);
    return r({ action: "aggregate", unpacker: t, argsMapper: qr })(e);
  }
  function Rm(e = {}) {
    let { select: r, ...t } = e;
    return typeof r == "object" ? qr({ ...t, _count: r }) : qr({ ...t, _count: { _all: true } });
  }
  function Cm(e = {}) {
    return typeof e.select == "object" ? (r) => qn(e)(r)._count : (r) => qn(e)(r)._count._all;
  }
  function Ba(e, r) {
    return r({ action: "count", unpacker: Cm(e), argsMapper: Rm })(e);
  }
  function Am(e = {}) {
    let r = qr(e);
    if (Array.isArray(r.by))
      for (let t of r.by)
        typeof t == "string" && (r.select[t] = true);
    else
      typeof r.by == "string" && (r.select[r.by] = true);
    return r;
  }
  function Im(e = {}) {
    return (r) => (typeof e?._count == "boolean" && r.forEach((t) => {
      t._count = t._count._all;
    }), r);
  }
  function Ua(e, r) {
    return r({ action: "groupBy", unpacker: Im(e), argsMapper: Am })(e);
  }
  function Ga(e, r, t) {
    if (r === "aggregate")
      return (n) => Va(n, t);
    if (r === "count")
      return (n) => Ba(n, t);
    if (r === "groupBy")
      return (n) => Ua(n, t);
  }
  function Qa(e, r) {
    let t = r.fields.filter((i) => !i.relationName), n = zs(t, "name");
    return new Proxy({}, { get(i, o) {
      if (o in i || typeof o == "symbol")
        return i[o];
      let s = n[o];
      if (s)
        return new mt(e, o, s.type, s.isList, s.kind === "enum");
    }, ...$n(Object.keys(n)) });
  }
  var Wa = (e) => Array.isArray(e) ? e : e.split(".");
  var oo = (e, r) => Wa(r).reduce((t, n) => t && t[n], e);
  var Ja = (e, r, t) => Wa(r).reduceRight((n, i, o, s) => Object.assign({}, oo(e, s.slice(0, o)), { [i]: n }), t);
  function km(e, r) {
    return e === undefined || r === undefined ? [] : [...r, "select", e];
  }
  function Dm(e, r, t) {
    return r === undefined ? e ?? {} : Ja(r, t, e || true);
  }
  function so(e, r, t, n, i, o) {
    let a = e._runtimeDataModel.models[r].fields.reduce((l, u) => ({ ...l, [u.name]: u }), {});
    return (l) => {
      let u = Ze(e._errorFormat), c = km(n, i), p = Dm(l, o, c), d = t({ dataPath: c, callsite: u })(p), f = Om(e, r);
      return new Proxy(d, { get(h, g) {
        if (!f.includes(g))
          return h[g];
        let P = [a[g].type, t, g], R = [c, p];
        return so(e, ...P, ...R);
      }, ...$n([...f, ...Object.getOwnPropertyNames(d)]) });
    };
  }
  function Om(e, r) {
    return e._runtimeDataModel.models[r].fields.filter((t) => t.kind === "object").map((t) => t.name);
  }
  var _m = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
  var Nm = ["aggregate", "count", "groupBy"];
  function ao(e, r) {
    let t = e._extensions.getAllModelExtensions(r) ?? {}, n = [Lm(e, r), Mm(e, r), xt(t), re("name", () => r), re("$name", () => r), re("$parent", () => e._appliedParent)];
    return he({}, n);
  }
  function Lm(e, r) {
    let t = Se(r), n = Object.keys(Cr).concat("count");
    return { getKeys() {
      return n;
    }, getPropertyValue(i) {
      let o = i, s = (a) => (l) => {
        let u = Ze(e._errorFormat);
        return e._createPrismaPromise((c) => {
          let p = { args: l, dataPath: [], action: o, model: r, clientMethod: `${t}.${i}`, jsModelName: t, transaction: c, callsite: u };
          return e._request({ ...p, ...a });
        }, { action: o, args: l, model: r });
      };
      return _m.includes(o) ? so(e, r, s) : Fm(i) ? Ga(e, i, s) : s({});
    } };
  }
  function Fm(e) {
    return Nm.includes(e);
  }
  function Mm(e, r) {
    return ar(re("fields", () => {
      let t = e._runtimeDataModel.models[r];
      return Qa(r, t);
    }));
  }
  function Ha(e) {
    return e.replace(/^./, (r) => r.toUpperCase());
  }
  var lo = Symbol();
  function Pt(e) {
    let r = [$m(e), qm(e), re(lo, () => e), re("$parent", () => e._appliedParent)], t = e._extensions.getAllClientExtensions();
    return t && r.push(xt(t)), he(e, r);
  }
  function $m(e) {
    let r = Object.getPrototypeOf(e._originalClient), t = [...new Set(Object.getOwnPropertyNames(r))];
    return { getKeys() {
      return t;
    }, getPropertyValue(n) {
      return e[n];
    } };
  }
  function qm(e) {
    let r = Object.keys(e._runtimeDataModel.models), t = r.map(Se), n = [...new Set(r.concat(t))];
    return ar({ getKeys() {
      return n;
    }, getPropertyValue(i) {
      let o = Ha(i);
      if (e._runtimeDataModel.models[o] !== undefined)
        return ao(e, o);
      if (e._runtimeDataModel.models[i] !== undefined)
        return ao(e, i);
    }, getPropertyDescriptor(i) {
      if (!t.includes(i))
        return { enumerable: false };
    } });
  }
  function Ka(e) {
    return e[lo] ? e[lo] : e;
  }
  function Ya(e) {
    if (typeof e == "function")
      return e(this);
    if (e.client?.__AccelerateEngine) {
      let t = e.client.__AccelerateEngine;
      this._originalClient._engine = new t(this._originalClient._accelerateEngineConfig);
    }
    let r = Object.create(this._originalClient, { _extensions: { value: this._extensions.append(e) }, _appliedParent: { value: this, configurable: true }, $use: { value: undefined }, $on: { value: undefined } });
    return Pt(r);
  }
  function za({ result: e, modelName: r, select: t, omit: n, extensions: i }) {
    let o = i.getAllComputedFields(r);
    if (!o)
      return e;
    let s = [], a = [];
    for (let l of Object.values(o)) {
      if (n) {
        if (n[l.name])
          continue;
        let u = l.needs.filter((c) => n[c]);
        u.length > 0 && a.push(Fr(u));
      } else if (t) {
        if (!t[l.name])
          continue;
        let u = l.needs.filter((c) => !t[c]);
        u.length > 0 && a.push(Fr(u));
      }
      jm(e, l.needs) && s.push(Vm(l, he(e, s)));
    }
    return s.length > 0 || a.length > 0 ? he(e, [...s, ...a]) : e;
  }
  function jm(e, r) {
    return r.every((t) => $i(e, t));
  }
  function Vm(e, r) {
    return ar(re(e.name, () => e.compute(r)));
  }
  function jn({ visitor: e, result: r, args: t, runtimeDataModel: n, modelName: i }) {
    if (Array.isArray(r)) {
      for (let s = 0;s < r.length; s++)
        r[s] = jn({ result: r[s], args: t, modelName: i, runtimeDataModel: n, visitor: e });
      return r;
    }
    let o = e(r, i, t) ?? r;
    return t.include && Za({ includeOrSelect: t.include, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), t.select && Za({ includeOrSelect: t.select, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), o;
  }
  function Za({ includeOrSelect: e, result: r, parentModelName: t, runtimeDataModel: n, visitor: i }) {
    for (let [o, s] of Object.entries(e)) {
      if (!s || r[o] == null || Re(s))
        continue;
      let l = n.models[t].fields.find((c) => c.name === o);
      if (!l || l.kind !== "object" || !l.relationName)
        continue;
      let u = typeof s == "object" ? s : {};
      r[o] = jn({ visitor: i, result: r[o], args: u, modelName: l.type, runtimeDataModel: n });
    }
  }
  function Xa({ result: e, modelName: r, args: t, extensions: n, runtimeDataModel: i, globalOmit: o }) {
    return n.isEmpty() || e == null || typeof e != "object" || !i.models[r] ? e : jn({ result: e, args: t ?? {}, modelName: r, runtimeDataModel: i, visitor: (a, l, u) => {
      let c = Se(l);
      return za({ result: a, modelName: c, select: u.select, omit: u.select ? undefined : { ...o?.[c], ...u.omit }, extensions: n });
    } });
  }
  var Bm = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
  var el = Bm;
  function rl(e) {
    if (e instanceof oe)
      return Um(e);
    if (Fn(e))
      return Gm(e);
    if (Array.isArray(e)) {
      let t = [e[0]];
      for (let n = 1;n < e.length; n++)
        t[n] = Tt(e[n]);
      return t;
    }
    let r = {};
    for (let t in e)
      r[t] = Tt(e[t]);
    return r;
  }
  function Um(e) {
    return new oe(e.strings, e.values);
  }
  function Gm(e) {
    return new wt(e.sql, e.values);
  }
  function Tt(e) {
    if (typeof e != "object" || e == null || e instanceof Fe || Or(e))
      return e;
    if (Rr(e))
      return new ve(e.toFixed());
    if (Sr(e))
      return new Date(+e);
    if (ArrayBuffer.isView(e))
      return e.slice(0);
    if (Array.isArray(e)) {
      let r = e.length, t;
      for (t = Array(r);r--; )
        t[r] = Tt(e[r]);
      return t;
    }
    if (typeof e == "object") {
      let r = {};
      for (let t in e)
        t === "__proto__" ? Object.defineProperty(r, t, { value: Tt(e[t]), configurable: true, enumerable: true, writable: true }) : r[t] = Tt(e[t]);
      return r;
    }
    _e(e, "Unknown value");
  }
  function nl(e, r, t, n = 0) {
    return e._createPrismaPromise((i) => {
      let o = r.customDataProxyFetch;
      return "transaction" in r && i !== undefined && (r.transaction?.kind === "batch" && r.transaction.lock.then(), r.transaction = i), n === t.length ? e._executeRequest(r) : t[n]({ model: r.model, operation: r.model ? r.action : r.clientMethod, args: rl(r.args ?? {}), __internalParams: r, query: (s, a = r) => {
        let l = a.customDataProxyFetch;
        return a.customDataProxyFetch = al(o, l), a.args = s, nl(e, a, t, n + 1);
      } });
    });
  }
  function il(e, r) {
    let { jsModelName: t, action: n, clientMethod: i } = r, o = t ? n : i;
    if (e._extensions.isEmpty())
      return e._executeRequest(r);
    let s = e._extensions.getAllQueryCallbacks(t ?? "$none", o);
    return nl(e, r, s);
  }
  function ol(e) {
    return (r) => {
      let t = { requests: r }, n = r[0].extensions.getAllBatchQueryCallbacks();
      return n.length ? sl(t, n, 0, e) : e(t);
    };
  }
  function sl(e, r, t, n) {
    if (t === r.length)
      return n(e);
    let i = e.customDataProxyFetch, o = e.requests[0].transaction;
    return r[t]({ args: { queries: e.requests.map((s) => ({ model: s.modelName, operation: s.action, args: s.args })), transaction: o ? { isolationLevel: o.kind === "batch" ? o.isolationLevel : undefined } : undefined }, __internalParams: e, query(s, a = e) {
      let l = a.customDataProxyFetch;
      return a.customDataProxyFetch = al(i, l), sl(a, r, t + 1, n);
    } });
  }
  var tl = (e) => e;
  function al(e = tl, r = tl) {
    return (t) => e(r(t));
  }
  var ll = N("prisma:client");
  var ul = { Vercel: "vercel", "Netlify CI": "netlify" };
  function cl({ postinstall: e, ciName: r, clientVersion: t }) {
    if (ll("checkPlatformCaching:postinstall", e), ll("checkPlatformCaching:ciName", r), e === true && r && r in ul) {
      let n = `Prisma has detected that this project was built on ${r}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ul[r]}-build`;
      throw console.error(n), new T(n, t);
    }
  }
  function pl(e, r) {
    return e ? e.datasources ? e.datasources : e.datasourceUrl ? { [r[0]]: { url: e.datasourceUrl } } : {} : {};
  }
  var Qm = () => globalThis.process?.release?.name === "node";
  var Wm = () => !!globalThis.Bun || !!globalThis.process?.versions?.bun;
  var Jm = () => !!globalThis.Deno;
  var Hm = () => typeof globalThis.Netlify == "object";
  var Km = () => typeof globalThis.EdgeRuntime == "object";
  var Ym = () => globalThis.navigator?.userAgent === "Cloudflare-Workers";
  function zm() {
    return [[Hm, "netlify"], [Km, "edge-light"], [Ym, "workerd"], [Jm, "deno"], [Wm, "bun"], [Qm, "node"]].flatMap((t) => t[0]() ? [t[1]] : []).at(0) ?? "";
  }
  var Zm = { node: "Node.js", workerd: "Cloudflare Workers", deno: "Deno and Deno Deploy", netlify: "Netlify Edge Functions", "edge-light": "Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)" };
  function Vn() {
    let e = zm();
    return { id: e, prettyName: Zm[e] || e, isEdge: ["workerd", "deno", "netlify", "edge-light"].includes(e) };
  }
  var hl = k(__require("fs"));
  var St = k(__require("path"));
  function Bn(e) {
    let { runtimeBinaryTarget: r } = e;
    return `Add "${r}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Xm(e)}`;
  }
  function Xm(e) {
    let { generator: r, generatorBinaryTargets: t, runtimeBinaryTarget: n } = e, i = { fromEnvVar: null, value: n }, o = [...t, i];
    return ki({ ...r, binaryTargets: o });
  }
  function Xe(e) {
    let { runtimeBinaryTarget: r } = e;
    return `Prisma Client could not locate the Query Engine for runtime "${r}".`;
  }
  function er(e) {
    let { searchedLocations: r } = e;
    return `The following locations have been searched:
${[...new Set(r)].map((i) => `  ${i}`).join(`
`)}`;
  }
  function dl(e) {
    let { runtimeBinaryTarget: r } = e;
    return `${Xe(e)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${r}".
${Bn(e)}

${er(e)}`;
  }
  function Un(e) {
    return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e}`;
  }
  function Gn(e) {
    let { errorStack: r } = e;
    return r?.match(/\/\.next|\/next@|\/next\//) ? `

We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.` : "";
  }
  function ml(e) {
    let { queryEngineName: r } = e;
    return `${Xe(e)}${Gn(e)}

This is likely caused by a bundler that has not copied "${r}" next to the resulting bundle.
Ensure that "${r}" has been copied next to the bundle or in "${e.expectedLocation}".

${Un("engine-not-found-bundler-investigation")}

${er(e)}`;
  }
  function fl(e) {
    let { runtimeBinaryTarget: r, generatorBinaryTargets: t } = e, n = t.find((i) => i.native);
    return `${Xe(e)}

This happened because Prisma Client was generated for "${n?.value ?? "unknown"}", but the actual deployment required "${r}".
${Bn(e)}

${er(e)}`;
  }
  function gl(e) {
    let { queryEngineName: r } = e;
    return `${Xe(e)}${Gn(e)}

This is likely caused by tooling that has not copied "${r}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${r}" has been copied to "${e.expectedLocation}".

${Un("engine-not-found-tooling-investigation")}

${er(e)}`;
  }
  var ef = N("prisma:client:engines:resolveEnginePath");
  var rf = () => new RegExp("runtime[\\\\/]library\\.m?js$");
  async function yl(e, r) {
    let t = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e] ?? r.prismaPath;
    if (t !== undefined)
      return t;
    let { enginePath: n, searchedLocations: i } = await tf(e, r);
    if (ef("enginePath", n), n !== undefined && e === "binary" && Ti(n), n !== undefined)
      return r.prismaPath = n;
    let o = await ir(), s = r.generator?.binaryTargets ?? [], a = s.some((d) => d.native), l = !s.some((d) => d.value === o), u = __filename.match(rf()) === null, c = { searchedLocations: i, generatorBinaryTargets: s, generator: r.generator, runtimeBinaryTarget: o, queryEngineName: El(e, o), expectedLocation: St.default.relative(process.cwd(), r.dirname), errorStack: new Error().stack }, p;
    throw a && l ? p = fl(c) : l ? p = dl(c) : u ? p = ml(c) : p = gl(c), new T(p, r.clientVersion);
  }
  async function tf(e, r) {
    let t = await ir(), n = [], i = [r.dirname, St.default.resolve(__dirname, ".."), r.generator?.output?.value ?? __dirname, St.default.resolve(__dirname, "../../../.prisma/client"), "/tmp/prisma-engines", r.cwd];
    __filename.includes("resolveEnginePath") && i.push(fs());
    for (let o of i) {
      let s = El(e, t), a = St.default.join(o, s);
      if (n.push(o), hl.default.existsSync(a))
        return { enginePath: a, searchedLocations: n };
    }
    return { enginePath: undefined, searchedLocations: n };
  }
  function El(e, r) {
    return e === "library" ? Gt(r, "fs") : `query-engine-${r}${r === "windows" ? ".exe" : ""}`;
  }
  var uo = k(Oi());
  function bl(e) {
    return e ? e.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (r) => `${r[0]}5`) : "";
  }
  function wl(e) {
    return e.split(`
`).map((r) => r.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
  }
  var xl = k(Ls());
  function vl({ title: e, user: r = "prisma", repo: t = "prisma", template: n = "bug_report.yml", body: i }) {
    return (0, xl.default)({ user: r, repo: t, template: n, title: e, body: i });
  }
  function Pl({ version: e, binaryTarget: r, title: t, description: n, engineVersion: i, database: o, query: s }) {
    let a = Go(6000 - (s?.length ?? 0)), l = wl((0, uo.default)(a)), u = n ? `# Description
\`\`\`
${n}
\`\`\`` : "", c = (0, uo.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${r?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|

${u}

## Logs
\`\`\`
${l}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s ? bl(s) : ""}
\`\`\`
`), p = vl({ title: t, body: c });
    return `${t}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${Y(p)}

If you want the Prisma team to look into it, please open the link above \uD83D\uDE4F
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  }
  function co(e) {
    return e.name === "DriverAdapterError" && typeof e.cause == "object";
  }
  function Qn(e) {
    return { ok: true, value: e, map(r) {
      return Qn(r(e));
    }, flatMap(r) {
      return r(e);
    } };
  }
  function lr(e) {
    return { ok: false, error: e, map() {
      return lr(e);
    }, flatMap() {
      return lr(e);
    } };
  }
  var Tl = N("driver-adapter-utils");
  var po = class {
    registeredErrors = [];
    consumeError(r) {
      return this.registeredErrors[r];
    }
    registerNewError(r) {
      let t = 0;
      for (;this.registeredErrors[t] !== undefined; )
        t++;
      return this.registeredErrors[t] = { error: r }, t;
    }
  };
  var Wn = (e, r = new po) => {
    let t = { adapterName: e.adapterName, errorRegistry: r, queryRaw: Me(r, e.queryRaw.bind(e)), executeRaw: Me(r, e.executeRaw.bind(e)), executeScript: Me(r, e.executeScript.bind(e)), dispose: Me(r, e.dispose.bind(e)), provider: e.provider, startTransaction: async (...n) => (await Me(r, e.startTransaction.bind(e))(...n)).map((o) => nf(r, o)) };
    return e.getConnectionInfo && (t.getConnectionInfo = of(r, e.getConnectionInfo.bind(e))), t;
  };
  var nf = (e, r) => ({ adapterName: r.adapterName, provider: r.provider, options: r.options, queryRaw: Me(e, r.queryRaw.bind(r)), executeRaw: Me(e, r.executeRaw.bind(r)), commit: Me(e, r.commit.bind(r)), rollback: Me(e, r.rollback.bind(r)) });
  function Me(e, r) {
    return async (...t) => {
      try {
        return Qn(await r(...t));
      } catch (n) {
        if (Tl("[error@wrapAsync]", n), co(n))
          return lr(n.cause);
        let i = e.registerNewError(n);
        return lr({ kind: "GenericJs", id: i });
      }
    };
  }
  function of(e, r) {
    return (...t) => {
      try {
        return Qn(r(...t));
      } catch (n) {
        if (Tl("[error@wrapSync]", n), co(n))
          return lr(n.cause);
        let i = e.registerNewError(n);
        return lr({ kind: "GenericJs", id: i });
      }
    };
  }
  var Sl = "6.11.1";
  function jr({ inlineDatasources: e, overrideDatasources: r, env: t, clientVersion: n }) {
    let i, o = Object.keys(e)[0], s = e[o]?.url, a = r[o]?.url;
    if (o === undefined ? i = undefined : a ? i = a : s?.value ? i = s.value : s?.fromEnvVar && (i = t[s.fromEnvVar]), s?.fromEnvVar !== undefined && i === undefined)
      throw new T(`error: Environment variable not found: ${s.fromEnvVar}.`, n);
    if (i === undefined)
      throw new T("error: Missing URL environment variable, value, or override.", n);
    return i;
  }
  var Jn = class extends Error {
    clientVersion;
    cause;
    constructor(r, t) {
      super(r), this.clientVersion = t.clientVersion, this.cause = t.cause;
    }
    get [Symbol.toStringTag]() {
      return this.name;
    }
  };
  var se = class extends Jn {
    isRetryable;
    constructor(r, t) {
      super(r, t), this.isRetryable = t.isRetryable ?? true;
    }
  };
  function C(e, r) {
    return { ...e, isRetryable: r };
  }
  var Vr = class extends se {
    name = "ForcedRetryError";
    code = "P5001";
    constructor(r) {
      super("This request must be retried", C(r, true));
    }
  };
  x(Vr, "ForcedRetryError");
  var ur = class extends se {
    name = "InvalidDatasourceError";
    code = "P6001";
    constructor(r, t) {
      super(r, C(t, false));
    }
  };
  x(ur, "InvalidDatasourceError");
  var cr = class extends se {
    name = "NotImplementedYetError";
    code = "P5004";
    constructor(r, t) {
      super(r, C(t, false));
    }
  };
  x(cr, "NotImplementedYetError");
  var $ = class extends se {
    response;
    constructor(r, t) {
      super(r, t), this.response = t.response;
      let n = this.response.headers.get("prisma-request-id");
      if (n) {
        let i = `(The request id was: ${n})`;
        this.message = this.message + " " + i;
      }
    }
  };
  var pr = class extends $ {
    name = "SchemaMissingError";
    code = "P5005";
    constructor(r) {
      super("Schema needs to be uploaded", C(r, true));
    }
  };
  x(pr, "SchemaMissingError");
  var mo = "This request could not be understood by the server";
  var Rt = class extends $ {
    name = "BadRequestError";
    code = "P5000";
    constructor(r, t, n) {
      super(t || mo, C(r, false)), n && (this.code = n);
    }
  };
  x(Rt, "BadRequestError");
  var Ct = class extends $ {
    name = "HealthcheckTimeoutError";
    code = "P5013";
    logs;
    constructor(r, t) {
      super("Engine not started: healthcheck timeout", C(r, true)), this.logs = t;
    }
  };
  x(Ct, "HealthcheckTimeoutError");
  var At = class extends $ {
    name = "EngineStartupError";
    code = "P5014";
    logs;
    constructor(r, t, n) {
      super(t, C(r, true)), this.logs = n;
    }
  };
  x(At, "EngineStartupError");
  var It = class extends $ {
    name = "EngineVersionNotSupportedError";
    code = "P5012";
    constructor(r) {
      super("Engine version is not supported", C(r, false));
    }
  };
  x(It, "EngineVersionNotSupportedError");
  var fo = "Request timed out";
  var kt = class extends $ {
    name = "GatewayTimeoutError";
    code = "P5009";
    constructor(r, t = fo) {
      super(t, C(r, false));
    }
  };
  x(kt, "GatewayTimeoutError");
  var af = "Interactive transaction error";
  var Dt = class extends $ {
    name = "InteractiveTransactionError";
    code = "P5015";
    constructor(r, t = af) {
      super(t, C(r, false));
    }
  };
  x(Dt, "InteractiveTransactionError");
  var lf = "Request parameters are invalid";
  var Ot = class extends $ {
    name = "InvalidRequestError";
    code = "P5011";
    constructor(r, t = lf) {
      super(t, C(r, false));
    }
  };
  x(Ot, "InvalidRequestError");
  var go = "Requested resource does not exist";
  var _t = class extends $ {
    name = "NotFoundError";
    code = "P5003";
    constructor(r, t = go) {
      super(t, C(r, false));
    }
  };
  x(_t, "NotFoundError");
  var ho = "Unknown server error";
  var Br = class extends $ {
    name = "ServerError";
    code = "P5006";
    logs;
    constructor(r, t, n) {
      super(t || ho, C(r, true)), this.logs = n;
    }
  };
  x(Br, "ServerError");
  var yo = "Unauthorized, check your connection string";
  var Nt = class extends $ {
    name = "UnauthorizedError";
    code = "P5007";
    constructor(r, t = yo) {
      super(t, C(r, false));
    }
  };
  x(Nt, "UnauthorizedError");
  var Eo = "Usage exceeded, retry again later";
  var Lt = class extends $ {
    name = "UsageExceededError";
    code = "P5008";
    constructor(r, t = Eo) {
      super(t, C(r, true));
    }
  };
  x(Lt, "UsageExceededError");
  async function uf(e) {
    let r;
    try {
      r = await e.text();
    } catch {
      return { type: "EmptyError" };
    }
    try {
      let t = JSON.parse(r);
      if (typeof t == "string")
        switch (t) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: t };
          default:
            return { type: "UnknownTextError", body: t };
        }
      if (typeof t == "object" && t !== null) {
        if ("is_panic" in t && "message" in t && "error_code" in t)
          return { type: "QueryEngineError", body: t };
        if ("EngineNotStarted" in t || "InteractiveTransactionMisrouted" in t || "InvalidRequestError" in t) {
          let n = Object.values(t)[0].reason;
          return typeof n == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n) ? { type: "UnknownJsonError", body: t } : { type: "DataProxyError", body: t };
        }
      }
      return { type: "UnknownJsonError", body: t };
    } catch {
      return r === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: r };
    }
  }
  async function Ft(e, r) {
    if (e.ok)
      return;
    let t = { clientVersion: r, response: e }, n = await uf(e);
    if (n.type === "QueryEngineError")
      throw new z(n.body.message, { code: n.body.error_code, clientVersion: r });
    if (n.type === "DataProxyError") {
      if (n.body === "InternalDataProxyError")
        throw new Br(t, "Internal Data Proxy error");
      if ("EngineNotStarted" in n.body) {
        if (n.body.EngineNotStarted.reason === "SchemaMissing")
          return new pr(t);
        if (n.body.EngineNotStarted.reason === "EngineVersionNotSupported")
          throw new It(t);
        if ("EngineStartupError" in n.body.EngineNotStarted.reason) {
          let { msg: i, logs: o } = n.body.EngineNotStarted.reason.EngineStartupError;
          throw new At(t, i, o);
        }
        if ("KnownEngineStartupError" in n.body.EngineNotStarted.reason) {
          let { msg: i, error_code: o } = n.body.EngineNotStarted.reason.KnownEngineStartupError;
          throw new T(i, r, o);
        }
        if ("HealthcheckTimeout" in n.body.EngineNotStarted.reason) {
          let { logs: i } = n.body.EngineNotStarted.reason.HealthcheckTimeout;
          throw new Ct(t, i);
        }
      }
      if ("InteractiveTransactionMisrouted" in n.body) {
        let i = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
        throw new Dt(t, i[n.body.InteractiveTransactionMisrouted.reason]);
      }
      if ("InvalidRequestError" in n.body)
        throw new Ot(t, n.body.InvalidRequestError.reason);
    }
    if (e.status === 401 || e.status === 403)
      throw new Nt(t, Ur(yo, n));
    if (e.status === 404)
      return new _t(t, Ur(go, n));
    if (e.status === 429)
      throw new Lt(t, Ur(Eo, n));
    if (e.status === 504)
      throw new kt(t, Ur(fo, n));
    if (e.status >= 500)
      throw new Br(t, Ur(ho, n));
    if (e.status >= 400)
      throw new Rt(t, Ur(mo, n));
  }
  function Ur(e, r) {
    return r.type === "EmptyError" ? e : `${e}: ${JSON.stringify(r)}`;
  }
  function Rl(e) {
    let r = Math.pow(2, e) * 50, t = Math.ceil(Math.random() * r) - Math.ceil(r / 2), n = r + t;
    return new Promise((i) => setTimeout(() => i(n), n));
  }
  var $e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  function Cl(e) {
    let r = new TextEncoder().encode(e), t = "", n = r.byteLength, i = n % 3, o = n - i, s, a, l, u, c;
    for (let p = 0;p < o; p = p + 3)
      c = r[p] << 16 | r[p + 1] << 8 | r[p + 2], s = (c & 16515072) >> 18, a = (c & 258048) >> 12, l = (c & 4032) >> 6, u = c & 63, t += $e[s] + $e[a] + $e[l] + $e[u];
    return i == 1 ? (c = r[o], s = (c & 252) >> 2, a = (c & 3) << 4, t += $e[s] + $e[a] + "==") : i == 2 && (c = r[o] << 8 | r[o + 1], s = (c & 64512) >> 10, a = (c & 1008) >> 4, l = (c & 15) << 2, t += $e[s] + $e[a] + $e[l] + "="), t;
  }
  function Al(e) {
    if (!!e.generator?.previewFeatures.some((t) => t.toLowerCase().includes("metrics")))
      throw new T("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e.clientVersion);
  }
  function cf(e) {
    return e[0] * 1000 + e[1] / 1e6;
  }
  function bo(e) {
    return new Date(cf(e));
  }
  var Il = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "6.11.1-1.f40f79ec31188888a2e33acda0ecc8fd10a853a9", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*" };
  var Mt = class extends se {
    name = "RequestError";
    code = "P5010";
    constructor(r, t) {
      super(`Cannot fetch data from service:
${r}`, C(t, true));
    }
  };
  x(Mt, "RequestError");
  async function dr(e, r, t = (n) => n) {
    let { clientVersion: n, ...i } = r, o = t(fetch);
    try {
      return await o(e, i);
    } catch (s) {
      let a = s.message ?? "Unknown error";
      throw new Mt(a, { clientVersion: n, cause: s });
    }
  }
  var df = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
  var kl = N("prisma:client:dataproxyEngine");
  async function mf(e, r) {
    let t = Il["@prisma/engines-version"], n = r.clientVersion ?? "unknown";
    if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION || globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
      return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION || globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
    if (e.includes("accelerate") && n !== "0.0.0" && n !== "in-memory")
      return n;
    let [i, o] = n?.split("-") ?? [];
    if (o === undefined && df.test(i))
      return i;
    if (o !== undefined || n === "0.0.0" || n === "in-memory") {
      let [s] = t.split("-") ?? [], [a, l, u] = s.split("."), c = ff(`<=${a}.${l}.${u}`), p = await dr(c, { clientVersion: n });
      if (!p.ok)
        throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text() || "<empty body>"}`);
      let d = await p.text();
      kl("length of body fetched from unpkg.com", d.length);
      let f;
      try {
        f = JSON.parse(d);
      } catch (h) {
        throw console.error("JSON.parse error: body fetched from unpkg.com: ", d), h;
      }
      return f.version;
    }
    throw new cr("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n });
  }
  async function Dl(e, r) {
    let t = await mf(e, r);
    return kl("version", t), t;
  }
  function ff(e) {
    return encodeURI(`https://unpkg.com/prisma@${e}/package.json`);
  }
  var Ol = 3;
  var $t = N("prisma:client:dataproxyEngine");
  var wo = class {
    apiKey;
    tracingHelper;
    logLevel;
    logQueries;
    engineHash;
    constructor({ apiKey: r, tracingHelper: t, logLevel: n, logQueries: i, engineHash: o }) {
      this.apiKey = r, this.tracingHelper = t, this.logLevel = n, this.logQueries = i, this.engineHash = o;
    }
    build({ traceparent: r, interactiveTransaction: t } = {}) {
      let n = { Authorization: `Bearer ${this.apiKey}`, "Prisma-Engine-Hash": this.engineHash };
      this.tracingHelper.isEnabled() && (n.traceparent = r ?? this.tracingHelper.getTraceParent()), t && (n["X-transaction-id"] = t.id);
      let i = this.buildCaptureSettings();
      return i.length > 0 && (n["X-capture-telemetry"] = i.join(", ")), n;
    }
    buildCaptureSettings() {
      let r = [];
      return this.tracingHelper.isEnabled() && r.push("tracing"), this.logLevel && r.push(this.logLevel), this.logQueries && r.push("query"), r;
    }
  };
  var qt = class {
    name = "DataProxyEngine";
    inlineSchema;
    inlineSchemaHash;
    inlineDatasources;
    config;
    logEmitter;
    env;
    clientVersion;
    engineHash;
    tracingHelper;
    remoteClientVersion;
    host;
    headerBuilder;
    startPromise;
    protocol;
    constructor(r) {
      Al(r), this.config = r, this.env = { ...r.env, ...typeof process < "u" ? process.env : {} }, this.inlineSchema = Cl(r.inlineSchema), this.inlineDatasources = r.inlineDatasources, this.inlineSchemaHash = r.inlineSchemaHash, this.clientVersion = r.clientVersion, this.engineHash = r.engineVersion, this.logEmitter = r.logEmitter, this.tracingHelper = r.tracingHelper;
    }
    apiKey() {
      return this.headerBuilder.apiKey;
    }
    version() {
      return this.engineHash;
    }
    async start() {
      this.startPromise !== undefined && await this.startPromise, this.startPromise = (async () => {
        let { apiKey: r, url: t } = this.getURLAndAPIKey();
        this.host = t.host, this.headerBuilder = new wo({ apiKey: r, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries, engineHash: this.engineHash }), this.protocol = Ci(t) ? "http" : "https", this.remoteClientVersion = await Dl(this.host, this.config), $t("host", this.host), $t("protocol", this.protocol);
      })(), await this.startPromise;
    }
    async stop() {}
    propagateResponseExtensions(r) {
      r?.logs?.length && r.logs.forEach((t) => {
        switch (t.level) {
          case "debug":
          case "trace":
            $t(t);
            break;
          case "error":
          case "warn":
          case "info": {
            this.logEmitter.emit(t.level, { timestamp: bo(t.timestamp), message: t.attributes.message ?? "", target: t.target });
            break;
          }
          case "query": {
            this.logEmitter.emit("query", { query: t.attributes.query ?? "", timestamp: bo(t.timestamp), duration: t.attributes.duration_ms ?? 0, params: t.attributes.params ?? "", target: t.target });
            break;
          }
          default:
            t.level;
        }
      }), r?.traces?.length && this.tracingHelper.dispatchEngineSpans(r.traces);
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the remote query engine');
    }
    async url(r) {
      return await this.start(), `${this.protocol}://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`;
    }
    async uploadSchema() {
      let r = { name: "schemaUpload", internal: true };
      return this.tracingHelper.runInChildSpan(r, async () => {
        let t = await dr(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
        t.ok || $t("schema response status", t.status);
        let n = await Ft(t, this.clientVersion);
        if (n)
          throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${n.message}`, timestamp: new Date, target: "" }), n;
        this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`, timestamp: new Date, target: "" });
      });
    }
    request(r, { traceparent: t, interactiveTransaction: n, customDataProxyFetch: i }) {
      return this.requestInternal({ body: r, traceparent: t, interactiveTransaction: n, customDataProxyFetch: i });
    }
    async requestBatch(r, { traceparent: t, transaction: n, customDataProxyFetch: i }) {
      let o = n?.kind === "itx" ? n.options : undefined, s = Mr(r, n);
      return (await this.requestInternal({ body: s, customDataProxyFetch: i, interactiveTransaction: o, traceparent: t })).map((l) => (l.extensions && this.propagateResponseExtensions(l.extensions), ("errors" in l) ? this.convertProtocolErrorsToClientError(l.errors) : l));
    }
    requestInternal({ body: r, traceparent: t, customDataProxyFetch: n, interactiveTransaction: i }) {
      return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: o }) => {
        let s = i ? `${i.payload.endpoint}/graphql` : await this.url("graphql");
        o(s);
        let a = await dr(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: t, interactiveTransaction: i }), body: JSON.stringify(r), clientVersion: this.clientVersion }, n);
        a.ok || $t("graphql response status", a.status), await this.handleError(await Ft(a, this.clientVersion));
        let l = await a.json();
        if (l.extensions && this.propagateResponseExtensions(l.extensions), "errors" in l)
          throw this.convertProtocolErrorsToClientError(l.errors);
        return "batchResult" in l ? l.batchResult : l;
      } });
    }
    async transaction(r, t, n) {
      let i = { start: "starting", commit: "committing", rollback: "rolling back" };
      return this.withRetry({ actionGerund: `${i[r]} transaction`, callback: async ({ logHttpCall: o }) => {
        if (r === "start") {
          let s = JSON.stringify({ max_wait: n.maxWait, timeout: n.timeout, isolation_level: n.isolationLevel }), a = await this.url("transaction/start");
          o(a);
          let l = await dr(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: t.traceparent }), body: s, clientVersion: this.clientVersion });
          await this.handleError(await Ft(l, this.clientVersion));
          let u = await l.json(), { extensions: c } = u;
          c && this.propagateResponseExtensions(c);
          let p = u.id, d = u["data-proxy"].endpoint;
          return { id: p, payload: { endpoint: d } };
        } else {
          let s = `${n.payload.endpoint}/${r}`;
          o(s);
          let a = await dr(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: t.traceparent }), clientVersion: this.clientVersion });
          await this.handleError(await Ft(a, this.clientVersion));
          let l = await a.json(), { extensions: u } = l;
          u && this.propagateResponseExtensions(u);
          return;
        }
      } });
    }
    getURLAndAPIKey() {
      let r = { clientVersion: this.clientVersion }, t = Object.keys(this.inlineDatasources)[0], n = jr({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), i;
      try {
        i = new URL(n);
      } catch {
        throw new ur(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\``, r);
      }
      let { protocol: o, searchParams: s } = i;
      if (o !== "prisma:" && o !== tn)
        throw new ur(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\` or \`prisma+postgres://\``, r);
      let a = s.get("api_key");
      if (a === null || a.length < 1)
        throw new ur(`Error validating datasource \`${t}\`: the URL must contain a valid API key`, r);
      return { apiKey: a, url: i };
    }
    metrics() {
      throw new cr("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
    }
    async withRetry(r) {
      for (let t = 0;; t++) {
        let n = (i) => {
          this.logEmitter.emit("info", { message: `Calling ${i} (n=${t})`, timestamp: new Date, target: "" });
        };
        try {
          return await r.callback({ logHttpCall: n });
        } catch (i) {
          if (!(i instanceof se) || !i.isRetryable)
            throw i;
          if (t >= Ol)
            throw i instanceof Vr ? i.cause : i;
          this.logEmitter.emit("warn", { message: `Attempt ${t + 1}/${Ol} failed for ${r.actionGerund}: ${i.message ?? "(unknown)"}`, timestamp: new Date, target: "" });
          let o = await Rl(t);
          this.logEmitter.emit("warn", { message: `Retrying after ${o}ms`, timestamp: new Date, target: "" });
        }
      }
    }
    async handleError(r) {
      if (r instanceof pr)
        throw await this.uploadSchema(), new Vr({ clientVersion: this.clientVersion, cause: r });
      if (r)
        throw r;
    }
    convertProtocolErrorsToClientError(r) {
      return r.length === 1 ? $r(r[0], this.config.clientVersion, this.config.activeProvider) : new j(JSON.stringify(r), { clientVersion: this.config.clientVersion });
    }
    applyPendingMigrations() {
      throw new Error("Method not implemented.");
    }
  };
  function _l(e) {
    if (e?.kind === "itx")
      return e.options.id;
  }
  var vo = k(__require("os"));
  var Nl = k(__require("path"));
  var xo = Symbol("PrismaLibraryEngineCache");
  function gf() {
    let e = globalThis;
    return e[xo] === undefined && (e[xo] = {}), e[xo];
  }
  function hf(e) {
    let r = gf();
    if (r[e] !== undefined)
      return r[e];
    let t = Nl.default.toNamespacedPath(e), n = { exports: {} }, i = 0;
    return process.platform !== "win32" && (i = vo.default.constants.dlopen.RTLD_LAZY | vo.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n, t, i), r[e] = n.exports, n.exports;
  }
  var Ll = { async loadLibrary(e) {
    let r = await mi(), t = await yl("library", e);
    try {
      return e.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => hf(t));
    } catch (n) {
      let i = Si({ e: n, platformInfo: r, id: t });
      throw new T(i, e.clientVersion);
    }
  } };
  var Po;
  var Fl = { async loadLibrary(e) {
    let { clientVersion: r, adapter: t, engineWasm: n } = e;
    if (t === undefined)
      throw new T(`The \`adapter\` option for \`PrismaClient\` is required in this context (${Vn().prettyName})`, r);
    if (n === undefined)
      throw new T("WASM engine was unexpectedly `undefined`", r);
    Po === undefined && (Po = (async () => {
      let o = await n.getRuntime(), s = await n.getQueryEngineWasmModule();
      if (s == null)
        throw new T("The loaded wasm module was unexpectedly `undefined` or `null` once loaded", r);
      let a = { "./query_engine_bg.js": o }, l = new WebAssembly.Instance(s, a), u = l.exports.__wbindgen_start;
      return o.__wbg_set_wasm(l.exports), u(), o.QueryEngine;
    })());
    let i = await Po;
    return { debugPanic() {
      return Promise.reject("{}");
    }, dmmf() {
      return Promise.resolve("{}");
    }, version() {
      return { commit: "unknown", version: "unknown" };
    }, QueryEngine: i };
  } };
  var yf = "P2036";
  var Ce = N("prisma:client:libraryEngine");
  function Ef(e) {
    return e.item_type === "query" && "query" in e;
  }
  function bf(e) {
    return "level" in e ? e.level === "error" && e.message === "PANIC" : false;
  }
  var Ml = [...ai, "native"];
  var wf = 0xffffffffffffffffn;
  var To = 1n;
  function xf() {
    let e = To++;
    return To > wf && (To = 1n), e;
  }
  var Gr = class {
    name = "LibraryEngine";
    engine;
    libraryInstantiationPromise;
    libraryStartingPromise;
    libraryStoppingPromise;
    libraryStarted;
    executingQueryPromise;
    config;
    QueryEngineConstructor;
    libraryLoader;
    library;
    logEmitter;
    libQueryEnginePath;
    binaryTarget;
    datasourceOverrides;
    datamodel;
    logQueries;
    logLevel;
    lastQuery;
    loggerRustPanic;
    tracingHelper;
    adapterPromise;
    versionInfo;
    constructor(r, t) {
      this.libraryLoader = t ?? Ll, r.engineWasm !== undefined && (this.libraryLoader = t ?? Fl), this.config = r, this.libraryStarted = false, this.logQueries = r.logQueries ?? false, this.logLevel = r.logLevel ?? "error", this.logEmitter = r.logEmitter, this.datamodel = r.inlineSchema, this.tracingHelper = r.tracingHelper, r.enableDebugLogs && (this.logLevel = "debug");
      let n = Object.keys(r.overrideDatasources)[0], i = r.overrideDatasources[n]?.url;
      n !== undefined && i !== undefined && (this.datasourceOverrides = { [n]: i }), this.libraryInstantiationPromise = this.instantiateLibrary();
    }
    wrapEngine(r) {
      return { applyPendingMigrations: r.applyPendingMigrations?.bind(r), commitTransaction: this.withRequestId(r.commitTransaction.bind(r)), connect: this.withRequestId(r.connect.bind(r)), disconnect: this.withRequestId(r.disconnect.bind(r)), metrics: r.metrics?.bind(r), query: this.withRequestId(r.query.bind(r)), rollbackTransaction: this.withRequestId(r.rollbackTransaction.bind(r)), sdlSchema: r.sdlSchema?.bind(r), startTransaction: this.withRequestId(r.startTransaction.bind(r)), trace: r.trace.bind(r), free: r.free?.bind(r) };
    }
    withRequestId(r) {
      return async (...t) => {
        let n = xf().toString();
        try {
          return await r(...t, n);
        } finally {
          if (this.tracingHelper.isEnabled()) {
            let i = await this.engine?.trace(n);
            if (i) {
              let o = JSON.parse(i);
              this.tracingHelper.dispatchEngineSpans(o.spans);
            }
          }
        }
      };
    }
    async applyPendingMigrations() {
      throw new Error("Cannot call this method from this type of engine instance");
    }
    async transaction(r, t, n) {
      await this.start();
      let i = await this.adapterPromise, o = JSON.stringify(t), s;
      if (r === "start") {
        let l = JSON.stringify({ max_wait: n.maxWait, timeout: n.timeout, isolation_level: n.isolationLevel });
        s = await this.engine?.startTransaction(l, o);
      } else
        r === "commit" ? s = await this.engine?.commitTransaction(n.id, o) : r === "rollback" && (s = await this.engine?.rollbackTransaction(n.id, o));
      let a = this.parseEngineResponse(s);
      if (vf(a)) {
        let l = this.getExternalAdapterError(a, i?.errorRegistry);
        throw l ? l.error : new z(a.message, { code: a.error_code, clientVersion: this.config.clientVersion, meta: a.meta });
      } else if (typeof a.message == "string")
        throw new j(a.message, { clientVersion: this.config.clientVersion });
      return a;
    }
    async instantiateLibrary() {
      if (Ce("internalSetup"), this.libraryInstantiationPromise)
        return this.libraryInstantiationPromise;
      si(), this.binaryTarget = await this.getCurrentBinaryTarget(), await this.tracingHelper.runInChildSpan("load_engine", () => this.loadEngine()), this.version();
    }
    async getCurrentBinaryTarget() {
      {
        if (this.binaryTarget)
          return this.binaryTarget;
        let r = await this.tracingHelper.runInChildSpan("detect_platform", () => ir());
        if (!Ml.includes(r))
          throw new T(`Unknown ${ce("PRISMA_QUERY_ENGINE_LIBRARY")} ${ce(W(r))}. Possible binaryTargets: ${qe(Ml.join(", "))} or a path to the query engine library.
You may have to run ${qe("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
        return r;
      }
    }
    parseEngineResponse(r) {
      if (!r)
        throw new j("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
      try {
        return JSON.parse(r);
      } catch {
        throw new j("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
      }
    }
    async loadEngine() {
      if (!this.engine) {
        this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(this.config), this.QueryEngineConstructor = this.library.QueryEngine);
        try {
          let r = new WeakRef(this);
          this.adapterPromise || (this.adapterPromise = this.config.adapter?.connect()?.then(Wn));
          let t = await this.adapterPromise;
          t && Ce("Using driver adapter: %O", t), this.engine = this.wrapEngine(new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json", enableTracing: this.tracingHelper.isEnabled() }, (n) => {
            r.deref()?.logger(n);
          }, t));
        } catch (r) {
          let t = r, n = this.parseInitError(t.message);
          throw typeof n == "string" ? t : new T(n.message, this.config.clientVersion, n.error_code);
        }
      }
    }
    logger(r) {
      let t = this.parseEngineResponse(r);
      t && (t.level = t?.level.toLowerCase() ?? "unknown", Ef(t) ? this.logEmitter.emit("query", { timestamp: new Date, query: t.query, params: t.params, duration: Number(t.duration_ms), target: t.module_path }) : bf(t) ? this.loggerRustPanic = new le(So(this, `${t.message}: ${t.reason} in ${t.file}:${t.line}:${t.column}`), this.config.clientVersion) : this.logEmitter.emit(t.level, { timestamp: new Date, message: t.message, target: t.module_path }));
    }
    parseInitError(r) {
      try {
        return JSON.parse(r);
      } catch {}
      return r;
    }
    parseRequestError(r) {
      try {
        return JSON.parse(r);
      } catch {}
      return r;
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
    }
    async start() {
      if (this.libraryInstantiationPromise || (this.libraryInstantiationPromise = this.instantiateLibrary()), await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise)
        return Ce(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
      if (this.libraryStarted)
        return;
      let r = async () => {
        Ce("library starting");
        try {
          let t = { traceparent: this.tracingHelper.getTraceParent() };
          await this.engine?.connect(JSON.stringify(t)), this.libraryStarted = true, this.adapterPromise || (this.adapterPromise = this.config.adapter?.connect()?.then(Wn)), await this.adapterPromise, Ce("library started");
        } catch (t) {
          let n = this.parseInitError(t.message);
          throw typeof n == "string" ? t : new T(n.message, this.config.clientVersion, n.error_code);
        } finally {
          this.libraryStartingPromise = undefined;
        }
      };
      return this.libraryStartingPromise = this.tracingHelper.runInChildSpan("connect", r), this.libraryStartingPromise;
    }
    async stop() {
      if (await this.libraryInstantiationPromise, await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise)
        return Ce("library is already stopping"), this.libraryStoppingPromise;
      if (!this.libraryStarted) {
        await (await this.adapterPromise)?.dispose(), this.adapterPromise = undefined;
        return;
      }
      let r = async () => {
        await new Promise((n) => setImmediate(n)), Ce("library stopping");
        let t = { traceparent: this.tracingHelper.getTraceParent() };
        await this.engine?.disconnect(JSON.stringify(t)), this.engine?.free && this.engine.free(), this.engine = undefined, this.libraryStarted = false, this.libraryStoppingPromise = undefined, this.libraryInstantiationPromise = undefined, await (await this.adapterPromise)?.dispose(), this.adapterPromise = undefined, Ce("library stopped");
      };
      return this.libraryStoppingPromise = this.tracingHelper.runInChildSpan("disconnect", r), this.libraryStoppingPromise;
    }
    version() {
      return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
    }
    debugPanic(r) {
      return this.library?.debugPanic(r);
    }
    async request(r, { traceparent: t, interactiveTransaction: n }) {
      Ce(`sending request, this.libraryStarted: ${this.libraryStarted}`);
      let i = JSON.stringify({ traceparent: t }), o = JSON.stringify(r);
      try {
        await this.start();
        let s = await this.adapterPromise;
        this.executingQueryPromise = this.engine?.query(o, i, n?.id), this.lastQuery = o;
        let a = this.parseEngineResponse(await this.executingQueryPromise);
        if (a.errors)
          throw a.errors.length === 1 ? this.buildQueryError(a.errors[0], s?.errorRegistry) : new j(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
        if (this.loggerRustPanic)
          throw this.loggerRustPanic;
        return { data: a };
      } catch (s) {
        if (s instanceof T)
          throw s;
        if (s.code === "GenericFailure" && s.message?.startsWith("PANIC:"))
          throw new le(So(this, s.message), this.config.clientVersion);
        let a = this.parseRequestError(s.message);
        throw typeof a == "string" ? s : new j(`${a.message}
${a.backtrace}`, { clientVersion: this.config.clientVersion });
      }
    }
    async requestBatch(r, { transaction: t, traceparent: n }) {
      Ce("requestBatch");
      let i = Mr(r, t);
      await this.start();
      let o = await this.adapterPromise;
      this.lastQuery = JSON.stringify(i), this.executingQueryPromise = this.engine?.query(this.lastQuery, JSON.stringify({ traceparent: n }), _l(t));
      let s = await this.executingQueryPromise, a = this.parseEngineResponse(s);
      if (a.errors)
        throw a.errors.length === 1 ? this.buildQueryError(a.errors[0], o?.errorRegistry) : new j(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
      let { batchResult: l, errors: u } = a;
      if (Array.isArray(l))
        return l.map((c) => c.errors && c.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(c.errors[0], o?.errorRegistry) : { data: c });
      throw u && u.length === 1 ? new Error(u[0].error) : new Error(JSON.stringify(a));
    }
    buildQueryError(r, t) {
      if (r.user_facing_error.is_panic)
        return new le(So(this, r.user_facing_error.message), this.config.clientVersion);
      let n = this.getExternalAdapterError(r.user_facing_error, t);
      return n ? n.error : $r(r, this.config.clientVersion, this.config.activeProvider);
    }
    getExternalAdapterError(r, t) {
      if (r.error_code === yf && t) {
        let n = r.meta?.id;
        on(typeof n == "number", "Malformed external JS error received from the engine");
        let i = t.consumeError(n);
        return on(i, "External error with reported id was not registered"), i;
      }
    }
    async metrics(r) {
      await this.start();
      let t = await this.engine.metrics(JSON.stringify(r));
      return r.format === "prometheus" ? t : this.parseEngineResponse(t);
    }
  };
  function vf(e) {
    return typeof e == "object" && e !== null && e.error_code !== undefined;
  }
  function So(e, r) {
    return Pl({ binaryTarget: e.binaryTarget, title: r, version: e.config.clientVersion, engineVersion: e.versionInfo?.commit, database: e.config.activeProvider, query: e.lastQuery });
  }
  function $l({ url: e, adapter: r, copyEngine: t, targetBuildType: n }) {
    let i = [], o = [], s = (g) => {
      i.push({ _tag: "warning", value: g });
    }, a = (g) => {
      let S = g.join(`
`);
      o.push({ _tag: "error", value: S });
    }, l = !!e?.startsWith("prisma://"), u = nn(e), c = !!r, p = l || u;
    !c && t && p && s(["recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)"]);
    let d = p || !t;
    c && (d || n === "edge") && (n === "edge" ? a(["Prisma Client was configured to use the `adapter` option but it was imported via its `/edge` endpoint.", "Please either remove the `/edge` endpoint or remove the `adapter` from the Prisma Client constructor."]) : t ? l && a(["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.", "Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."]) : a(["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.", "Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."]));
    let f = { accelerate: d, ppg: u, driverAdapters: c };
    function h(g) {
      return g.length > 0;
    }
    return h(o) ? { ok: false, diagnostics: { warnings: i, errors: o }, isUsing: f } : { ok: true, diagnostics: { warnings: i }, isUsing: f };
  }
  function ql({ copyEngine: e = true }, r) {
    let t;
    try {
      t = jr({ inlineDatasources: r.inlineDatasources, overrideDatasources: r.overrideDatasources, env: { ...r.env, ...process.env }, clientVersion: r.clientVersion });
    } catch {}
    let { ok: n, isUsing: i, diagnostics: o } = $l({ url: t, adapter: r.adapter, copyEngine: e, targetBuildType: "library" });
    for (let c of o.warnings)
      st(...c.value);
    if (!n) {
      let c = o.errors[0];
      throw new Z(c.value, { clientVersion: r.clientVersion });
    }
    let s = br(r.generator), a = s === "library", l = s === "binary", u = s === "client";
    return i.accelerate ? new qt(r) : (i.driverAdapters, a ? new Gr(r) : (i.accelerate, new Gr(r)));
  }
  function Hn({ generator: e }) {
    return e?.previewFeatures ?? [];
  }
  var jl = (e) => ({ command: e });
  var Vl = (e) => e.strings.reduce((r, t, n) => `${r}@P${n}${t}`);
  function Qr(e) {
    try {
      return Bl(e, "fast");
    } catch {
      return Bl(e, "slow");
    }
  }
  function Bl(e, r) {
    return JSON.stringify(e.map((t) => Gl(t, r)));
  }
  function Gl(e, r) {
    if (Array.isArray(e))
      return e.map((t) => Gl(t, r));
    if (typeof e == "bigint")
      return { prisma__type: "bigint", prisma__value: e.toString() };
    if (Sr(e))
      return { prisma__type: "date", prisma__value: e.toJSON() };
    if (ve.isDecimal(e))
      return { prisma__type: "decimal", prisma__value: e.toJSON() };
    if (Buffer.isBuffer(e))
      return { prisma__type: "bytes", prisma__value: e.toString("base64") };
    if (Pf(e))
      return { prisma__type: "bytes", prisma__value: Buffer.from(e).toString("base64") };
    if (ArrayBuffer.isView(e)) {
      let { buffer: t, byteOffset: n, byteLength: i } = e;
      return { prisma__type: "bytes", prisma__value: Buffer.from(t, n, i).toString("base64") };
    }
    return typeof e == "object" && r === "slow" ? Ql(e) : e;
  }
  function Pf(e) {
    return e instanceof ArrayBuffer || e instanceof SharedArrayBuffer ? true : typeof e == "object" && e !== null ? e[Symbol.toStringTag] === "ArrayBuffer" || e[Symbol.toStringTag] === "SharedArrayBuffer" : false;
  }
  function Ql(e) {
    if (typeof e != "object" || e === null)
      return e;
    if (typeof e.toJSON == "function")
      return e.toJSON();
    if (Array.isArray(e))
      return e.map(Ul);
    let r = {};
    for (let t of Object.keys(e))
      r[t] = Ul(e[t]);
    return r;
  }
  function Ul(e) {
    return typeof e == "bigint" ? e.toString() : Ql(e);
  }
  var Tf = /^(\s*alter\s)/i;
  var Wl = N("prisma:client");
  function Ro(e, r, t, n) {
    if (!(e !== "postgresql" && e !== "cockroachdb") && t.length > 0 && Tf.exec(r))
      throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
  }
  var Co = ({ clientMethod: e, activeProvider: r }) => (t) => {
    let n = "", i;
    if (Fn(t))
      n = t.sql, i = { values: Qr(t.values), __prismaRawParameters__: true };
    else if (Array.isArray(t)) {
      let [o, ...s] = t;
      n = o, i = { values: Qr(s || []), __prismaRawParameters__: true };
    } else
      switch (r) {
        case "sqlite":
        case "mysql": {
          n = t.sql, i = { values: Qr(t.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          n = t.text, i = { values: Qr(t.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          n = Vl(t), i = { values: Qr(t.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${r} provider does not support ${e}`);
      }
    return i?.values ? Wl(`prisma.${e}(${n}, ${i.values})`) : Wl(`prisma.${e}(${n})`), { query: n, parameters: i };
  };
  var Jl = { requestArgsToMiddlewareArgs(e) {
    return [e.strings, ...e.values];
  }, middlewareArgsToRequestArgs(e) {
    let [r, ...t] = e;
    return new oe(r, t);
  } };
  var Hl = { requestArgsToMiddlewareArgs(e) {
    return [e];
  }, middlewareArgsToRequestArgs(e) {
    return e[0];
  } };
  function Ao(e) {
    return function(t, n) {
      let i, o = (s = e) => {
        try {
          return s === undefined || s?.kind === "itx" ? i ??= Kl(t(s)) : Kl(t(s));
        } catch (a) {
          return Promise.reject(a);
        }
      };
      return { get spec() {
        return n;
      }, then(s, a) {
        return o().then(s, a);
      }, catch(s) {
        return o().catch(s);
      }, finally(s) {
        return o().finally(s);
      }, requestTransaction(s) {
        let a = o(s);
        return a.requestTransaction ? a.requestTransaction(s) : a;
      }, [Symbol.toStringTag]: "PrismaPromise" };
    };
  }
  function Kl(e) {
    return typeof e.then == "function" ? e : Promise.resolve(e);
  }
  var Sf = wi.split(".")[0];
  var Rf = { isEnabled() {
    return false;
  }, getTraceParent() {
    return "00-10-10-00";
  }, dispatchEngineSpans() {}, getActiveContext() {}, runInChildSpan(e, r) {
    return r();
  } };
  var Io = class {
    isEnabled() {
      return this.getGlobalTracingHelper().isEnabled();
    }
    getTraceParent(r) {
      return this.getGlobalTracingHelper().getTraceParent(r);
    }
    dispatchEngineSpans(r) {
      return this.getGlobalTracingHelper().dispatchEngineSpans(r);
    }
    getActiveContext() {
      return this.getGlobalTracingHelper().getActiveContext();
    }
    runInChildSpan(r, t) {
      return this.getGlobalTracingHelper().runInChildSpan(r, t);
    }
    getGlobalTracingHelper() {
      let r = globalThis[`V${Sf}_PRISMA_INSTRUMENTATION`], t = globalThis.PRISMA_INSTRUMENTATION;
      return r?.helper ?? t?.helper ?? Rf;
    }
  };
  function Yl() {
    return new Io;
  }
  function zl(e, r = () => {}) {
    let t, n = new Promise((i) => t = i);
    return { then(i) {
      return --e === 0 && t(r()), i?.(n);
    } };
  }
  function Zl(e) {
    return typeof e == "string" ? e : e.reduce((r, t) => {
      let n = typeof t == "string" ? t : t.level;
      return n === "query" ? r : r && (t === "info" || r === "info") ? "info" : n;
    }, undefined);
  }
  var Kn = class {
    _middlewares = [];
    use(r) {
      this._middlewares.push(r);
    }
    get(r) {
      return this._middlewares[r];
    }
    has(r) {
      return !!this._middlewares[r];
    }
    length() {
      return this._middlewares.length;
    }
  };
  var eu = k(Oi());
  function Yn(e) {
    return typeof e.batchRequestIdx == "number";
  }
  function Xl(e) {
    if (e.action !== "findUnique" && e.action !== "findUniqueOrThrow")
      return;
    let r = [];
    return e.modelName && r.push(e.modelName), e.query.arguments && r.push(ko(e.query.arguments)), r.push(ko(e.query.selection)), r.join("");
  }
  function ko(e) {
    return `(${Object.keys(e).sort().map((t) => {
      let n = e[t];
      return typeof n == "object" && n !== null ? `(${t} ${ko(n)})` : t;
    }).join(" ")})`;
  }
  var Cf = { aggregate: false, aggregateRaw: false, createMany: true, createManyAndReturn: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateManyAndReturn: true, updateOne: true, upsertOne: true };
  function Do(e) {
    return Cf[e];
  }
  var zn = class {
    constructor(r) {
      this.options = r;
      this.batches = {};
    }
    batches;
    tickActive = false;
    request(r) {
      let t = this.options.batchBy(r);
      return t ? (this.batches[t] || (this.batches[t] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
        this.dispatchBatches(), this.tickActive = false;
      }))), new Promise((n, i) => {
        this.batches[t].push({ request: r, resolve: n, reject: i });
      })) : this.options.singleLoader(r);
    }
    dispatchBatches() {
      for (let r in this.batches) {
        let t = this.batches[r];
        delete this.batches[r], t.length === 1 ? this.options.singleLoader(t[0].request).then((n) => {
          n instanceof Error ? t[0].reject(n) : t[0].resolve(n);
        }).catch((n) => {
          t[0].reject(n);
        }) : (t.sort((n, i) => this.options.batchOrder(n.request, i.request)), this.options.batchLoader(t.map((n) => n.request)).then((n) => {
          if (n instanceof Error)
            for (let i = 0;i < t.length; i++)
              t[i].reject(n);
          else
            for (let i = 0;i < t.length; i++) {
              let o = n[i];
              o instanceof Error ? t[i].reject(o) : t[i].resolve(o);
            }
        }).catch((n) => {
          for (let i = 0;i < t.length; i++)
            t[i].reject(n);
        }));
      }
    }
    get [Symbol.toStringTag]() {
      return "DataLoader";
    }
  };
  function mr(e, r) {
    if (r === null)
      return r;
    switch (e) {
      case "bigint":
        return BigInt(r);
      case "bytes": {
        let { buffer: t, byteOffset: n, byteLength: i } = Buffer.from(r, "base64");
        return new Uint8Array(t, n, i);
      }
      case "decimal":
        return new ve(r);
      case "datetime":
      case "date":
        return new Date(r);
      case "time":
        return new Date(`1970-01-01T${r}Z`);
      case "bigint-array":
        return r.map((t) => mr("bigint", t));
      case "bytes-array":
        return r.map((t) => mr("bytes", t));
      case "decimal-array":
        return r.map((t) => mr("decimal", t));
      case "datetime-array":
        return r.map((t) => mr("datetime", t));
      case "date-array":
        return r.map((t) => mr("date", t));
      case "time-array":
        return r.map((t) => mr("time", t));
      default:
        return r;
    }
  }
  function Zn(e) {
    let r = [], t = Af(e);
    for (let n = 0;n < e.rows.length; n++) {
      let i = e.rows[n], o = { ...t };
      for (let s = 0;s < i.length; s++)
        o[e.columns[s]] = mr(e.types[s], i[s]);
      r.push(o);
    }
    return r;
  }
  function Af(e) {
    let r = {};
    for (let t = 0;t < e.columns.length; t++)
      r[e.columns[t]] = null;
    return r;
  }
  var If = N("prisma:client:request_handler");
  var Xn = class {
    client;
    dataloader;
    logEmitter;
    constructor(r, t) {
      this.logEmitter = t, this.client = r, this.dataloader = new zn({ batchLoader: ol(async ({ requests: n, customDataProxyFetch: i }) => {
        let { transaction: o, otelParentCtx: s } = n[0], a = n.map((p) => p.protocolQuery), l = this.client._tracingHelper.getTraceParent(s), u = n.some((p) => Do(p.protocolQuery.action));
        return (await this.client._engine.requestBatch(a, { traceparent: l, transaction: kf(o), containsWrite: u, customDataProxyFetch: i })).map((p, d) => {
          if (p instanceof Error)
            return p;
          try {
            return this.mapQueryEngineResult(n[d], p);
          } catch (f) {
            return f;
          }
        });
      }), singleLoader: async (n) => {
        let i = n.transaction?.kind === "itx" ? ru(n.transaction) : undefined, o = await this.client._engine.request(n.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i, isWrite: Do(n.protocolQuery.action), customDataProxyFetch: n.customDataProxyFetch });
        return this.mapQueryEngineResult(n, o);
      }, batchBy: (n) => n.transaction?.id ? `transaction-${n.transaction.id}` : Xl(n.protocolQuery), batchOrder(n, i) {
        return n.transaction?.kind === "batch" && i.transaction?.kind === "batch" ? n.transaction.index - i.transaction.index : 0;
      } });
    }
    async request(r) {
      try {
        return await this.dataloader.request(r);
      } catch (t) {
        let { clientMethod: n, callsite: i, transaction: o, args: s, modelName: a } = r;
        this.handleAndLogRequestError({ error: t, clientMethod: n, callsite: i, transaction: o, args: s, modelName: a, globalOmit: r.globalOmit });
      }
    }
    mapQueryEngineResult({ dataPath: r, unpacker: t }, n) {
      let i = n?.data, o = this.unpack(i, r, t);
      return process.env.PRISMA_CLIENT_GET_TIME ? { data: o } : o;
    }
    handleAndLogRequestError(r) {
      try {
        this.handleRequestError(r);
      } catch (t) {
        throw this.logEmitter && this.logEmitter.emit("error", { message: t.message, target: r.clientMethod, timestamp: new Date }), t;
      }
    }
    handleRequestError({ error: r, clientMethod: t, callsite: n, transaction: i, args: o, modelName: s, globalOmit: a }) {
      if (If(r), Df(r, i))
        throw r;
      if (r instanceof z && Of(r)) {
        let u = tu(r.meta);
        kn({ args: o, errors: [u], callsite: n, errorFormat: this.client._errorFormat, originalMethod: t, clientVersion: this.client._clientVersion, globalOmit: a });
      }
      let l = r.message;
      if (n && (l = wn({ callsite: n, originalMethod: t, isPanic: r.isPanic, showColors: this.client._errorFormat === "pretty", message: l })), l = this.sanitizeMessage(l), r.code) {
        let u = s ? { modelName: s, ...r.meta } : r.meta;
        throw new z(l, { code: r.code, clientVersion: this.client._clientVersion, meta: u, batchRequestIdx: r.batchRequestIdx });
      } else {
        if (r.isPanic)
          throw new le(l, this.client._clientVersion);
        if (r instanceof j)
          throw new j(l, { clientVersion: this.client._clientVersion, batchRequestIdx: r.batchRequestIdx });
        if (r instanceof T)
          throw new T(l, this.client._clientVersion);
        if (r instanceof le)
          throw new le(l, this.client._clientVersion);
      }
      throw r.clientVersion = this.client._clientVersion, r;
    }
    sanitizeMessage(r) {
      return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, eu.default)(r) : r;
    }
    unpack(r, t, n) {
      if (!r || (r.data && (r = r.data), !r))
        return r;
      let i = Object.keys(r)[0], o = Object.values(r)[0], s = t.filter((u) => u !== "select" && u !== "include"), a = oo(o, s), l = i === "queryRaw" ? Zn(a) : Tr(a);
      return n ? n(l) : l;
    }
    get [Symbol.toStringTag]() {
      return "RequestHandler";
    }
  };
  function kf(e) {
    if (e) {
      if (e.kind === "batch")
        return { kind: "batch", options: { isolationLevel: e.isolationLevel } };
      if (e.kind === "itx")
        return { kind: "itx", options: ru(e) };
      _e(e, "Unknown transaction kind");
    }
  }
  function ru(e) {
    return { id: e.id, payload: e.payload };
  }
  function Df(e, r) {
    return Yn(e) && r?.kind === "batch" && e.batchRequestIdx !== r.index;
  }
  function Of(e) {
    return e.code === "P2009" || e.code === "P2012";
  }
  function tu(e) {
    if (e.kind === "Union")
      return { kind: "Union", errors: e.errors.map(tu) };
    if (Array.isArray(e.selectionPath)) {
      let [, ...r] = e.selectionPath;
      return { ...e, selectionPath: r };
    }
    return e;
  }
  var nu = Sl;
  var lu = k(Wi());
  var O = class extends Error {
    constructor(r) {
      super(r + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientConstructorValidationError";
    }
  };
  x(O, "PrismaClientConstructorValidationError");
  var iu = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "transactionOptions", "omit", "__internal"];
  var ou = ["pretty", "colorless", "minimal"];
  var su = ["info", "query", "warn", "error"];
  var _f = { datasources: (e, { datasourceNames: r }) => {
    if (e) {
      if (typeof e != "object" || Array.isArray(e))
        throw new O(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);
      for (let [t, n] of Object.entries(e)) {
        if (!r.includes(t)) {
          let i = Wr(t, r) || ` Available datasources: ${r.join(", ")}`;
          throw new O(`Unknown datasource ${t} provided to PrismaClient constructor.${i}`);
        }
        if (typeof n != "object" || Array.isArray(n))
          throw new O(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
        if (n && typeof n == "object")
          for (let [i, o] of Object.entries(n)) {
            if (i !== "url")
              throw new O(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof o != "string")
              throw new O(`Invalid value ${JSON.stringify(o)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
      }
    }
  }, adapter: (e, r) => {
    if (!e && br(r.generator) === "client")
      throw new O('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');
    if (e === null)
      return;
    if (e === undefined)
      throw new O('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
    if (!Hn(r).includes("driverAdapters"))
      throw new O('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
    if (br(r.generator) === "binary")
      throw new O('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.');
  }, datasourceUrl: (e) => {
    if (typeof e < "u" && typeof e != "string")
      throw new O(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
  }, errorFormat: (e) => {
    if (e) {
      if (typeof e != "string")
        throw new O(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);
      if (!ou.includes(e)) {
        let r = Wr(e, ou);
        throw new O(`Invalid errorFormat ${e} provided to PrismaClient constructor.${r}`);
      }
    }
  }, log: (e) => {
    if (!e)
      return;
    if (!Array.isArray(e))
      throw new O(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);
    function r(t) {
      if (typeof t == "string" && !su.includes(t)) {
        let n = Wr(t, su);
        throw new O(`Invalid log level "${t}" provided to PrismaClient constructor.${n}`);
      }
    }
    for (let t of e) {
      r(t);
      let n = { level: r, emit: (i) => {
        let o = ["stdout", "event"];
        if (!o.includes(i)) {
          let s = Wr(i, o);
          throw new O(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`);
        }
      } };
      if (t && typeof t == "object")
        for (let [i, o] of Object.entries(t))
          if (n[i])
            n[i](o);
          else
            throw new O(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
    }
  }, transactionOptions: (e) => {
    if (!e)
      return;
    let r = e.maxWait;
    if (r != null && r <= 0)
      throw new O(`Invalid value ${r} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);
    let t = e.timeout;
    if (t != null && t <= 0)
      throw new O(`Invalid value ${t} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`);
  }, omit: (e, r) => {
    if (typeof e != "object")
      throw new O('"omit" option is expected to be an object.');
    if (e === null)
      throw new O('"omit" option can not be `null`');
    let t = [];
    for (let [n, i] of Object.entries(e)) {
      let o = Lf(n, r.runtimeDataModel);
      if (!o) {
        t.push({ kind: "UnknownModel", modelKey: n });
        continue;
      }
      for (let [s, a] of Object.entries(i)) {
        let l = o.fields.find((u) => u.name === s);
        if (!l) {
          t.push({ kind: "UnknownField", modelKey: n, fieldName: s });
          continue;
        }
        if (l.relationName) {
          t.push({ kind: "RelationInOmit", modelKey: n, fieldName: s });
          continue;
        }
        typeof a != "boolean" && t.push({ kind: "InvalidFieldValue", modelKey: n, fieldName: s });
      }
    }
    if (t.length > 0)
      throw new O(Ff(e, t));
  }, __internal: (e) => {
    if (!e)
      return;
    let r = ["debug", "engine", "configOverride"];
    if (typeof e != "object")
      throw new O(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);
    for (let [t] of Object.entries(e))
      if (!r.includes(t)) {
        let n = Wr(t, r);
        throw new O(`Invalid property ${JSON.stringify(t)} for "__internal" provided to PrismaClient constructor.${n}`);
      }
  } };
  function uu(e, r) {
    for (let [t, n] of Object.entries(e)) {
      if (!iu.includes(t)) {
        let i = Wr(t, iu);
        throw new O(`Unknown property ${t} provided to PrismaClient constructor.${i}`);
      }
      _f[t](n, r);
    }
    if (e.datasourceUrl && e.datasources)
      throw new O('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
  }
  function Wr(e, r) {
    if (r.length === 0 || typeof e != "string")
      return "";
    let t = Nf(e, r);
    return t ? ` Did you mean "${t}"?` : "";
  }
  function Nf(e, r) {
    if (r.length === 0)
      return null;
    let t = r.map((i) => ({ value: i, distance: (0, lu.default)(e, i) }));
    t.sort((i, o) => i.distance < o.distance ? -1 : 1);
    let n = t[0];
    return n.distance < 3 ? n.value : null;
  }
  function Lf(e, r) {
    return au(r.models, e) ?? au(r.types, e);
  }
  function au(e, r) {
    let t = Object.keys(e).find((n) => Ye(n) === r);
    if (t)
      return e[t];
  }
  function Ff(e, r) {
    let t = _r(e);
    for (let o of r)
      switch (o.kind) {
        case "UnknownModel":
          t.arguments.getField(o.modelKey)?.markAsError(), t.addErrorMessage(() => `Unknown model name: ${o.modelKey}.`);
          break;
        case "UnknownField":
          t.arguments.getDeepField([o.modelKey, o.fieldName])?.markAsError(), t.addErrorMessage(() => `Model "${o.modelKey}" does not have a field named "${o.fieldName}".`);
          break;
        case "RelationInOmit":
          t.arguments.getDeepField([o.modelKey, o.fieldName])?.markAsError(), t.addErrorMessage(() => 'Relations are already excluded by default and can not be specified in "omit".');
          break;
        case "InvalidFieldValue":
          t.arguments.getDeepFieldValue([o.modelKey, o.fieldName])?.markAsError(), t.addErrorMessage(() => "Omit field option value must be a boolean.");
          break;
      }
    let { message: n, args: i } = In(t, "colorless");
    return `Error validating "omit" option:

${i}

${n}`;
  }
  function cu(e) {
    return e.length === 0 ? Promise.resolve([]) : new Promise((r, t) => {
      let n = new Array(e.length), i = null, o = false, s = 0, a = () => {
        o || (s++, s === e.length && (o = true, i ? t(i) : r(n)));
      }, l = (u) => {
        o || (o = true, t(u));
      };
      for (let u = 0;u < e.length; u++)
        e[u].then((c) => {
          n[u] = c, a();
        }, (c) => {
          if (!Yn(c)) {
            l(c);
            return;
          }
          c.batchRequestIdx === u ? l(c) : (i || (i = c), a());
        });
    });
  }
  var rr = N("prisma:client");
  typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
  var Mf = { requestArgsToMiddlewareArgs: (e) => e, middlewareArgsToRequestArgs: (e) => e };
  var $f = Symbol.for("prisma.client.transaction.id");
  var qf = { id: 0, nextId() {
    return ++this.id;
  } };
  function hu(e) {

    class r {
      _originalClient = this;
      _runtimeDataModel;
      _requestHandler;
      _connectionPromise;
      _disconnectionPromise;
      _engineConfig;
      _accelerateEngineConfig;
      _clientVersion;
      _errorFormat;
      _tracingHelper;
      _middlewares = new Kn;
      _previewFeatures;
      _activeProvider;
      _globalOmit;
      _extensions;
      _engine;
      _appliedParent;
      _createPrismaPromise = Ao();
      constructor(n) {
        e = n?.__internal?.configOverride?.(e) ?? e, cl(e), n && uu(n, e);
        let i = new fu.EventEmitter().on("error", () => {});
        this._extensions = Nr.empty(), this._previewFeatures = Hn(e), this._clientVersion = e.clientVersion ?? nu, this._activeProvider = e.activeProvider, this._globalOmit = n?.omit, this._tracingHelper = Yl();
        let o = e.relativeEnvPaths && { rootEnvPath: e.relativeEnvPaths.rootEnvPath && ei.default.resolve(e.dirname, e.relativeEnvPaths.rootEnvPath), schemaEnvPath: e.relativeEnvPaths.schemaEnvPath && ei.default.resolve(e.dirname, e.relativeEnvPaths.schemaEnvPath) }, s;
        if (n?.adapter) {
          s = n.adapter;
          let l = e.activeProvider === "postgresql" || e.activeProvider === "cockroachdb" ? "postgres" : e.activeProvider;
          if (s.provider !== l)
            throw new T(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`, this._clientVersion);
          if (n.datasources || n.datasourceUrl !== undefined)
            throw new T("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.", this._clientVersion);
        }
        let a = !s && o && ot(o, { conflictCheck: "none" }) || e.injectableEdgeEnv?.();
        try {
          let l = n ?? {}, u = l.__internal ?? {}, c = u.debug === true;
          c && N.enable("prisma:client");
          let p = ei.default.resolve(e.dirname, e.relativePath);
          gu.default.existsSync(p) || (p = e.dirname), rr("dirname", e.dirname), rr("relativePath", e.relativePath), rr("cwd", p);
          let d = u.engine || {};
          if (l.errorFormat ? this._errorFormat = l.errorFormat : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e.runtimeDataModel, this._engineConfig = { cwd: p, dirname: e.dirname, enableDebugLogs: c, allowTriggerPanic: d.allowTriggerPanic, prismaPath: d.binaryPath ?? undefined, engineEndpoint: d.endpoint, generator: e.generator, showColors: this._errorFormat === "pretty", logLevel: l.log && Zl(l.log), logQueries: l.log && !!(typeof l.log == "string" ? l.log === "query" : l.log.find((f) => typeof f == "string" ? f === "query" : f.level === "query")), env: a?.parsed ?? {}, flags: [], engineWasm: e.engineWasm, compilerWasm: e.compilerWasm, clientVersion: e.clientVersion, engineVersion: e.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e.activeProvider, inlineSchema: e.inlineSchema, overrideDatasources: pl(l, e.datasourceNames), inlineDatasources: e.inlineDatasources, inlineSchemaHash: e.inlineSchemaHash, tracingHelper: this._tracingHelper, transactionOptions: { maxWait: l.transactionOptions?.maxWait ?? 2000, timeout: l.transactionOptions?.timeout ?? 5000, isolationLevel: l.transactionOptions?.isolationLevel }, logEmitter: i, isBundled: e.isBundled, adapter: s }, this._accelerateEngineConfig = { ...this._engineConfig, accelerateUtils: { resolveDatasourceUrl: jr, getBatchRequestPayload: Mr, prismaGraphQLToJSError: $r, PrismaClientUnknownRequestError: j, PrismaClientInitializationError: T, PrismaClientKnownRequestError: z, debug: N("prisma:client:accelerateEngine"), engineVersion: du.version, clientVersion: e.clientVersion } }, rr("clientVersion", e.clientVersion), this._engine = ql(e, this._engineConfig), this._requestHandler = new Xn(this, i), l.log)
            for (let f of l.log) {
              let h = typeof f == "string" ? f : f.emit === "stdout" ? f.level : null;
              h && this.$on(h, (g) => {
                tt.log(`${tt.tags[h] ?? ""}`, g.message || g.query);
              });
            }
        } catch (l) {
          throw l.clientVersion = this._clientVersion, l;
        }
        return this._appliedParent = Pt(this);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClient";
      }
      $use(n) {
        this._middlewares.use(n);
      }
      $on(n, i) {
        return n === "beforeExit" ? this._engine.onBeforeExit(i) : n && this._engineConfig.logEmitter.on(n, i), this;
      }
      $connect() {
        try {
          return this._engine.start();
        } catch (n) {
          throw n.clientVersion = this._clientVersion, n;
        }
      }
      async $disconnect() {
        try {
          await this._engine.stop();
        } catch (n) {
          throw n.clientVersion = this._clientVersion, n;
        } finally {
          Qo();
        }
      }
      $executeRawInternal(n, i, o, s) {
        let a = this._activeProvider;
        return this._request({ action: "executeRaw", args: o, transaction: n, clientMethod: i, argsMapper: Co({ clientMethod: i, activeProvider: a }), callsite: Ze(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
      }
      $executeRaw(n, ...i) {
        return this._createPrismaPromise((o) => {
          if (n.raw !== undefined || n.sql !== undefined) {
            let [s, a] = pu(n, i);
            return Ro(this._activeProvider, s.text, s.values, Array.isArray(n) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o, "$executeRaw", s, a);
          }
          throw new Z("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
        });
      }
      $executeRawUnsafe(n, ...i) {
        return this._createPrismaPromise((o) => (Ro(this._activeProvider, n, i, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o, "$executeRawUnsafe", [n, ...i])));
      }
      $runCommandRaw(n) {
        if (e.activeProvider !== "mongodb")
          throw new Z(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
        return this._createPrismaPromise((i) => this._request({ args: n, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: jl, callsite: Ze(this._errorFormat), transaction: i }));
      }
      async $queryRawInternal(n, i, o, s) {
        let a = this._activeProvider;
        return this._request({ action: "queryRaw", args: o, transaction: n, clientMethod: i, argsMapper: Co({ clientMethod: i, activeProvider: a }), callsite: Ze(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
      }
      $queryRaw(n, ...i) {
        return this._createPrismaPromise((o) => {
          if (n.raw !== undefined || n.sql !== undefined)
            return this.$queryRawInternal(o, "$queryRaw", ...pu(n, i));
          throw new Z("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
        });
      }
      $queryRawTyped(n) {
        return this._createPrismaPromise((i) => {
          if (!this._hasPreviewFlag("typedSql"))
            throw new Z("`typedSql` preview feature must be enabled in order to access $queryRawTyped API", { clientVersion: this._clientVersion });
          return this.$queryRawInternal(i, "$queryRawTyped", n);
        });
      }
      $queryRawUnsafe(n, ...i) {
        return this._createPrismaPromise((o) => this.$queryRawInternal(o, "$queryRawUnsafe", [n, ...i]));
      }
      _transactionWithArray({ promises: n, options: i }) {
        let o = qf.nextId(), s = zl(n.length), a = n.map((l, u) => {
          if (l?.[Symbol.toStringTag] !== "PrismaPromise")
            throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
          let c = i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel, p = { kind: "batch", id: o, index: u, isolationLevel: c, lock: s };
          return l.requestTransaction?.(p) ?? l;
        });
        return cu(a);
      }
      async _transactionWithCallback({ callback: n, options: i }) {
        let o = { traceparent: this._tracingHelper.getTraceParent() }, s = { maxWait: i?.maxWait ?? this._engineConfig.transactionOptions.maxWait, timeout: i?.timeout ?? this._engineConfig.transactionOptions.timeout, isolationLevel: i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel }, a = await this._engine.transaction("start", o, s), l;
        try {
          let u = { kind: "itx", ...a };
          l = await n(this._createItxClient(u)), await this._engine.transaction("commit", o, a);
        } catch (u) {
          throw await this._engine.transaction("rollback", o, a).catch(() => {}), u;
        }
        return l;
      }
      _createItxClient(n) {
        return he(Pt(he(Ka(this), [re("_appliedParent", () => this._appliedParent._createItxClient(n)), re("_createPrismaPromise", () => Ao(n)), re($f, () => n.id)])), [Fr(el)]);
      }
      $transaction(n, i) {
        let o;
        typeof n == "function" ? this._engineConfig.adapter?.adapterName === "@prisma/adapter-d1" ? o = () => {
          throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.");
        } : o = () => this._transactionWithCallback({ callback: n, options: i }) : o = () => this._transactionWithArray({ promises: n, options: i });
        let s = { name: "transaction", attributes: { method: "$transaction" } };
        return this._tracingHelper.runInChildSpan(s, o);
      }
      _request(n) {
        n.otelParentCtx = this._tracingHelper.getActiveContext();
        let i = n.middlewareArgsMapper ?? Mf, o = { args: i.requestArgsToMiddlewareArgs(n.args), dataPath: n.dataPath, runInTransaction: !!n.transaction, action: n.action, model: n.model }, s = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: o.action, model: o.model, name: o.model ? `${o.model}.${o.action}` : o.action } } }, a = -1, l = async (u) => {
          let c = this._middlewares.get(++a);
          if (c)
            return this._tracingHelper.runInChildSpan(s.middleware, (S) => c(u, (P) => (S?.end(), l(P))));
          let { runInTransaction: p, args: d, ...f } = u, h = { ...n, ...f };
          d && (h.args = i.middlewareArgsToRequestArgs(d)), n.transaction !== undefined && p === false && delete h.transaction;
          let g = await il(this, h);
          return h.model ? Xa({ result: g, modelName: h.model, args: h.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel, globalOmit: this._globalOmit }) : g;
        };
        return this._tracingHelper.runInChildSpan(s.operation, () => new mu.AsyncResource("prisma-client-request").runInAsyncScope(() => l(o)));
      }
      async _executeRequest({ args: n, clientMethod: i, dataPath: o, callsite: s, action: a, model: l, argsMapper: u, transaction: c, unpacker: p, otelParentCtx: d, customDataProxyFetch: f }) {
        try {
          n = u ? u(n) : n;
          let h = { name: "serialize" }, g = this._tracingHelper.runInChildSpan(h, () => Nn({ modelName: l, runtimeDataModel: this._runtimeDataModel, action: a, args: n, clientMethod: i, callsite: s, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion, previewFeatures: this._previewFeatures, globalOmit: this._globalOmit }));
          return N.enabled("prisma:client") && (rr("Prisma Client call:"), rr(`prisma.${i}(${$a(n)})`), rr("Generated request:"), rr(JSON.stringify(g, null, 2) + `
`)), c?.kind === "batch" && await c.lock, this._requestHandler.request({ protocolQuery: g, modelName: l, action: a, clientMethod: i, dataPath: o, callsite: s, args: n, extensions: this._extensions, transaction: c, unpacker: p, otelParentCtx: d, otelChildCtx: this._tracingHelper.getActiveContext(), globalOmit: this._globalOmit, customDataProxyFetch: f });
        } catch (h) {
          throw h.clientVersion = this._clientVersion, h;
        }
      }
      $metrics = new Lr(this);
      _hasPreviewFlag(n) {
        return !!this._engineConfig.previewFeatures?.includes(n);
      }
      $applyPendingMigrations() {
        return this._engine.applyPendingMigrations();
      }
      $extends = Ya;
    }
    return r;
  }
  function pu(e, r) {
    return jf(e) ? [new oe(e, r), Jl] : [e, Hl];
  }
  function jf(e) {
    return Array.isArray(e) && Array.isArray(e.raw);
  }
  var Vf = new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
  function yu(e) {
    return new Proxy(e, { get(r, t) {
      if (t in r)
        return r[t];
      if (!Vf.has(t))
        throw new TypeError(`Invalid enum value: ${String(t)}`);
    } });
  }
  function Eu(e) {
    ot(e, { conflictCheck: "warn" });
  }
  /*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.5.0
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  */
});

// ../../packages/db/generated/prisma/index.js
var require_prisma = __commonJS((exports) => {
  var __dirname = "/home/futabandit/the-projects/better-pogtime/packages/db/generated/prisma";
  Object.defineProperty(exports, "__esModule", { value: true });
  var {
    PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
    PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
    PrismaClientRustPanicError: PrismaClientRustPanicError2,
    PrismaClientInitializationError: PrismaClientInitializationError2,
    PrismaClientValidationError: PrismaClientValidationError2,
    getPrismaClient: getPrismaClient2,
    sqltag: sqltag2,
    empty: empty2,
    join: join2,
    raw: raw2,
    skip: skip2,
    Decimal: Decimal2,
    Debug: Debug2,
    objectEnumValues: objectEnumValues2,
    makeStrictEnum: makeStrictEnum2,
    Extensions: Extensions2,
    warnOnce: warnOnce2,
    defineDmmfProperty: defineDmmfProperty2,
    Public: Public2,
    getRuntime: getRuntime2,
    createParam: createParam2
  } = require_library();
  var Prisma = {};
  exports.Prisma = Prisma;
  exports.$Enums = {};
  Prisma.prismaVersion = {
    client: "6.11.1",
    engine: "f40f79ec31188888a2e33acda0ecc8fd10a853a9"
  };
  Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
  Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
  Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
  Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
  Prisma.PrismaClientValidationError = PrismaClientValidationError2;
  Prisma.Decimal = Decimal2;
  Prisma.sql = sqltag2;
  Prisma.empty = empty2;
  Prisma.join = join2;
  Prisma.raw = raw2;
  Prisma.validator = Public2.validator;
  Prisma.getExtensionContext = Extensions2.getExtensionContext;
  Prisma.defineExtension = Extensions2.defineExtension;
  Prisma.DbNull = objectEnumValues2.instances.DbNull;
  Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
  Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
  Prisma.NullTypes = {
    DbNull: objectEnumValues2.classes.DbNull,
    JsonNull: objectEnumValues2.classes.JsonNull,
    AnyNull: objectEnumValues2.classes.AnyNull
  };
  var path = __require("path");
  exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
    ReadUncommitted: "ReadUncommitted",
    ReadCommitted: "ReadCommitted",
    RepeatableRead: "RepeatableRead",
    Serializable: "Serializable"
  });
  exports.Prisma.UserScalarFieldEnum = {
    id: "id",
    username: "username",
    password: "password"
  };
  exports.Prisma.WebsiteScalarFieldEnum = {
    id: "id",
    url: "url",
    time_added: "time_added",
    user_id: "user_id"
  };
  exports.Prisma.RegionScalarFieldEnum = {
    id: "id",
    name: "name"
  };
  exports.Prisma.Website_tickScalarFieldEnum = {
    id: "id",
    response_time_ms: "response_time_ms",
    status: "status",
    website_id: "website_id",
    region_id: "region_id",
    createdAt: "createdAt"
  };
  exports.Prisma.NotificationsScalarFieldEnum = {
    id: "id",
    user_id: "user_id",
    content: "content",
    read: "read",
    createdAt: "createdAt"
  };
  exports.Prisma.SortOrder = {
    asc: "asc",
    desc: "desc"
  };
  exports.Prisma.QueryMode = {
    default: "default",
    insensitive: "insensitive"
  };
  exports.website_status = exports.$Enums.website_status = {
    UP: "UP",
    DOWN: "DOWN",
    UNKNOWN: "UNKNOWN"
  };
  exports.Prisma.ModelName = {
    user: "user",
    website: "website",
    region: "region",
    website_tick: "website_tick",
    notifications: "notifications"
  };
  var config = {
    generator: {
      name: "client",
      provider: {
        fromEnvVar: null,
        value: "prisma-client-js"
      },
      output: {
        value: "/home/futabandit/the-projects/better-pogtime/packages/db/generated/prisma",
        fromEnvVar: null
      },
      config: {
        engineType: "library"
      },
      binaryTargets: [
        {
          fromEnvVar: null,
          value: "debian-openssl-3.0.x",
          native: true
        }
      ],
      previewFeatures: [],
      sourceFilePath: "/home/futabandit/the-projects/better-pogtime/packages/db/prisma/schema.prisma",
      isCustomOutput: true
    },
    relativeEnvPaths: {
      rootEnvPath: null,
      schemaEnvPath: "../../.env"
    },
    relativePath: "../../prisma",
    clientVersion: "6.11.1",
    engineVersion: "f40f79ec31188888a2e33acda0ecc8fd10a853a9",
    datasourceNames: [
      "db"
    ],
    activeProvider: "postgresql",
    inlineDatasources: {
      db: {
        url: {
          fromEnvVar: "DATABASE_URL",
          value: null
        }
      }
    },
    inlineSchema: `generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model user {
  id            String          @id @default(uuid())
  username      String          @unique(map: "uq_user_username")
  password      String
  websites      website[]
  notifications notifications[]
}

model website {
  id             String         @id @default(uuid())
  url            String
  time_added     DateTime       @default(now())
  user_id        String
  user           user           @relation(fields: [user_id], references: [id], onDelete: Cascade)
  website_ticker website_tick[]
}

model region {
  id           String         @id @default(uuid())
  name         String
  website_tick website_tick[]
}

model website_tick {
  id               String         @id @default(uuid())
  response_time_ms Int
  status           website_status
  website_id       String
  region_id        String
  createdAt        DateTime       @default(now())
  region           region         @relation(fields: [region_id], references: [id], onDelete: Cascade)
  website          website        @relation(fields: [website_id], references: [id], onDelete: Cascade)
}

model notifications {
  id        String   @id @default(uuid())
  user_id   String
  user      user     @relation(fields: [user_id], references: [id])
  content   String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
}

enum website_status {
  UP
  DOWN
  UNKNOWN
}
`,
    inlineSchemaHash: "f9dff791e7d08011a24747f86bf4e685f06bd44ed008587dba0e2ec7a831c8da",
    copyEngine: true
  };
  var fs = __require("fs");
  config.dirname = __dirname;
  if (!fs.existsSync(path.join(__dirname, "schema.prisma"))) {
    const alternativePaths = [
      "generated/prisma",
      "prisma"
    ];
    const alternativePath = alternativePaths.find((altPath) => {
      return fs.existsSync(path.join(process.cwd(), altPath, "schema.prisma"));
    }) ?? alternativePaths[0];
    config.dirname = path.join(process.cwd(), alternativePath);
    config.isBundled = true;
  }
  config.runtimeDataModel = JSON.parse('{"models":{"user":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"username","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"password","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"websites","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"website","nativeType":null,"relationName":"userTowebsite","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"notifications","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"notifications","nativeType":null,"relationName":"notificationsTouser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"website":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"url","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"time_added","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"user_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"user","nativeType":null,"relationName":"userTowebsite","relationFromFields":["user_id"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"website_ticker","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"website_tick","nativeType":null,"relationName":"websiteTowebsite_tick","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"region":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"website_tick","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"website_tick","nativeType":null,"relationName":"regionTowebsite_tick","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"website_tick":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"response_time_ms","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"website_status","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"website_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"region_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"region","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"region","nativeType":null,"relationName":"regionTowebsite_tick","relationFromFields":["region_id"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"website","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"website","nativeType":null,"relationName":"websiteTowebsite_tick","relationFromFields":["website_id"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"notifications":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"user_id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"user","nativeType":null,"relationName":"notificationsTouser","relationFromFields":["user_id"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"content","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"read","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false}},"enums":{"website_status":{"values":[{"name":"UP","dbName":null},{"name":"DOWN","dbName":null},{"name":"UNKNOWN","dbName":null}],"dbName":null}},"types":{}}');
  defineDmmfProperty2(exports.Prisma, config.runtimeDataModel);
  config.engineWasm = undefined;
  config.compilerWasm = undefined;
  var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
  warnEnvConflicts2({
    rootEnvPath: config.relativeEnvPaths.rootEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.rootEnvPath),
    schemaEnvPath: config.relativeEnvPaths.schemaEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.schemaEnvPath)
  });
  var PrismaClient = getPrismaClient2(config);
  exports.PrismaClient = PrismaClient;
  Object.assign(exports, Prisma);
  path.join(__dirname, "libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(process.cwd(), "generated/prisma/libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(__dirname, "schema.prisma");
  path.join(process.cwd(), "generated/prisma/schema.prisma");
});

// ../../node_modules/@redis/client/dist/lib/RESP/verbatim-string.js
var require_verbatim_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VerbatimString = undefined;

  class VerbatimString extends String {
    format;
    constructor(format, value) {
      super(value);
      this.format = format;
    }
  }
  exports.VerbatimString = VerbatimString;
});

// ../../node_modules/@redis/client/dist/lib/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MultiErrorReply = exports.TimeoutError = exports.BlobError = exports.SimpleError = exports.ErrorReply = exports.ReconnectStrategyError = exports.RootNodesUnavailableError = exports.SocketClosedUnexpectedlyError = exports.DisconnectsClientError = exports.ClientOfflineError = exports.ClientClosedError = exports.SocketTimeoutError = exports.ConnectionTimeoutError = exports.WatchError = exports.AbortError = undefined;

  class AbortError extends Error {
    constructor() {
      super("The command was aborted");
    }
  }
  exports.AbortError = AbortError;

  class WatchError extends Error {
    constructor(message = "One (or more) of the watched keys has been changed") {
      super(message);
    }
  }
  exports.WatchError = WatchError;

  class ConnectionTimeoutError extends Error {
    constructor() {
      super("Connection timeout");
    }
  }
  exports.ConnectionTimeoutError = ConnectionTimeoutError;

  class SocketTimeoutError extends Error {
    constructor(timeout) {
      super(`Socket timeout timeout. Expecting data, but didn't receive any in ${timeout}ms.`);
    }
  }
  exports.SocketTimeoutError = SocketTimeoutError;

  class ClientClosedError extends Error {
    constructor() {
      super("The client is closed");
    }
  }
  exports.ClientClosedError = ClientClosedError;

  class ClientOfflineError extends Error {
    constructor() {
      super("The client is offline");
    }
  }
  exports.ClientOfflineError = ClientOfflineError;

  class DisconnectsClientError extends Error {
    constructor() {
      super("Disconnects client");
    }
  }
  exports.DisconnectsClientError = DisconnectsClientError;

  class SocketClosedUnexpectedlyError extends Error {
    constructor() {
      super("Socket closed unexpectedly");
    }
  }
  exports.SocketClosedUnexpectedlyError = SocketClosedUnexpectedlyError;

  class RootNodesUnavailableError extends Error {
    constructor() {
      super("All the root nodes are unavailable");
    }
  }
  exports.RootNodesUnavailableError = RootNodesUnavailableError;

  class ReconnectStrategyError extends Error {
    originalError;
    socketError;
    constructor(originalError, socketError) {
      super(originalError.message);
      this.originalError = originalError;
      this.socketError = socketError;
    }
  }
  exports.ReconnectStrategyError = ReconnectStrategyError;

  class ErrorReply extends Error {
    constructor(message) {
      super(message);
      this.stack = undefined;
    }
  }
  exports.ErrorReply = ErrorReply;

  class SimpleError extends ErrorReply {
  }
  exports.SimpleError = SimpleError;

  class BlobError extends ErrorReply {
  }
  exports.BlobError = BlobError;

  class TimeoutError extends Error {
  }
  exports.TimeoutError = TimeoutError;

  class MultiErrorReply extends ErrorReply {
    replies;
    errorIndexes;
    constructor(replies, errorIndexes) {
      super(`${errorIndexes.length} commands failed, see .replies and .errorIndexes for more information`);
      this.replies = replies;
      this.errorIndexes = errorIndexes;
    }
    *errors() {
      for (const index of this.errorIndexes) {
        yield this.replies[index];
      }
    }
  }
  exports.MultiErrorReply = MultiErrorReply;
});

// ../../node_modules/@redis/client/dist/lib/RESP/decoder.js
var require_decoder = __commonJS((exports) => {
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Decoder = exports.PUSH_TYPE_MAPPING = exports.RESP_TYPES = undefined;
  var verbatim_string_1 = require_verbatim_string();
  var errors_1 = require_errors();
  exports.RESP_TYPES = {
    NULL: 95,
    BOOLEAN: 35,
    NUMBER: 58,
    BIG_NUMBER: 40,
    DOUBLE: 44,
    SIMPLE_STRING: 43,
    BLOB_STRING: 36,
    VERBATIM_STRING: 61,
    SIMPLE_ERROR: 45,
    BLOB_ERROR: 33,
    ARRAY: 42,
    SET: 126,
    MAP: 37,
    PUSH: 62
  };
  var ASCII = {
    "\r": 13,
    t: 116,
    "+": 43,
    "-": 45,
    "0": 48,
    ".": 46,
    i: 105,
    n: 110,
    E: 69,
    e: 101
  };
  exports.PUSH_TYPE_MAPPING = {
    [exports.RESP_TYPES.BLOB_STRING]: Buffer
  };

  class Decoder {
    onReply;
    onErrorReply;
    onPush;
    getTypeMapping;
    #cursor = 0;
    #next;
    constructor(config) {
      this.onReply = config.onReply;
      this.onErrorReply = config.onErrorReply;
      this.onPush = config.onPush;
      this.getTypeMapping = config.getTypeMapping;
    }
    reset() {
      this.#cursor = 0;
      this.#next = undefined;
    }
    write(chunk) {
      if (this.#cursor >= chunk.length) {
        this.#cursor -= chunk.length;
        return;
      }
      if (this.#next) {
        if (this.#next(chunk) || this.#cursor >= chunk.length) {
          this.#cursor -= chunk.length;
          return;
        }
      }
      do {
        const type = chunk[this.#cursor];
        if (++this.#cursor === chunk.length) {
          this.#next = this.#continueDecodeTypeValue.bind(this, type);
          break;
        }
        if (this.#decodeTypeValue(type, chunk)) {
          break;
        }
      } while (this.#cursor < chunk.length);
      this.#cursor -= chunk.length;
    }
    #continueDecodeTypeValue(type, chunk) {
      this.#next = undefined;
      return this.#decodeTypeValue(type, chunk);
    }
    #decodeTypeValue(type, chunk) {
      switch (type) {
        case exports.RESP_TYPES.NULL:
          this.onReply(this.#decodeNull());
          return false;
        case exports.RESP_TYPES.BOOLEAN:
          return this.#handleDecodedValue(this.onReply, this.#decodeBoolean(chunk));
        case exports.RESP_TYPES.NUMBER:
          return this.#handleDecodedValue(this.onReply, this.#decodeNumber(this.getTypeMapping()[exports.RESP_TYPES.NUMBER], chunk));
        case exports.RESP_TYPES.BIG_NUMBER:
          return this.#handleDecodedValue(this.onReply, this.#decodeBigNumber(this.getTypeMapping()[exports.RESP_TYPES.BIG_NUMBER], chunk));
        case exports.RESP_TYPES.DOUBLE:
          return this.#handleDecodedValue(this.onReply, this.#decodeDouble(this.getTypeMapping()[exports.RESP_TYPES.DOUBLE], chunk));
        case exports.RESP_TYPES.SIMPLE_STRING:
          return this.#handleDecodedValue(this.onReply, this.#decodeSimpleString(this.getTypeMapping()[exports.RESP_TYPES.SIMPLE_STRING], chunk));
        case exports.RESP_TYPES.BLOB_STRING:
          return this.#handleDecodedValue(this.onReply, this.#decodeBlobString(this.getTypeMapping()[exports.RESP_TYPES.BLOB_STRING], chunk));
        case exports.RESP_TYPES.VERBATIM_STRING:
          return this.#handleDecodedValue(this.onReply, this.#decodeVerbatimString(this.getTypeMapping()[exports.RESP_TYPES.VERBATIM_STRING], chunk));
        case exports.RESP_TYPES.SIMPLE_ERROR:
          return this.#handleDecodedValue(this.onErrorReply, this.#decodeSimpleError(chunk));
        case exports.RESP_TYPES.BLOB_ERROR:
          return this.#handleDecodedValue(this.onErrorReply, this.#decodeBlobError(chunk));
        case exports.RESP_TYPES.ARRAY:
          return this.#handleDecodedValue(this.onReply, this.#decodeArray(this.getTypeMapping(), chunk));
        case exports.RESP_TYPES.SET:
          return this.#handleDecodedValue(this.onReply, this.#decodeSet(this.getTypeMapping(), chunk));
        case exports.RESP_TYPES.MAP:
          return this.#handleDecodedValue(this.onReply, this.#decodeMap(this.getTypeMapping(), chunk));
        case exports.RESP_TYPES.PUSH:
          return this.#handleDecodedValue(this.onPush, this.#decodeArray(exports.PUSH_TYPE_MAPPING, chunk));
        default:
          throw new Error(`Unknown RESP type ${type} "${String.fromCharCode(type)}"`);
      }
    }
    #handleDecodedValue(cb, value) {
      if (typeof value === "function") {
        this.#next = this.#continueDecodeValue.bind(this, cb, value);
        return true;
      }
      cb(value);
      return false;
    }
    #continueDecodeValue(cb, next, chunk) {
      this.#next = undefined;
      return this.#handleDecodedValue(cb, next(chunk));
    }
    #decodeNull() {
      this.#cursor += 2;
      return null;
    }
    #decodeBoolean(chunk) {
      const boolean = chunk[this.#cursor] === ASCII.t;
      this.#cursor += 3;
      return boolean;
    }
    #decodeNumber(type, chunk) {
      if (type === String) {
        return this.#decodeSimpleString(String, chunk);
      }
      switch (chunk[this.#cursor]) {
        case ASCII["+"]:
          return this.#maybeDecodeNumberValue(false, chunk);
        case ASCII["-"]:
          return this.#maybeDecodeNumberValue(true, chunk);
        default:
          return this.#decodeNumberValue(false, this.#decodeUnsingedNumber.bind(this, 0), chunk);
      }
    }
    #maybeDecodeNumberValue(isNegative, chunk) {
      const cb = this.#decodeUnsingedNumber.bind(this, 0);
      return ++this.#cursor === chunk.length ? this.#decodeNumberValue.bind(this, isNegative, cb) : this.#decodeNumberValue(isNegative, cb, chunk);
    }
    #decodeNumberValue(isNegative, numberCb, chunk) {
      const number = numberCb(chunk);
      return typeof number === "function" ? this.#decodeNumberValue.bind(this, isNegative, number) : isNegative ? -number : number;
    }
    #decodeUnsingedNumber(number, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        if (byte === ASCII["\r"]) {
          this.#cursor = cursor + 2;
          return number;
        }
        number = number * 10 + byte - ASCII["0"];
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#decodeUnsingedNumber.bind(this, number);
    }
    #decodeBigNumber(type, chunk) {
      if (type === String) {
        return this.#decodeSimpleString(String, chunk);
      }
      switch (chunk[this.#cursor]) {
        case ASCII["+"]:
          return this.#maybeDecodeBigNumberValue(false, chunk);
        case ASCII["-"]:
          return this.#maybeDecodeBigNumberValue(true, chunk);
        default:
          return this.#decodeBigNumberValue(false, this.#decodeUnsingedBigNumber.bind(this, 0n), chunk);
      }
    }
    #maybeDecodeBigNumberValue(isNegative, chunk) {
      const cb = this.#decodeUnsingedBigNumber.bind(this, 0n);
      return ++this.#cursor === chunk.length ? this.#decodeBigNumberValue.bind(this, isNegative, cb) : this.#decodeBigNumberValue(isNegative, cb, chunk);
    }
    #decodeBigNumberValue(isNegative, bigNumberCb, chunk) {
      const bigNumber = bigNumberCb(chunk);
      return typeof bigNumber === "function" ? this.#decodeBigNumberValue.bind(this, isNegative, bigNumber) : isNegative ? -bigNumber : bigNumber;
    }
    #decodeUnsingedBigNumber(bigNumber, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        if (byte === ASCII["\r"]) {
          this.#cursor = cursor + 2;
          return bigNumber;
        }
        bigNumber = bigNumber * 10n + BigInt(byte - ASCII["0"]);
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#decodeUnsingedBigNumber.bind(this, bigNumber);
    }
    #decodeDouble(type, chunk) {
      if (type === String) {
        return this.#decodeSimpleString(String, chunk);
      }
      switch (chunk[this.#cursor]) {
        case ASCII.n:
          this.#cursor += 5;
          return NaN;
        case ASCII["+"]:
          return this.#maybeDecodeDoubleInteger(false, chunk);
        case ASCII["-"]:
          return this.#maybeDecodeDoubleInteger(true, chunk);
        default:
          return this.#decodeDoubleInteger(false, 0, chunk);
      }
    }
    #maybeDecodeDoubleInteger(isNegative, chunk) {
      return ++this.#cursor === chunk.length ? this.#decodeDoubleInteger.bind(this, isNegative, 0) : this.#decodeDoubleInteger(isNegative, 0, chunk);
    }
    #decodeDoubleInteger(isNegative, integer, chunk) {
      if (chunk[this.#cursor] === ASCII.i) {
        this.#cursor += 5;
        return isNegative ? -Infinity : Infinity;
      }
      return this.#continueDecodeDoubleInteger(isNegative, integer, chunk);
    }
    #continueDecodeDoubleInteger(isNegative, integer, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        switch (byte) {
          case ASCII["."]:
            this.#cursor = cursor + 1;
            return this.#cursor < chunk.length ? this.#decodeDoubleDecimal(isNegative, 0, integer, chunk) : this.#decodeDoubleDecimal.bind(this, isNegative, 0, integer);
          case ASCII.E:
          case ASCII.e:
            this.#cursor = cursor + 1;
            const i = isNegative ? -integer : integer;
            return this.#cursor < chunk.length ? this.#decodeDoubleExponent(i, chunk) : this.#decodeDoubleExponent.bind(this, i);
          case ASCII["\r"]:
            this.#cursor = cursor + 2;
            return isNegative ? -integer : integer;
          default:
            integer = integer * 10 + byte - ASCII["0"];
        }
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#continueDecodeDoubleInteger.bind(this, isNegative, integer);
    }
    static #DOUBLE_DECIMAL_MULTIPLIERS = [
      0.1,
      0.01,
      0.001,
      0.0001,
      0.00001,
      0.000001,
      0.0000001,
      0.00000001,
      0.000000001,
      0.0000000001,
      0.00000000001,
      0.000000000001,
      0.0000000000001,
      0.00000000000001,
      0.000000000000001,
      0.0000000000000001,
      0.00000000000000001
    ];
    #decodeDoubleDecimal(isNegative, decimalIndex, double, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        switch (byte) {
          case ASCII.E:
          case ASCII.e:
            this.#cursor = cursor + 1;
            const d = isNegative ? -double : double;
            return this.#cursor === chunk.length ? this.#decodeDoubleExponent.bind(this, d) : this.#decodeDoubleExponent(d, chunk);
          case ASCII["\r"]:
            this.#cursor = cursor + 2;
            return isNegative ? -double : double;
        }
        if (decimalIndex < _a.#DOUBLE_DECIMAL_MULTIPLIERS.length) {
          double += (byte - ASCII["0"]) * _a.#DOUBLE_DECIMAL_MULTIPLIERS[decimalIndex++];
        }
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#decodeDoubleDecimal.bind(this, isNegative, decimalIndex, double);
    }
    #decodeDoubleExponent(double, chunk) {
      switch (chunk[this.#cursor]) {
        case ASCII["+"]:
          return ++this.#cursor === chunk.length ? this.#continueDecodeDoubleExponent.bind(this, false, double, 0) : this.#continueDecodeDoubleExponent(false, double, 0, chunk);
        case ASCII["-"]:
          return ++this.#cursor === chunk.length ? this.#continueDecodeDoubleExponent.bind(this, true, double, 0) : this.#continueDecodeDoubleExponent(true, double, 0, chunk);
      }
      return this.#continueDecodeDoubleExponent(false, double, 0, chunk);
    }
    #continueDecodeDoubleExponent(isNegative, double, exponent, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        if (byte === ASCII["\r"]) {
          this.#cursor = cursor + 2;
          return double * 10 ** (isNegative ? -exponent : exponent);
        }
        exponent = exponent * 10 + byte - ASCII["0"];
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#continueDecodeDoubleExponent.bind(this, isNegative, double, exponent);
    }
    #findCRLF(chunk, cursor) {
      while (chunk[cursor] !== ASCII["\r"]) {
        if (++cursor === chunk.length) {
          this.#cursor = chunk.length;
          return -1;
        }
      }
      this.#cursor = cursor + 2;
      return cursor;
    }
    #decodeSimpleString(type, chunk) {
      const start = this.#cursor, crlfIndex = this.#findCRLF(chunk, start);
      if (crlfIndex === -1) {
        return this.#continueDecodeSimpleString.bind(this, [chunk.subarray(start)], type);
      }
      const slice = chunk.subarray(start, crlfIndex);
      return type === Buffer ? slice : slice.toString();
    }
    #continueDecodeSimpleString(chunks, type, chunk) {
      const start = this.#cursor, crlfIndex = this.#findCRLF(chunk, start);
      if (crlfIndex === -1) {
        chunks.push(chunk.subarray(start));
        return this.#continueDecodeSimpleString.bind(this, chunks, type);
      }
      chunks.push(chunk.subarray(start, crlfIndex));
      return type === Buffer ? Buffer.concat(chunks) : chunks.join("");
    }
    #decodeBlobString(type, chunk) {
      if (chunk[this.#cursor] === ASCII["-"]) {
        this.#cursor += 4;
        return null;
      }
      const length = this.#decodeUnsingedNumber(0, chunk);
      if (typeof length === "function") {
        return this.#continueDecodeBlobStringLength.bind(this, length, type);
      } else if (this.#cursor >= chunk.length) {
        return this.#decodeBlobStringWithLength.bind(this, length, type);
      }
      return this.#decodeBlobStringWithLength(length, type, chunk);
    }
    #continueDecodeBlobStringLength(lengthCb, type, chunk) {
      const length = lengthCb(chunk);
      if (typeof length === "function") {
        return this.#continueDecodeBlobStringLength.bind(this, length, type);
      } else if (this.#cursor >= chunk.length) {
        return this.#decodeBlobStringWithLength.bind(this, length, type);
      }
      return this.#decodeBlobStringWithLength(length, type, chunk);
    }
    #decodeStringWithLength(length, skip2, type, chunk) {
      const end = this.#cursor + length;
      if (end >= chunk.length) {
        const slice2 = chunk.subarray(this.#cursor);
        this.#cursor = chunk.length;
        return this.#continueDecodeStringWithLength.bind(this, length - slice2.length, [slice2], skip2, type);
      }
      const slice = chunk.subarray(this.#cursor, end);
      this.#cursor = end + skip2;
      return type === Buffer ? slice : slice.toString();
    }
    #continueDecodeStringWithLength(length, chunks, skip2, type, chunk) {
      const end = this.#cursor + length;
      if (end >= chunk.length) {
        const slice = chunk.subarray(this.#cursor);
        chunks.push(slice);
        this.#cursor = chunk.length;
        return this.#continueDecodeStringWithLength.bind(this, length - slice.length, chunks, skip2, type);
      }
      chunks.push(chunk.subarray(this.#cursor, end));
      this.#cursor = end + skip2;
      return type === Buffer ? Buffer.concat(chunks) : chunks.join("");
    }
    #decodeBlobStringWithLength(length, type, chunk) {
      return this.#decodeStringWithLength(length, 2, type, chunk);
    }
    #decodeVerbatimString(type, chunk) {
      return this.#continueDecodeVerbatimStringLength(this.#decodeUnsingedNumber.bind(this, 0), type, chunk);
    }
    #continueDecodeVerbatimStringLength(lengthCb, type, chunk) {
      const length = lengthCb(chunk);
      return typeof length === "function" ? this.#continueDecodeVerbatimStringLength.bind(this, length, type) : this.#decodeVerbatimStringWithLength(length, type, chunk);
    }
    #decodeVerbatimStringWithLength(length, type, chunk) {
      const stringLength = length - 4;
      if (type === verbatim_string_1.VerbatimString) {
        return this.#decodeVerbatimStringFormat(stringLength, chunk);
      }
      this.#cursor += 4;
      return this.#cursor >= chunk.length ? this.#decodeBlobStringWithLength.bind(this, stringLength, type) : this.#decodeBlobStringWithLength(stringLength, type, chunk);
    }
    #decodeVerbatimStringFormat(stringLength, chunk) {
      const formatCb = this.#decodeStringWithLength.bind(this, 3, 1, String);
      return this.#cursor >= chunk.length ? this.#continueDecodeVerbatimStringFormat.bind(this, stringLength, formatCb) : this.#continueDecodeVerbatimStringFormat(stringLength, formatCb, chunk);
    }
    #continueDecodeVerbatimStringFormat(stringLength, formatCb, chunk) {
      const format = formatCb(chunk);
      return typeof format === "function" ? this.#continueDecodeVerbatimStringFormat.bind(this, stringLength, format) : this.#decodeVerbatimStringWithFormat(stringLength, format, chunk);
    }
    #decodeVerbatimStringWithFormat(stringLength, format, chunk) {
      return this.#continueDecodeVerbatimStringWithFormat(format, this.#decodeBlobStringWithLength.bind(this, stringLength, String), chunk);
    }
    #continueDecodeVerbatimStringWithFormat(format, stringCb, chunk) {
      const string = stringCb(chunk);
      return typeof string === "function" ? this.#continueDecodeVerbatimStringWithFormat.bind(this, format, string) : new verbatim_string_1.VerbatimString(format, string);
    }
    #decodeSimpleError(chunk) {
      const string = this.#decodeSimpleString(String, chunk);
      return typeof string === "function" ? this.#continueDecodeSimpleError.bind(this, string) : new errors_1.SimpleError(string);
    }
    #continueDecodeSimpleError(stringCb, chunk) {
      const string = stringCb(chunk);
      return typeof string === "function" ? this.#continueDecodeSimpleError.bind(this, string) : new errors_1.SimpleError(string);
    }
    #decodeBlobError(chunk) {
      const string = this.#decodeBlobString(String, chunk);
      return typeof string === "function" ? this.#continueDecodeBlobError.bind(this, string) : new errors_1.BlobError(string);
    }
    #continueDecodeBlobError(stringCb, chunk) {
      const string = stringCb(chunk);
      return typeof string === "function" ? this.#continueDecodeBlobError.bind(this, string) : new errors_1.BlobError(string);
    }
    #decodeNestedType(typeMapping, chunk) {
      const type = chunk[this.#cursor];
      return ++this.#cursor === chunk.length ? this.#decodeNestedTypeValue.bind(this, type, typeMapping) : this.#decodeNestedTypeValue(type, typeMapping, chunk);
    }
    #decodeNestedTypeValue(type, typeMapping, chunk) {
      switch (type) {
        case exports.RESP_TYPES.NULL:
          return this.#decodeNull();
        case exports.RESP_TYPES.BOOLEAN:
          return this.#decodeBoolean(chunk);
        case exports.RESP_TYPES.NUMBER:
          return this.#decodeNumber(typeMapping[exports.RESP_TYPES.NUMBER], chunk);
        case exports.RESP_TYPES.BIG_NUMBER:
          return this.#decodeBigNumber(typeMapping[exports.RESP_TYPES.BIG_NUMBER], chunk);
        case exports.RESP_TYPES.DOUBLE:
          return this.#decodeDouble(typeMapping[exports.RESP_TYPES.DOUBLE], chunk);
        case exports.RESP_TYPES.SIMPLE_STRING:
          return this.#decodeSimpleString(typeMapping[exports.RESP_TYPES.SIMPLE_STRING], chunk);
        case exports.RESP_TYPES.BLOB_STRING:
          return this.#decodeBlobString(typeMapping[exports.RESP_TYPES.BLOB_STRING], chunk);
        case exports.RESP_TYPES.VERBATIM_STRING:
          return this.#decodeVerbatimString(typeMapping[exports.RESP_TYPES.VERBATIM_STRING], chunk);
        case exports.RESP_TYPES.SIMPLE_ERROR:
          return this.#decodeSimpleError(chunk);
        case exports.RESP_TYPES.BLOB_ERROR:
          return this.#decodeBlobError(chunk);
        case exports.RESP_TYPES.ARRAY:
          return this.#decodeArray(typeMapping, chunk);
        case exports.RESP_TYPES.SET:
          return this.#decodeSet(typeMapping, chunk);
        case exports.RESP_TYPES.MAP:
          return this.#decodeMap(typeMapping, chunk);
        default:
          throw new Error(`Unknown RESP type ${type} "${String.fromCharCode(type)}"`);
      }
    }
    #decodeArray(typeMapping, chunk) {
      if (chunk[this.#cursor] === ASCII["-"]) {
        this.#cursor += 4;
        return null;
      }
      return this.#decodeArrayWithLength(this.#decodeUnsingedNumber(0, chunk), typeMapping, chunk);
    }
    #decodeArrayWithLength(length, typeMapping, chunk) {
      return typeof length === "function" ? this.#continueDecodeArrayLength.bind(this, length, typeMapping) : this.#decodeArrayItems(new Array(length), 0, typeMapping, chunk);
    }
    #continueDecodeArrayLength(lengthCb, typeMapping, chunk) {
      return this.#decodeArrayWithLength(lengthCb(chunk), typeMapping, chunk);
    }
    #decodeArrayItems(array, filled, typeMapping, chunk) {
      for (let i = filled;i < array.length; i++) {
        if (this.#cursor >= chunk.length) {
          return this.#decodeArrayItems.bind(this, array, i, typeMapping);
        }
        const item = this.#decodeNestedType(typeMapping, chunk);
        if (typeof item === "function") {
          return this.#continueDecodeArrayItems.bind(this, array, i, item, typeMapping);
        }
        array[i] = item;
      }
      return array;
    }
    #continueDecodeArrayItems(array, filled, itemCb, typeMapping, chunk) {
      const item = itemCb(chunk);
      if (typeof item === "function") {
        return this.#continueDecodeArrayItems.bind(this, array, filled, item, typeMapping);
      }
      array[filled++] = item;
      return this.#decodeArrayItems(array, filled, typeMapping, chunk);
    }
    #decodeSet(typeMapping, chunk) {
      const length = this.#decodeUnsingedNumber(0, chunk);
      if (typeof length === "function") {
        return this.#continueDecodeSetLength.bind(this, length, typeMapping);
      }
      return this.#decodeSetItems(length, typeMapping, chunk);
    }
    #continueDecodeSetLength(lengthCb, typeMapping, chunk) {
      const length = lengthCb(chunk);
      return typeof length === "function" ? this.#continueDecodeSetLength.bind(this, length, typeMapping) : this.#decodeSetItems(length, typeMapping, chunk);
    }
    #decodeSetItems(length, typeMapping, chunk) {
      return typeMapping[exports.RESP_TYPES.SET] === Set ? this.#decodeSetAsSet(new Set, length, typeMapping, chunk) : this.#decodeArrayItems(new Array(length), 0, typeMapping, chunk);
    }
    #decodeSetAsSet(set, remaining, typeMapping, chunk) {
      while (remaining > 0) {
        if (this.#cursor >= chunk.length) {
          return this.#decodeSetAsSet.bind(this, set, remaining, typeMapping);
        }
        const item = this.#decodeNestedType(typeMapping, chunk);
        if (typeof item === "function") {
          return this.#continueDecodeSetAsSet.bind(this, set, remaining, item, typeMapping);
        }
        set.add(item);
        --remaining;
      }
      return set;
    }
    #continueDecodeSetAsSet(set, remaining, itemCb, typeMapping, chunk) {
      const item = itemCb(chunk);
      if (typeof item === "function") {
        return this.#continueDecodeSetAsSet.bind(this, set, remaining, item, typeMapping);
      }
      set.add(item);
      return this.#decodeSetAsSet(set, remaining - 1, typeMapping, chunk);
    }
    #decodeMap(typeMapping, chunk) {
      const length = this.#decodeUnsingedNumber(0, chunk);
      if (typeof length === "function") {
        return this.#continueDecodeMapLength.bind(this, length, typeMapping);
      }
      return this.#decodeMapItems(length, typeMapping, chunk);
    }
    #continueDecodeMapLength(lengthCb, typeMapping, chunk) {
      const length = lengthCb(chunk);
      return typeof length === "function" ? this.#continueDecodeMapLength.bind(this, length, typeMapping) : this.#decodeMapItems(length, typeMapping, chunk);
    }
    #decodeMapItems(length, typeMapping, chunk) {
      switch (typeMapping[exports.RESP_TYPES.MAP]) {
        case Map:
          return this.#decodeMapAsMap(new Map, length, typeMapping, chunk);
        case Array:
          return this.#decodeArrayItems(new Array(length * 2), 0, typeMapping, chunk);
        default:
          return this.#decodeMapAsObject(Object.create(null), length, typeMapping, chunk);
      }
    }
    #decodeMapAsMap(map, remaining, typeMapping, chunk) {
      while (remaining > 0) {
        if (this.#cursor >= chunk.length) {
          return this.#decodeMapAsMap.bind(this, map, remaining, typeMapping);
        }
        const key = this.#decodeMapKey(typeMapping, chunk);
        if (typeof key === "function") {
          return this.#continueDecodeMapKey.bind(this, map, remaining, key, typeMapping);
        }
        if (this.#cursor >= chunk.length) {
          return this.#continueDecodeMapValue.bind(this, map, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
        }
        const value = this.#decodeNestedType(typeMapping, chunk);
        if (typeof value === "function") {
          return this.#continueDecodeMapValue.bind(this, map, remaining, key, value, typeMapping);
        }
        map.set(key, value);
        --remaining;
      }
      return map;
    }
    #decodeMapKey(typeMapping, chunk) {
      const type = chunk[this.#cursor];
      return ++this.#cursor === chunk.length ? this.#decodeMapKeyValue.bind(this, type, typeMapping) : this.#decodeMapKeyValue(type, typeMapping, chunk);
    }
    #decodeMapKeyValue(type, typeMapping, chunk) {
      switch (type) {
        case exports.RESP_TYPES.SIMPLE_STRING:
          return this.#decodeSimpleString(String, chunk);
        case exports.RESP_TYPES.BLOB_STRING:
          return this.#decodeBlobString(String, chunk);
        default:
          return this.#decodeNestedTypeValue(type, typeMapping, chunk);
      }
    }
    #continueDecodeMapKey(map, remaining, keyCb, typeMapping, chunk) {
      const key = keyCb(chunk);
      if (typeof key === "function") {
        return this.#continueDecodeMapKey.bind(this, map, remaining, key, typeMapping);
      }
      if (this.#cursor >= chunk.length) {
        return this.#continueDecodeMapValue.bind(this, map, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
      }
      const value = this.#decodeNestedType(typeMapping, chunk);
      if (typeof value === "function") {
        return this.#continueDecodeMapValue.bind(this, map, remaining, key, value, typeMapping);
      }
      map.set(key, value);
      return this.#decodeMapAsMap(map, remaining - 1, typeMapping, chunk);
    }
    #continueDecodeMapValue(map, remaining, key, valueCb, typeMapping, chunk) {
      const value = valueCb(chunk);
      if (typeof value === "function") {
        return this.#continueDecodeMapValue.bind(this, map, remaining, key, value, typeMapping);
      }
      map.set(key, value);
      return this.#decodeMapAsMap(map, remaining - 1, typeMapping, chunk);
    }
    #decodeMapAsObject(object, remaining, typeMapping, chunk) {
      while (remaining > 0) {
        if (this.#cursor >= chunk.length) {
          return this.#decodeMapAsObject.bind(this, object, remaining, typeMapping);
        }
        const key = this.#decodeMapKey(typeMapping, chunk);
        if (typeof key === "function") {
          return this.#continueDecodeMapAsObjectKey.bind(this, object, remaining, key, typeMapping);
        }
        if (this.#cursor >= chunk.length) {
          return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
        }
        const value = this.#decodeNestedType(typeMapping, chunk);
        if (typeof value === "function") {
          return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, value, typeMapping);
        }
        object[key] = value;
        --remaining;
      }
      return object;
    }
    #continueDecodeMapAsObjectKey(object, remaining, keyCb, typeMapping, chunk) {
      const key = keyCb(chunk);
      if (typeof key === "function") {
        return this.#continueDecodeMapAsObjectKey.bind(this, object, remaining, key, typeMapping);
      }
      if (this.#cursor >= chunk.length) {
        return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
      }
      const value = this.#decodeNestedType(typeMapping, chunk);
      if (typeof value === "function") {
        return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, value, typeMapping);
      }
      object[key] = value;
      return this.#decodeMapAsObject(object, remaining - 1, typeMapping, chunk);
    }
    #continueDecodeMapAsObjectValue(object, remaining, key, valueCb, typeMapping, chunk) {
      const value = valueCb(chunk);
      if (typeof value === "function") {
        return this.#continueDecodeMapAsObjectValue.bind(this, object, remaining, key, value, typeMapping);
      }
      object[key] = value;
      return this.#decodeMapAsObject(object, remaining - 1, typeMapping, chunk);
    }
  }
  exports.Decoder = Decoder;
  _a = Decoder;
});

// ../../node_modules/@redis/client/dist/lib/lua-script.js
var require_lua_script = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scriptSha1 = exports.defineScript = undefined;
  var node_crypto_1 = __require("crypto");
  function defineScript(script) {
    return {
      ...script,
      SHA1: scriptSha1(script.SCRIPT)
    };
  }
  exports.defineScript = defineScript;
  function scriptSha1(script) {
    return (0, node_crypto_1.createHash)("sha1").update(script).digest("hex");
  }
  exports.scriptSha1 = scriptSha1;
});

// ../../node_modules/@redis/client/dist/lib/commands/ACL_CAT.js
var require_ACL_CAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, categoryName) {
      parser.push("ACL", "CAT");
      if (categoryName) {
        parser.push(categoryName);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ACL_DELUSER.js
var require_ACL_DELUSER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, username) {
      parser.push("ACL", "DELUSER");
      parser.pushVariadic(username);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ACL_DRYRUN.js
var require_ACL_DRYRUN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, username, command) {
      parser.push("ACL", "DRYRUN", username, ...command);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ACL_GENPASS.js
var require_ACL_GENPASS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, bits) {
      parser.push("ACL", "GENPASS");
      if (bits) {
        parser.push(bits.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ACL_GETUSER.js
var require_ACL_GETUSER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, username) {
      parser.push("ACL", "GETUSER", username);
    },
    transformReply: {
      2: (reply) => ({
        flags: reply[1],
        passwords: reply[3],
        commands: reply[5],
        keys: reply[7],
        channels: reply[9],
        selectors: reply[11]?.map((selector) => {
          const inferred = selector;
          return {
            commands: inferred[1],
            keys: inferred[3],
            channels: inferred[5]
          };
        })
      }),
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ACL_LIST.js
var require_ACL_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "LIST");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ACL_LOAD.js
var require_ACL_LOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "LOAD");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/client/parser.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BasicCommandParser = undefined;

  class BasicCommandParser {
    #redisArgs = [];
    #keys = [];
    preserve;
    get redisArgs() {
      return this.#redisArgs;
    }
    get keys() {
      return this.#keys;
    }
    get firstKey() {
      return this.#keys[0];
    }
    get cacheKey() {
      const tmp = new Array(this.#redisArgs.length * 2);
      for (let i = 0;i < this.#redisArgs.length; i++) {
        tmp[i] = this.#redisArgs[i].length;
        tmp[i + this.#redisArgs.length] = this.#redisArgs[i];
      }
      return tmp.join("_");
    }
    push(...arg) {
      this.#redisArgs.push(...arg);
    }
    pushVariadic(vals) {
      if (Array.isArray(vals)) {
        for (const val of vals) {
          this.push(val);
        }
      } else {
        this.push(vals);
      }
    }
    pushVariadicWithLength(vals) {
      if (Array.isArray(vals)) {
        this.#redisArgs.push(vals.length.toString());
      } else {
        this.#redisArgs.push("1");
      }
      this.pushVariadic(vals);
    }
    pushVariadicNumber(vals) {
      if (Array.isArray(vals)) {
        for (const val of vals) {
          this.push(val.toString());
        }
      } else {
        this.push(vals.toString());
      }
    }
    pushKey(key) {
      this.#keys.push(key);
      this.#redisArgs.push(key);
    }
    pushKeysLength(keys) {
      if (Array.isArray(keys)) {
        this.#redisArgs.push(keys.length.toString());
      } else {
        this.#redisArgs.push("1");
      }
      this.pushKeys(keys);
    }
    pushKeys(keys) {
      if (Array.isArray(keys)) {
        this.#keys.push(...keys);
        this.#redisArgs.push(...keys);
      } else {
        this.#keys.push(keys);
        this.#redisArgs.push(keys);
      }
    }
  }
  exports.BasicCommandParser = BasicCommandParser;
});

// ../../node_modules/@redis/client/dist/lib/commands/generic-transformers.js
var require_generic_transformers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRedisJsonNullReply = exports.transformRedisJsonReply = exports.transformRedisJsonArgument = exports.transformStreamsMessagesReplyResp3 = exports.transformStreamsMessagesReplyResp2 = exports.transformStreamMessagesReply = exports.transformStreamMessageNullReply = exports.transformStreamMessageReply = exports.parseArgs = exports.parseZKeysArguments = exports.transformRangeReply = exports.parseSlotRangesArguments = exports.transformFunctionListItemReply = exports.RedisFunctionFlags = exports.transformCommandReply = exports.CommandCategories = exports.CommandFlags = exports.parseOptionalVariadicArgument = exports.pushVariadicArgument = exports.pushVariadicNumberArguments = exports.pushVariadicArguments = exports.pushEvalArguments = exports.evalFirstKeyIndex = exports.transformPXAT = exports.transformEXAT = exports.transformSortedSetReply = exports.transformTuplesReply = exports.createTransformTuplesReplyFunc = exports.transformTuplesToMap = exports.transformNullableDoubleReply = exports.createTransformNullableDoubleReplyResp2Func = exports.transformDoubleArrayReply = exports.createTransformDoubleReplyResp2Func = exports.transformDoubleReply = exports.transformStringDoubleArgument = exports.transformDoubleArgument = exports.transformBooleanArrayReply = exports.transformBooleanReply = exports.isArrayReply = exports.isNullReply = undefined;
  var parser_1 = require_parser();
  var decoder_1 = require_decoder();
  function isNullReply(reply) {
    return reply === null;
  }
  exports.isNullReply = isNullReply;
  function isArrayReply(reply) {
    return Array.isArray(reply);
  }
  exports.isArrayReply = isArrayReply;
  exports.transformBooleanReply = {
    2: (reply) => reply === 1,
    3: undefined
  };
  exports.transformBooleanArrayReply = {
    2: (reply) => {
      return reply.map(exports.transformBooleanReply[2]);
    },
    3: undefined
  };
  function transformDoubleArgument(num) {
    switch (num) {
      case Infinity:
        return "+inf";
      case -Infinity:
        return "-inf";
      default:
        return num.toString();
    }
  }
  exports.transformDoubleArgument = transformDoubleArgument;
  function transformStringDoubleArgument(num) {
    if (typeof num !== "number")
      return num;
    return transformDoubleArgument(num);
  }
  exports.transformStringDoubleArgument = transformStringDoubleArgument;
  exports.transformDoubleReply = {
    2: (reply, preserve, typeMapping) => {
      const double = typeMapping ? typeMapping[decoder_1.RESP_TYPES.DOUBLE] : undefined;
      switch (double) {
        case String: {
          return reply;
        }
        default: {
          let ret;
          switch (reply.toString()) {
            case "inf":
            case "+inf":
              ret = Infinity;
            case "-inf":
              ret = -Infinity;
            case "nan":
              ret = NaN;
            default:
              ret = Number(reply);
          }
          return ret;
        }
      }
    },
    3: undefined
  };
  function createTransformDoubleReplyResp2Func(preserve, typeMapping) {
    return (reply) => {
      return exports.transformDoubleReply[2](reply, preserve, typeMapping);
    };
  }
  exports.createTransformDoubleReplyResp2Func = createTransformDoubleReplyResp2Func;
  exports.transformDoubleArrayReply = {
    2: (reply, preserve, typeMapping) => {
      return reply.map(createTransformDoubleReplyResp2Func(preserve, typeMapping));
    },
    3: undefined
  };
  function createTransformNullableDoubleReplyResp2Func(preserve, typeMapping) {
    return (reply) => {
      return exports.transformNullableDoubleReply[2](reply, preserve, typeMapping);
    };
  }
  exports.createTransformNullableDoubleReplyResp2Func = createTransformNullableDoubleReplyResp2Func;
  exports.transformNullableDoubleReply = {
    2: (reply, preserve, typeMapping) => {
      if (reply === null)
        return null;
      return exports.transformDoubleReply[2](reply, preserve, typeMapping);
    },
    3: undefined
  };
  function transformTuplesToMap(reply, func) {
    const message = Object.create(null);
    for (let i = 0;i < reply.length; i += 2) {
      message[reply[i].toString()] = func(reply[i + 1]);
    }
    return message;
  }
  exports.transformTuplesToMap = transformTuplesToMap;
  function createTransformTuplesReplyFunc(preserve, typeMapping) {
    return (reply) => {
      return transformTuplesReply(reply, preserve, typeMapping);
    };
  }
  exports.createTransformTuplesReplyFunc = createTransformTuplesReplyFunc;
  function transformTuplesReply(reply, preserve, typeMapping) {
    const mapType = typeMapping ? typeMapping[decoder_1.RESP_TYPES.MAP] : undefined;
    const inferred = reply;
    switch (mapType) {
      case Array: {
        return reply;
      }
      case Map: {
        const ret = new Map;
        for (let i = 0;i < inferred.length; i += 2) {
          ret.set(inferred[i].toString(), inferred[i + 1]);
        }
        return ret;
      }
      default: {
        const ret = Object.create(null);
        for (let i = 0;i < inferred.length; i += 2) {
          ret[inferred[i].toString()] = inferred[i + 1];
        }
        return ret;
      }
    }
  }
  exports.transformTuplesReply = transformTuplesReply;
  exports.transformSortedSetReply = {
    2: (reply, preserve, typeMapping) => {
      const inferred = reply, members = [];
      for (let i = 0;i < inferred.length; i += 2) {
        members.push({
          value: inferred[i],
          score: exports.transformDoubleReply[2](inferred[i + 1], preserve, typeMapping)
        });
      }
      return members;
    },
    3: (reply) => {
      return reply.map((member) => {
        const [value, score] = member;
        return {
          value,
          score
        };
      });
    }
  };
  function transformEXAT(EXAT) {
    return (typeof EXAT === "number" ? EXAT : Math.floor(EXAT.getTime() / 1000)).toString();
  }
  exports.transformEXAT = transformEXAT;
  function transformPXAT(PXAT) {
    return (typeof PXAT === "number" ? PXAT : PXAT.getTime()).toString();
  }
  exports.transformPXAT = transformPXAT;
  function evalFirstKeyIndex(options) {
    return options?.keys?.[0];
  }
  exports.evalFirstKeyIndex = evalFirstKeyIndex;
  function pushEvalArguments(args, options) {
    if (options?.keys) {
      args.push(options.keys.length.toString(), ...options.keys);
    } else {
      args.push("0");
    }
    if (options?.arguments) {
      args.push(...options.arguments);
    }
    return args;
  }
  exports.pushEvalArguments = pushEvalArguments;
  function pushVariadicArguments(args, value) {
    if (Array.isArray(value)) {
      args = args.concat(value);
    } else {
      args.push(value);
    }
    return args;
  }
  exports.pushVariadicArguments = pushVariadicArguments;
  function pushVariadicNumberArguments(args, value) {
    if (Array.isArray(value)) {
      for (const item of value) {
        args.push(item.toString());
      }
    } else {
      args.push(value.toString());
    }
    return args;
  }
  exports.pushVariadicNumberArguments = pushVariadicNumberArguments;
  function pushVariadicArgument(args, value) {
    if (Array.isArray(value)) {
      args.push(value.length.toString(), ...value);
    } else {
      args.push("1", value);
    }
    return args;
  }
  exports.pushVariadicArgument = pushVariadicArgument;
  function parseOptionalVariadicArgument(parser, name, value) {
    if (value === undefined)
      return;
    parser.push(name);
    parser.pushVariadicWithLength(value);
  }
  exports.parseOptionalVariadicArgument = parseOptionalVariadicArgument;
  var CommandFlags;
  (function(CommandFlags2) {
    CommandFlags2["WRITE"] = "write";
    CommandFlags2["READONLY"] = "readonly";
    CommandFlags2["DENYOOM"] = "denyoom";
    CommandFlags2["ADMIN"] = "admin";
    CommandFlags2["PUBSUB"] = "pubsub";
    CommandFlags2["NOSCRIPT"] = "noscript";
    CommandFlags2["RANDOM"] = "random";
    CommandFlags2["SORT_FOR_SCRIPT"] = "sort_for_script";
    CommandFlags2["LOADING"] = "loading";
    CommandFlags2["STALE"] = "stale";
    CommandFlags2["SKIP_MONITOR"] = "skip_monitor";
    CommandFlags2["ASKING"] = "asking";
    CommandFlags2["FAST"] = "fast";
    CommandFlags2["MOVABLEKEYS"] = "movablekeys";
  })(CommandFlags || (exports.CommandFlags = CommandFlags = {}));
  var CommandCategories;
  (function(CommandCategories2) {
    CommandCategories2["KEYSPACE"] = "@keyspace";
    CommandCategories2["READ"] = "@read";
    CommandCategories2["WRITE"] = "@write";
    CommandCategories2["SET"] = "@set";
    CommandCategories2["SORTEDSET"] = "@sortedset";
    CommandCategories2["LIST"] = "@list";
    CommandCategories2["HASH"] = "@hash";
    CommandCategories2["STRING"] = "@string";
    CommandCategories2["BITMAP"] = "@bitmap";
    CommandCategories2["HYPERLOGLOG"] = "@hyperloglog";
    CommandCategories2["GEO"] = "@geo";
    CommandCategories2["STREAM"] = "@stream";
    CommandCategories2["PUBSUB"] = "@pubsub";
    CommandCategories2["ADMIN"] = "@admin";
    CommandCategories2["FAST"] = "@fast";
    CommandCategories2["SLOW"] = "@slow";
    CommandCategories2["BLOCKING"] = "@blocking";
    CommandCategories2["DANGEROUS"] = "@dangerous";
    CommandCategories2["CONNECTION"] = "@connection";
    CommandCategories2["TRANSACTION"] = "@transaction";
    CommandCategories2["SCRIPTING"] = "@scripting";
  })(CommandCategories || (exports.CommandCategories = CommandCategories = {}));
  function transformCommandReply([name, arity, flags, firstKeyIndex, lastKeyIndex, step, categories]) {
    return {
      name,
      arity,
      flags: new Set(flags),
      firstKeyIndex,
      lastKeyIndex,
      step,
      categories: new Set(categories)
    };
  }
  exports.transformCommandReply = transformCommandReply;
  var RedisFunctionFlags;
  (function(RedisFunctionFlags2) {
    RedisFunctionFlags2["NO_WRITES"] = "no-writes";
    RedisFunctionFlags2["ALLOW_OOM"] = "allow-oom";
    RedisFunctionFlags2["ALLOW_STALE"] = "allow-stale";
    RedisFunctionFlags2["NO_CLUSTER"] = "no-cluster";
  })(RedisFunctionFlags || (exports.RedisFunctionFlags = RedisFunctionFlags = {}));
  function transformFunctionListItemReply(reply) {
    return {
      libraryName: reply[1],
      engine: reply[3],
      functions: reply[5].map((fn) => ({
        name: fn[1],
        description: fn[3],
        flags: fn[5]
      }))
    };
  }
  exports.transformFunctionListItemReply = transformFunctionListItemReply;
  function parseSlotRangeArguments(parser, range) {
    parser.push(range.start.toString(), range.end.toString());
  }
  function parseSlotRangesArguments(parser, ranges) {
    if (Array.isArray(ranges)) {
      for (const range of ranges) {
        parseSlotRangeArguments(parser, range);
      }
    } else {
      parseSlotRangeArguments(parser, ranges);
    }
  }
  exports.parseSlotRangesArguments = parseSlotRangesArguments;
  function transformRangeReply([start, end]) {
    return {
      start,
      end
    };
  }
  exports.transformRangeReply = transformRangeReply;
  function parseZKeysArguments(parser, keys) {
    if (Array.isArray(keys)) {
      parser.push(keys.length.toString());
      if (keys.length) {
        if (isPlainKeys(keys)) {
          parser.pushKeys(keys);
        } else {
          for (let i = 0;i < keys.length; i++) {
            parser.pushKey(keys[i].key);
          }
          parser.push("WEIGHTS");
          for (let i = 0;i < keys.length; i++) {
            parser.push(transformDoubleArgument(keys[i].weight));
          }
        }
      }
    } else {
      parser.push("1");
      if (isPlainKey(keys)) {
        parser.pushKey(keys);
      } else {
        parser.pushKey(keys.key);
        parser.push("WEIGHTS", transformDoubleArgument(keys.weight));
      }
    }
  }
  exports.parseZKeysArguments = parseZKeysArguments;
  function isPlainKey(key) {
    return typeof key === "string" || key instanceof Buffer;
  }
  function isPlainKeys(keys) {
    return isPlainKey(keys[0]);
  }
  function parseArgs(command, ...args) {
    const parser = new parser_1.BasicCommandParser;
    command.parseCommand(parser, ...args);
    const redisArgs = parser.redisArgs;
    if (parser.preserve) {
      redisArgs.preserve = parser.preserve;
    }
    return redisArgs;
  }
  exports.parseArgs = parseArgs;
  function transformStreamMessageReply(typeMapping, reply) {
    const [id, message] = reply;
    return {
      id,
      message: transformTuplesReply(message, undefined, typeMapping)
    };
  }
  exports.transformStreamMessageReply = transformStreamMessageReply;
  function transformStreamMessageNullReply(typeMapping, reply) {
    return isNullReply(reply) ? reply : transformStreamMessageReply(typeMapping, reply);
  }
  exports.transformStreamMessageNullReply = transformStreamMessageNullReply;
  function transformStreamMessagesReply(r, typeMapping) {
    const reply = r;
    return reply.map(transformStreamMessageReply.bind(undefined, typeMapping));
  }
  exports.transformStreamMessagesReply = transformStreamMessagesReply;
  function transformStreamsMessagesReplyResp2(reply, preserve, typeMapping) {
    if (reply === null)
      return null;
    switch (typeMapping ? typeMapping[decoder_1.RESP_TYPES.MAP] : undefined) {
      default: {
        const ret = [];
        for (let i = 0;i < reply.length; i++) {
          const stream4 = reply[i];
          ret.push({
            name: stream4[0],
            messages: transformStreamMessagesReply(stream4[1])
          });
        }
        return ret;
      }
    }
  }
  exports.transformStreamsMessagesReplyResp2 = transformStreamsMessagesReplyResp2;
  function transformStreamsMessagesReplyResp3(reply) {
    if (reply === null)
      return null;
    if (reply instanceof Map) {
      const ret = new Map;
      for (const [n, rawMessages] of reply) {
        const name = n;
        ret.set(name.toString(), transformStreamMessagesReply(rawMessages));
      }
      return ret;
    } else if (reply instanceof Array) {
      const ret = [];
      for (let i = 0;i < reply.length; i += 2) {
        const name = reply[i];
        const rawMessages = reply[i + 1];
        ret.push(name);
        ret.push(transformStreamMessagesReply(rawMessages));
      }
      return ret;
    } else {
      const ret = Object.create(null);
      for (const [name, rawMessages] of Object.entries(reply)) {
        ret[name] = transformStreamMessagesReply(rawMessages);
      }
      return ret;
    }
  }
  exports.transformStreamsMessagesReplyResp3 = transformStreamsMessagesReplyResp3;
  function transformRedisJsonArgument(json) {
    return JSON.stringify(json);
  }
  exports.transformRedisJsonArgument = transformRedisJsonArgument;
  function transformRedisJsonReply(json) {
    const res = JSON.parse(json.toString());
    return res;
  }
  exports.transformRedisJsonReply = transformRedisJsonReply;
  function transformRedisJsonNullReply(json) {
    return isNullReply(json) ? json : transformRedisJsonReply(json);
  }
  exports.transformRedisJsonNullReply = transformRedisJsonNullReply;
});

// ../../node_modules/@redis/client/dist/lib/commands/ACL_LOG.js
var require_ACL_LOG = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, count) {
      parser.push("ACL", "LOG");
      if (count != null) {
        parser.push(count.toString());
      }
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        return reply.map((item) => {
          const inferred = item;
          return {
            count: inferred[1],
            reason: inferred[3],
            context: inferred[5],
            object: inferred[7],
            username: inferred[9],
            "age-seconds": generic_transformers_1.transformDoubleReply[2](inferred[11], preserve, typeMapping),
            "client-info": inferred[13],
            "entry-id": inferred[15],
            "timestamp-created": inferred[17],
            "timestamp-last-updated": inferred[19]
          };
        });
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ACL_LOG_RESET.js
var require_ACL_LOG_RESET = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ACL_LOG_1 = __importDefault(require_ACL_LOG());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: ACL_LOG_1.default.IS_READ_ONLY,
    parseCommand(parser) {
      parser.push("ACL", "LOG", "RESET");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ACL_SAVE.js
var require_ACL_SAVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "SAVE");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ACL_SETUSER.js
var require_ACL_SETUSER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, username, rule) {
      parser.push("ACL", "SETUSER", username);
      parser.pushVariadic(rule);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ACL_USERS.js
var require_ACL_USERS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "USERS");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ACL_WHOAMI.js
var require_ACL_WHOAMI = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "WHOAMI");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/APPEND.js
var require_APPEND = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, value) {
      parser.push("APPEND", key, value);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ASKING.js
var require_ASKING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ASKING_CMD = undefined;
  exports.ASKING_CMD = "ASKING";
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push(exports.ASKING_CMD);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/AUTH.js
var require_AUTH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, { username, password }) {
      parser.push("AUTH");
      if (username !== undefined) {
        parser.push(username);
      }
      parser.push(password);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BGREWRITEAOF.js
var require_BGREWRITEAOF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("BGREWRITEAOF");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BGSAVE.js
var require_BGSAVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, options) {
      parser.push("BGSAVE");
      if (options?.SCHEDULE) {
        parser.push("SCHEDULE");
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BITCOUNT.js
var require_BITCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, range) {
      parser.push("BITCOUNT");
      parser.pushKey(key);
      if (range) {
        parser.push(range.start.toString());
        parser.push(range.end.toString());
        if (range.mode) {
          parser.push(range.mode);
        }
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BITFIELD_RO.js
var require_BITFIELD_RO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, operations) {
      parser.push("BITFIELD_RO");
      parser.pushKey(key);
      for (const operation of operations) {
        parser.push("GET");
        parser.push(operation.encoding);
        parser.push(operation.offset.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BITFIELD.js
var require_BITFIELD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, operations) {
      parser.push("BITFIELD");
      parser.pushKey(key);
      for (const options of operations) {
        switch (options.operation) {
          case "GET":
            parser.push("GET", options.encoding, options.offset.toString());
            break;
          case "SET":
            parser.push("SET", options.encoding, options.offset.toString(), options.value.toString());
            break;
          case "INCRBY":
            parser.push("INCRBY", options.encoding, options.offset.toString(), options.increment.toString());
            break;
          case "OVERFLOW":
            parser.push("OVERFLOW", options.behavior);
            break;
        }
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BITOP.js
var require_BITOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, operation, destKey, key) {
      parser.push("BITOP", operation);
      parser.pushKey(destKey);
      parser.pushKeys(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BITPOS.js
var require_BITPOS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, bit, start, end, mode) {
      parser.push("BITPOS");
      parser.pushKey(key);
      parser.push(bit.toString());
      if (start !== undefined) {
        parser.push(start.toString());
      }
      if (end !== undefined) {
        parser.push(end.toString());
      }
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BLMOVE.js
var require_BLMOVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, sourceSide, destinationSide, timeout) {
      parser.push("BLMOVE");
      parser.pushKeys([source, destination]);
      parser.push(sourceSide, destinationSide, timeout.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LMPOP.js
var require_LMPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseLMPopArguments = undefined;
  function parseLMPopArguments(parser, keys, side, options) {
    parser.pushKeysLength(keys);
    parser.push(side);
    if (options?.COUNT !== undefined) {
      parser.push("COUNT", options.COUNT.toString());
    }
  }
  exports.parseLMPopArguments = parseLMPopArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, ...args) {
      parser.push("LMPOP");
      parseLMPopArguments(parser, ...args);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BLMPOP.js
var require_BLMPOP = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LMPOP_1 = __importStar(require_LMPOP());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, timeout, ...args) {
      parser.push("BLMPOP", timeout.toString());
      (0, LMPOP_1.parseLMPopArguments)(parser, ...args);
    },
    transformReply: LMPOP_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BLPOP.js
var require_BLPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, timeout) {
      parser.push("BLPOP");
      parser.pushKeys(key);
      parser.push(timeout.toString());
    },
    transformReply(reply) {
      if (reply === null)
        return null;
      return {
        key: reply[0],
        element: reply[1]
      };
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BRPOP.js
var require_BRPOP = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var BLPOP_1 = __importDefault(require_BLPOP());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, timeout) {
      parser.push("BRPOP");
      parser.pushKeys(key);
      parser.push(timeout.toString());
    },
    transformReply: BLPOP_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BRPOPLPUSH.js
var require_BRPOPLPUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, timeout) {
      parser.push("BRPOPLPUSH");
      parser.pushKeys([source, destination]);
      parser.push(timeout.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZMPOP.js
var require_ZMPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseZMPopArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function parseZMPopArguments(parser, keys, side, options) {
    parser.pushKeysLength(keys);
    parser.push(side);
    if (options?.COUNT) {
      parser.push("COUNT", options.COUNT.toString());
    }
  }
  exports.parseZMPopArguments = parseZMPopArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, keys, side, options) {
      parser.push("ZMPOP");
      parseZMPopArguments(parser, keys, side, options);
    },
    transformReply: {
      2(reply, preserve, typeMapping) {
        return reply === null ? null : {
          key: reply[0],
          members: reply[1].map((member) => {
            const [value, score] = member;
            return {
              value,
              score: generic_transformers_1.transformDoubleReply[2](score, preserve, typeMapping)
            };
          })
        };
      },
      3(reply) {
        return reply === null ? null : {
          key: reply[0],
          members: generic_transformers_1.transformSortedSetReply[3](reply[1])
        };
      }
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BZMPOP.js
var require_BZMPOP = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZMPOP_1 = __importStar(require_ZMPOP());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, timeout, ...args) {
      parser.push("BZMPOP", timeout.toString());
      (0, ZMPOP_1.parseZMPopArguments)(parser, ...args);
    },
    transformReply: ZMPOP_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BZPOPMAX.js
var require_BZPOPMAX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, keys, timeout) {
      parser.push("BZPOPMAX");
      parser.pushKeys(keys);
      parser.push(timeout.toString());
    },
    transformReply: {
      2(reply, preserve, typeMapping) {
        return reply === null ? null : {
          key: reply[0],
          value: reply[1],
          score: generic_transformers_1.transformDoubleReply[2](reply[2], preserve, typeMapping)
        };
      },
      3(reply) {
        return reply === null ? null : {
          key: reply[0],
          value: reply[1],
          score: reply[2]
        };
      }
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/BZPOPMIN.js
var require_BZPOPMIN = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var BZPOPMAX_1 = __importDefault(require_BZPOPMAX());
  exports.default = {
    IS_READ_ONLY: BZPOPMAX_1.default.IS_READ_ONLY,
    parseCommand(parser, keys, timeout) {
      parser.push("BZPOPMIN");
      parser.pushKeys(keys);
      parser.push(timeout.toString());
    },
    transformReply: BZPOPMAX_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_CACHING.js
var require_CLIENT_CACHING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, value) {
      parser.push("CLIENT", "CACHING", value ? "YES" : "NO");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_GETNAME.js
var require_CLIENT_GETNAME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "GETNAME");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_GETREDIR.js
var require_CLIENT_GETREDIR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "GETREDIR");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_ID.js
var require_CLIENT_ID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "ID");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_INFO.js
var require_CLIENT_INFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CLIENT_INFO_REGEX = /([^\s=]+)=([^\s]*)/g;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "INFO");
    },
    transformReply(rawReply) {
      const map = {};
      for (const item of rawReply.toString().matchAll(CLIENT_INFO_REGEX)) {
        map[item[1]] = item[2];
      }
      const reply = {
        id: Number(map.id),
        addr: map.addr,
        fd: Number(map.fd),
        name: map.name,
        age: Number(map.age),
        idle: Number(map.idle),
        flags: map.flags,
        db: Number(map.db),
        sub: Number(map.sub),
        psub: Number(map.psub),
        multi: Number(map.multi),
        qbuf: Number(map.qbuf),
        qbufFree: Number(map["qbuf-free"]),
        argvMem: Number(map["argv-mem"]),
        obl: Number(map.obl),
        oll: Number(map.oll),
        omem: Number(map.omem),
        totMem: Number(map["tot-mem"]),
        events: map.events,
        cmd: map.cmd,
        user: map.user,
        libName: map["lib-name"],
        libVer: map["lib-ver"]
      };
      if (map.laddr !== undefined) {
        reply.laddr = map.laddr;
      }
      if (map.redir !== undefined) {
        reply.redir = Number(map.redir);
      }
      if (map.ssub !== undefined) {
        reply.ssub = Number(map.ssub);
      }
      if (map["multi-mem"] !== undefined) {
        reply.multiMem = Number(map["multi-mem"]);
      }
      if (map.resp !== undefined) {
        reply.resp = Number(map.resp);
      }
      return reply;
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_KILL.js
var require_CLIENT_KILL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CLIENT_KILL_FILTERS = undefined;
  exports.CLIENT_KILL_FILTERS = {
    ADDRESS: "ADDR",
    LOCAL_ADDRESS: "LADDR",
    ID: "ID",
    TYPE: "TYPE",
    USER: "USER",
    SKIP_ME: "SKIPME",
    MAXAGE: "MAXAGE"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, filters) {
      parser.push("CLIENT", "KILL");
      if (Array.isArray(filters)) {
        for (const filter2 of filters) {
          pushFilter(parser, filter2);
        }
      } else {
        pushFilter(parser, filters);
      }
    },
    transformReply: undefined
  };
  function pushFilter(parser, filter2) {
    if (filter2 === exports.CLIENT_KILL_FILTERS.SKIP_ME) {
      parser.push("SKIPME");
      return;
    }
    parser.push(filter2.filter);
    switch (filter2.filter) {
      case exports.CLIENT_KILL_FILTERS.ADDRESS:
        parser.push(filter2.address);
        break;
      case exports.CLIENT_KILL_FILTERS.LOCAL_ADDRESS:
        parser.push(filter2.localAddress);
        break;
      case exports.CLIENT_KILL_FILTERS.ID:
        parser.push(typeof filter2.id === "number" ? filter2.id.toString() : filter2.id);
        break;
      case exports.CLIENT_KILL_FILTERS.TYPE:
        parser.push(filter2.type);
        break;
      case exports.CLIENT_KILL_FILTERS.USER:
        parser.push(filter2.username);
        break;
      case exports.CLIENT_KILL_FILTERS.SKIP_ME:
        parser.push(filter2.skipMe ? "yes" : "no");
        break;
      case exports.CLIENT_KILL_FILTERS.MAXAGE:
        parser.push(filter2.maxAge.toString());
        break;
    }
  }
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_LIST.js
var require_CLIENT_LIST = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var CLIENT_INFO_1 = __importDefault(require_CLIENT_INFO());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, filter2) {
      parser.push("CLIENT", "LIST");
      if (filter2) {
        if (filter2.TYPE !== undefined) {
          parser.push("TYPE", filter2.TYPE);
        } else {
          parser.push("ID");
          parser.pushVariadic(filter2.ID);
        }
      }
    },
    transformReply(rawReply) {
      const split = rawReply.toString().split(`
`), length = split.length - 1, reply = [];
      for (let i = 0;i < length; i++) {
        reply.push(CLIENT_INFO_1.default.transformReply(split[i]));
      }
      return reply;
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_NO-EVICT.js
var require_CLIENT_NO_EVICT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, value) {
      parser.push("CLIENT", "NO-EVICT", value ? "ON" : "OFF");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_NO-TOUCH.js
var require_CLIENT_NO_TOUCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, value) {
      parser.push("CLIENT", "NO-TOUCH", value ? "ON" : "OFF");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_PAUSE.js
var require_CLIENT_PAUSE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, timeout, mode) {
      parser.push("CLIENT", "PAUSE", timeout.toString());
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_SETNAME.js
var require_CLIENT_SETNAME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, name) {
      parser.push("CLIENT", "SETNAME", name);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_TRACKING.js
var require_CLIENT_TRACKING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, mode, options) {
      parser.push("CLIENT", "TRACKING", mode ? "ON" : "OFF");
      if (mode) {
        if (options?.REDIRECT) {
          parser.push("REDIRECT", options.REDIRECT.toString());
        }
        if (isBroadcast(options)) {
          parser.push("BCAST");
          if (options?.PREFIX) {
            if (Array.isArray(options.PREFIX)) {
              for (const prefix of options.PREFIX) {
                parser.push("PREFIX", prefix);
              }
            } else {
              parser.push("PREFIX", options.PREFIX);
            }
          }
        } else if (isOptIn(options)) {
          parser.push("OPTIN");
        } else if (isOptOut(options)) {
          parser.push("OPTOUT");
        }
        if (options?.NOLOOP) {
          parser.push("NOLOOP");
        }
      }
    },
    transformReply: undefined
  };
  function isBroadcast(options) {
    return options?.BCAST === true;
  }
  function isOptIn(options) {
    return options?.OPTIN === true;
  }
  function isOptOut(options) {
    return options?.OPTOUT === true;
  }
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_TRACKINGINFO.js
var require_CLIENT_TRACKINGINFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "TRACKINGINFO");
    },
    transformReply: {
      2: (reply) => ({
        flags: reply[1],
        redirect: reply[3],
        prefixes: reply[5]
      }),
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLIENT_UNPAUSE.js
var require_CLIENT_UNPAUSE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "UNPAUSE");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_ADDSLOTS.js
var require_CLUSTER_ADDSLOTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slots) {
      parser.push("CLUSTER", "ADDSLOTS");
      parser.pushVariadicNumber(slots);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_ADDSLOTSRANGE.js
var require_CLUSTER_ADDSLOTSRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, ranges) {
      parser.push("CLUSTER", "ADDSLOTSRANGE");
      (0, generic_transformers_1.parseSlotRangesArguments)(parser, ranges);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_BUMPEPOCH.js
var require_CLUSTER_BUMPEPOCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "BUMPEPOCH");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_COUNT-FAILURE-REPORTS.js
var require_CLUSTER_COUNT_FAILURE_REPORTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, nodeId) {
      parser.push("CLUSTER", "COUNT-FAILURE-REPORTS", nodeId);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_COUNTKEYSINSLOT.js
var require_CLUSTER_COUNTKEYSINSLOT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slot) {
      parser.push("CLUSTER", "COUNTKEYSINSLOT", slot.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_DELSLOTS.js
var require_CLUSTER_DELSLOTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slots) {
      parser.push("CLUSTER", "DELSLOTS");
      parser.pushVariadicNumber(slots);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_DELSLOTSRANGE.js
var require_CLUSTER_DELSLOTSRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, ranges) {
      parser.push("CLUSTER", "DELSLOTSRANGE");
      (0, generic_transformers_1.parseSlotRangesArguments)(parser, ranges);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_FAILOVER.js
var require_CLUSTER_FAILOVER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FAILOVER_MODES = undefined;
  exports.FAILOVER_MODES = {
    FORCE: "FORCE",
    TAKEOVER: "TAKEOVER"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, options) {
      parser.push("CLUSTER", "FAILOVER");
      if (options?.mode) {
        parser.push(options.mode);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_FLUSHSLOTS.js
var require_CLUSTER_FLUSHSLOTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "FLUSHSLOTS");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_FORGET.js
var require_CLUSTER_FORGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, nodeId) {
      parser.push("CLUSTER", "FORGET", nodeId);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_GETKEYSINSLOT.js
var require_CLUSTER_GETKEYSINSLOT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slot, count) {
      parser.push("CLUSTER", "GETKEYSINSLOT", slot.toString(), count.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_INFO.js
var require_CLUSTER_INFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "INFO");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_KEYSLOT.js
var require_CLUSTER_KEYSLOT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("CLUSTER", "KEYSLOT", key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_LINKS.js
var require_CLUSTER_LINKS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "LINKS");
    },
    transformReply: {
      2: (reply) => reply.map((link) => {
        const unwrapped = link;
        return {
          direction: unwrapped[1],
          node: unwrapped[3],
          "create-time": unwrapped[5],
          events: unwrapped[7],
          "send-buffer-allocated": unwrapped[9],
          "send-buffer-used": unwrapped[11]
        };
      }),
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_MEET.js
var require_CLUSTER_MEET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, host, port) {
      parser.push("CLUSTER", "MEET", host, port.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_MYID.js
var require_CLUSTER_MYID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "MYID");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_MYSHARDID.js
var require_CLUSTER_MYSHARDID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "MYSHARDID");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_NODES.js
var require_CLUSTER_NODES = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "NODES");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_REPLICAS.js
var require_CLUSTER_REPLICAS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, nodeId) {
      parser.push("CLUSTER", "REPLICAS", nodeId);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_REPLICATE.js
var require_CLUSTER_REPLICATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, nodeId) {
      parser.push("CLUSTER", "REPLICATE", nodeId);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_RESET.js
var require_CLUSTER_RESET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, options) {
      parser.push("CLUSTER", "RESET");
      if (options?.mode) {
        parser.push(options.mode);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_SAVECONFIG.js
var require_CLUSTER_SAVECONFIG = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "SAVECONFIG");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_SET-CONFIG-EPOCH.js
var require_CLUSTER_SET_CONFIG_EPOCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, configEpoch) {
      parser.push("CLUSTER", "SET-CONFIG-EPOCH", configEpoch.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_SETSLOT.js
var require_CLUSTER_SETSLOT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CLUSTER_SLOT_STATES = undefined;
  exports.CLUSTER_SLOT_STATES = {
    IMPORTING: "IMPORTING",
    MIGRATING: "MIGRATING",
    STABLE: "STABLE",
    NODE: "NODE"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slot, state, nodeId) {
      parser.push("CLUSTER", "SETSLOT", slot.toString(), state);
      if (nodeId) {
        parser.push(nodeId);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CLUSTER_SLOTS.js
var require_CLUSTER_SLOTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "SLOTS");
    },
    transformReply(reply) {
      return reply.map(([from, to, master, ...replicas]) => ({
        from,
        to,
        master: transformNode(master),
        replicas: replicas.map(transformNode)
      }));
    }
  };
  function transformNode(node) {
    const [host, port, id] = node;
    return {
      host,
      port,
      id
    };
  }
});

// ../../node_modules/@redis/client/dist/lib/commands/COMMAND_COUNT.js
var require_COMMAND_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("COMMAND", "COUNT");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/COMMAND_GETKEYS.js
var require_COMMAND_GETKEYS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, args) {
      parser.push("COMMAND", "GETKEYS");
      parser.push(...args);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/COMMAND_GETKEYSANDFLAGS.js
var require_COMMAND_GETKEYSANDFLAGS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, args) {
      parser.push("COMMAND", "GETKEYSANDFLAGS");
      parser.push(...args);
    },
    transformReply(reply) {
      return reply.map((entry) => {
        const [key, flags] = entry;
        return {
          key,
          flags
        };
      });
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/COMMAND_INFO.js
var require_COMMAND_INFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, commands) {
      parser.push("COMMAND", "INFO", ...commands);
    },
    transformReply(reply) {
      return reply.map((command) => command ? (0, generic_transformers_1.transformCommandReply)(command) : null);
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/COMMAND_LIST.js
var require_COMMAND_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.COMMAND_LIST_FILTER_BY = undefined;
  exports.COMMAND_LIST_FILTER_BY = {
    MODULE: "MODULE",
    ACLCAT: "ACLCAT",
    PATTERN: "PATTERN"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, options) {
      parser.push("COMMAND", "LIST");
      if (options?.FILTERBY) {
        parser.push("FILTERBY", options.FILTERBY.type, options.FILTERBY.value);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/COMMAND.js
var require_COMMAND = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("COMMAND");
    },
    transformReply(reply) {
      return reply.map(generic_transformers_1.transformCommandReply);
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CONFIG_GET.js
var require_CONFIG_GET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, parameters) {
      parser.push("CONFIG", "GET");
      parser.pushVariadic(parameters);
    },
    transformReply: {
      2: generic_transformers_1.transformTuplesReply,
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CONFIG_RESETSTAT.js
var require_CONFIG_RESETSTAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CONFIG", "RESETSTAT");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CONFIG_REWRITE.js
var require_CONFIG_REWRITE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CONFIG", "REWRITE");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/CONFIG_SET.js
var require_CONFIG_SET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, ...[parameterOrConfig, value]) {
      parser.push("CONFIG", "SET");
      if (typeof parameterOrConfig === "string" || parameterOrConfig instanceof Buffer) {
        parser.push(parameterOrConfig, value);
      } else {
        for (const [key, value2] of Object.entries(parameterOrConfig)) {
          parser.push(key, value2);
        }
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/COPY.js
var require_COPY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, options) {
      parser.push("COPY");
      parser.pushKeys([source, destination]);
      if (options?.DB) {
        parser.push("DB", options.DB.toString());
      }
      if (options?.REPLACE) {
        parser.push("REPLACE");
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/DBSIZE.js
var require_DBSIZE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("DBSIZE");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/DECR.js
var require_DECR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("DECR");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/DECRBY.js
var require_DECRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, decrement) {
      parser.push("DECRBY");
      parser.pushKey(key);
      parser.push(decrement.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/DEL.js
var require_DEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, keys) {
      parser.push("DEL");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/DUMP.js
var require_DUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("DUMP");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ECHO.js
var require_ECHO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, message) {
      parser.push("ECHO", message);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/EVAL.js
var require_EVAL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseEvalArguments = undefined;
  function parseEvalArguments(parser, script, options) {
    parser.push(script);
    if (options?.keys) {
      parser.pushKeysLength(options.keys);
    } else {
      parser.push("0");
    }
    if (options?.arguments) {
      parser.push(...options.arguments);
    }
  }
  exports.parseEvalArguments = parseEvalArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("EVAL");
      parseEvalArguments(...args);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/EVAL_RO.js
var require_EVAL_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("EVAL_RO");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/EVALSHA_RO.js
var require_EVALSHA_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("EVALSHA_RO");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/EVALSHA.js
var require_EVALSHA = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("EVALSHA");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEOADD.js
var require_GEOADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, toAdd, options) {
      parser.push("GEOADD");
      parser.pushKey(key);
      if (options?.condition) {
        parser.push(options.condition);
      } else if (options?.NX) {
        parser.push("NX");
      } else if (options?.XX) {
        parser.push("XX");
      }
      if (options?.CH) {
        parser.push("CH");
      }
      if (Array.isArray(toAdd)) {
        for (const member of toAdd) {
          pushMember(parser, member);
        }
      } else {
        pushMember(parser, toAdd);
      }
    },
    transformReply: undefined
  };
  function pushMember(parser, { longitude, latitude, member }) {
    parser.push(longitude.toString(), latitude.toString(), member);
  }
});

// ../../node_modules/@redis/client/dist/lib/commands/GEODIST.js
var require_GEODIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member1, member2, unit) {
      parser.push("GEODIST");
      parser.pushKey(key);
      parser.push(member1, member2);
      if (unit) {
        parser.push(unit);
      }
    },
    transformReply(reply) {
      return reply === null ? null : Number(reply);
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEOHASH.js
var require_GEOHASH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("GEOHASH");
      parser.pushKey(key);
      parser.pushVariadic(member);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEOPOS.js
var require_GEOPOS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("GEOPOS");
      parser.pushKey(key);
      parser.pushVariadic(member);
    },
    transformReply(reply) {
      return reply.map((item) => {
        const unwrapped = item;
        return unwrapped === null ? null : {
          longitude: unwrapped[0],
          latitude: unwrapped[1]
        };
      });
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEOSEARCH.js
var require_GEOSEARCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoSearchOptions = exports.parseGeoSearchArguments = undefined;
  function parseGeoSearchArguments(parser, key, from, by, options) {
    parser.pushKey(key);
    if (typeof from === "string" || from instanceof Buffer) {
      parser.push("FROMMEMBER", from);
    } else {
      parser.push("FROMLONLAT", from.longitude.toString(), from.latitude.toString());
    }
    if ("radius" in by) {
      parser.push("BYRADIUS", by.radius.toString(), by.unit);
    } else {
      parser.push("BYBOX", by.width.toString(), by.height.toString(), by.unit);
    }
    parseGeoSearchOptions(parser, options);
  }
  exports.parseGeoSearchArguments = parseGeoSearchArguments;
  function parseGeoSearchOptions(parser, options) {
    if (options?.SORT) {
      parser.push(options.SORT);
    }
    if (options?.COUNT) {
      if (typeof options.COUNT === "number") {
        parser.push("COUNT", options.COUNT.toString());
      } else {
        parser.push("COUNT", options.COUNT.value.toString());
        if (options.COUNT.ANY) {
          parser.push("ANY");
        }
      }
    }
  }
  exports.parseGeoSearchOptions = parseGeoSearchOptions;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, from, by, options) {
      parser.push("GEOSEARCH");
      parseGeoSearchArguments(parser, key, from, by, options);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEORADIUS.js
var require_GEORADIUS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoRadiusArguments = undefined;
  var GEOSEARCH_1 = require_GEOSEARCH();
  function parseGeoRadiusArguments(parser, key, from, radius, unit, options) {
    parser.pushKey(key);
    parser.push(from.longitude.toString(), from.latitude.toString(), radius.toString(), unit);
    (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options);
  }
  exports.parseGeoRadiusArguments = parseGeoRadiusArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("GEORADIUS");
      return parseGeoRadiusArguments(...args);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEOSEARCH_WITH.js
var require_GEOSEARCH_WITH = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GEO_REPLY_WITH = undefined;
  var GEOSEARCH_1 = __importDefault(require_GEOSEARCH());
  exports.GEO_REPLY_WITH = {
    DISTANCE: "WITHDIST",
    HASH: "WITHHASH",
    COORDINATES: "WITHCOORD"
  };
  exports.default = {
    IS_READ_ONLY: GEOSEARCH_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, by, replyWith, options) {
      GEOSEARCH_1.default.parseCommand(parser, key, from, by, options);
      parser.push(...replyWith);
      parser.preserve = replyWith;
    },
    transformReply(reply, replyWith) {
      const replyWithSet = new Set(replyWith);
      let index = 0;
      const distanceIndex = replyWithSet.has(exports.GEO_REPLY_WITH.DISTANCE) && ++index, hashIndex = replyWithSet.has(exports.GEO_REPLY_WITH.HASH) && ++index, coordinatesIndex = replyWithSet.has(exports.GEO_REPLY_WITH.COORDINATES) && ++index;
      return reply.map((raw2) => {
        const unwrapped = raw2;
        const item = {
          member: unwrapped[0]
        };
        if (distanceIndex) {
          item.distance = unwrapped[distanceIndex];
        }
        if (hashIndex) {
          item.hash = unwrapped[hashIndex];
        }
        if (coordinatesIndex) {
          const [longitude, latitude] = unwrapped[coordinatesIndex];
          item.coordinates = {
            longitude,
            latitude
          };
        }
        return item;
      });
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEORADIUS_WITH.js
var require_GEORADIUS_WITH = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoRadiusWithArguments = undefined;
  var GEORADIUS_1 = __importStar(require_GEORADIUS());
  var GEOSEARCH_WITH_1 = __importDefault(require_GEOSEARCH_WITH());
  function parseGeoRadiusWithArguments(parser, key, from, radius, unit, replyWith, options) {
    (0, GEORADIUS_1.parseGeoRadiusArguments)(parser, key, from, radius, unit, options);
    parser.pushVariadic(replyWith);
    parser.preserve = replyWith;
  }
  exports.parseGeoRadiusWithArguments = parseGeoRadiusWithArguments;
  exports.default = {
    IS_READ_ONLY: GEORADIUS_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, radius, unit, replyWith, options) {
      parser.push("GEORADIUS");
      parseGeoRadiusWithArguments(parser, key, from, radius, unit, replyWith, options);
    },
    transformReply: GEOSEARCH_WITH_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEORADIUS_RO_WITH.js
var require_GEORADIUS_RO_WITH = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUS_WITH_1 = require_GEORADIUS_WITH();
  var GEORADIUS_WITH_2 = __importDefault(require_GEORADIUS_WITH());
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("GEORADIUS_RO");
      (0, GEORADIUS_WITH_1.parseGeoRadiusWithArguments)(...args);
    },
    transformReply: GEORADIUS_WITH_2.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEORADIUS_RO.js
var require_GEORADIUS_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUS_1 = __importStar(require_GEORADIUS());
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("GEORADIUS_RO");
      (0, GEORADIUS_1.parseGeoRadiusArguments)(...args);
    },
    transformReply: GEORADIUS_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEORADIUS_STORE.js
var require_GEORADIUS_STORE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUS_1 = __importStar(require_GEORADIUS());
  exports.default = {
    IS_READ_ONLY: GEORADIUS_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, radius, unit, destination, options) {
      parser.push("GEORADIUS");
      (0, GEORADIUS_1.parseGeoRadiusArguments)(parser, key, from, radius, unit, options);
      if (options?.STOREDIST) {
        parser.push("STOREDIST");
        parser.pushKey(destination);
      } else {
        parser.push("STORE");
        parser.pushKey(destination);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER.js
var require_GEORADIUSBYMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoRadiusByMemberArguments = undefined;
  var GEOSEARCH_1 = require_GEOSEARCH();
  function parseGeoRadiusByMemberArguments(parser, key, from, radius, unit, options) {
    parser.pushKey(key);
    parser.push(from, radius.toString(), unit);
    (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options);
  }
  exports.parseGeoRadiusByMemberArguments = parseGeoRadiusByMemberArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, from, radius, unit, options) {
      parser.push("GEORADIUSBYMEMBER");
      parseGeoRadiusByMemberArguments(parser, key, from, radius, unit, options);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_WITH.js
var require_GEORADIUSBYMEMBER_WITH = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoRadiusByMemberWithArguments = undefined;
  var GEORADIUSBYMEMBER_1 = __importDefault(require_GEORADIUSBYMEMBER());
  var GEOSEARCH_1 = require_GEOSEARCH();
  var GEOSEARCH_WITH_1 = __importDefault(require_GEOSEARCH_WITH());
  function parseGeoRadiusByMemberWithArguments(parser, key, from, radius, unit, replyWith, options) {
    parser.pushKey(key);
    parser.push(from, radius.toString(), unit);
    (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options);
    parser.push(...replyWith);
    parser.preserve = replyWith;
  }
  exports.parseGeoRadiusByMemberWithArguments = parseGeoRadiusByMemberWithArguments;
  exports.default = {
    IS_READ_ONLY: GEORADIUSBYMEMBER_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, radius, unit, replyWith, options) {
      parser.push("GEORADIUSBYMEMBER");
      parseGeoRadiusByMemberWithArguments(parser, key, from, radius, unit, replyWith, options);
    },
    transformReply: GEOSEARCH_WITH_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_RO_WITH.js
var require_GEORADIUSBYMEMBER_RO_WITH = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUSBYMEMBER_WITH_1 = __importStar(require_GEORADIUSBYMEMBER_WITH());
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("GEORADIUSBYMEMBER_RO");
      (0, GEORADIUSBYMEMBER_WITH_1.parseGeoRadiusByMemberWithArguments)(...args);
    },
    transformReply: GEORADIUSBYMEMBER_WITH_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_RO.js
var require_GEORADIUSBYMEMBER_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUSBYMEMBER_1 = __importStar(require_GEORADIUSBYMEMBER());
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("GEORADIUSBYMEMBER_RO");
      (0, GEORADIUSBYMEMBER_1.parseGeoRadiusByMemberArguments)(...args);
    },
    transformReply: GEORADIUSBYMEMBER_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_STORE.js
var require_GEORADIUSBYMEMBER_STORE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUSBYMEMBER_1 = __importStar(require_GEORADIUSBYMEMBER());
  exports.default = {
    IS_READ_ONLY: GEORADIUSBYMEMBER_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, radius, unit, destination, options) {
      parser.push("GEORADIUSBYMEMBER");
      (0, GEORADIUSBYMEMBER_1.parseGeoRadiusByMemberArguments)(parser, key, from, radius, unit, options);
      if (options?.STOREDIST) {
        parser.push("STOREDIST");
        parser.pushKey(destination);
      } else {
        parser.push("STORE");
        parser.pushKey(destination);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GEOSEARCHSTORE.js
var require_GEOSEARCHSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEOSEARCH_1 = require_GEOSEARCH();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, source, from, by, options) {
      parser.push("GEOSEARCHSTORE");
      if (destination !== undefined) {
        parser.pushKey(destination);
      }
      (0, GEOSEARCH_1.parseGeoSearchArguments)(parser, source, from, by, options);
      if (options?.STOREDIST) {
        parser.push("STOREDIST");
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GET.js
var require_GET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("GET");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GETBIT.js
var require_GETBIT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, offset) {
      parser.push("GETBIT");
      parser.pushKey(key);
      parser.push(offset.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GETDEL.js
var require_GETDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("GETDEL");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GETEX.js
var require_GETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("GETEX");
      parser.pushKey(key);
      if ("type" in options) {
        switch (options.type) {
          case "EX":
          case "PX":
            parser.push(options.type, options.value.toString());
            break;
          case "EXAT":
          case "PXAT":
            parser.push(options.type, (0, generic_transformers_1.transformEXAT)(options.value));
            break;
          case "PERSIST":
            parser.push("PERSIST");
            break;
        }
      } else {
        if ("EX" in options) {
          parser.push("EX", options.EX.toString());
        } else if ("PX" in options) {
          parser.push("PX", options.PX.toString());
        } else if ("EXAT" in options) {
          parser.push("EXAT", (0, generic_transformers_1.transformEXAT)(options.EXAT));
        } else if ("PXAT" in options) {
          parser.push("PXAT", (0, generic_transformers_1.transformPXAT)(options.PXAT));
        } else {
          parser.push("PERSIST");
        }
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GETRANGE.js
var require_GETRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, start, end) {
      parser.push("GETRANGE");
      parser.pushKey(key);
      parser.push(start.toString(), end.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/GETSET.js
var require_GETSET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, value) {
      parser.push("GETSET");
      parser.pushKey(key);
      parser.push(value);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/EXISTS.js
var require_EXISTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("EXISTS");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/EXPIRE.js
var require_EXPIRE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, seconds, mode) {
      parser.push("EXPIRE");
      parser.pushKey(key);
      parser.push(seconds.toString());
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/EXPIREAT.js
var require_EXPIREAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, timestamp, mode) {
      parser.push("EXPIREAT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformEXAT)(timestamp));
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/EXPIRETIME.js
var require_EXPIRETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("EXPIRETIME");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/FLUSHALL.js
var require_FLUSHALL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.REDIS_FLUSH_MODES = undefined;
  exports.REDIS_FLUSH_MODES = {
    ASYNC: "ASYNC",
    SYNC: "SYNC"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, mode) {
      parser.push("FLUSHALL");
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/FLUSHDB.js
var require_FLUSHDB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, mode) {
      parser.push("FLUSHDB");
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/FCALL.js
var require_FCALL = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("FCALL");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/FCALL_RO.js
var require_FCALL_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("FCALL_RO");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/FUNCTION_DELETE.js
var require_FUNCTION_DELETE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, library) {
      parser.push("FUNCTION", "DELETE", library);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/FUNCTION_DUMP.js
var require_FUNCTION_DUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("FUNCTION", "DUMP");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/FUNCTION_FLUSH.js
var require_FUNCTION_FLUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, mode) {
      parser.push("FUNCTION", "FLUSH");
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/FUNCTION_KILL.js
var require_FUNCTION_KILL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("FUNCTION", "KILL");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/FUNCTION_LIST.js
var require_FUNCTION_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, options) {
      parser.push("FUNCTION", "LIST");
      if (options?.LIBRARYNAME) {
        parser.push("LIBRARYNAME", options.LIBRARYNAME);
      }
    },
    transformReply: {
      2: (reply) => {
        return reply.map((library) => {
          const unwrapped = library;
          return {
            library_name: unwrapped[1],
            engine: unwrapped[3],
            functions: unwrapped[5].map((fn) => {
              const unwrapped2 = fn;
              return {
                name: unwrapped2[1],
                description: unwrapped2[3],
                flags: unwrapped2[5]
              };
            })
          };
        });
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/FUNCTION_LIST_WITHCODE.js
var require_FUNCTION_LIST_WITHCODE = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var FUNCTION_LIST_1 = __importDefault(require_FUNCTION_LIST());
  exports.default = {
    NOT_KEYED_COMMAND: FUNCTION_LIST_1.default.NOT_KEYED_COMMAND,
    IS_READ_ONLY: FUNCTION_LIST_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      FUNCTION_LIST_1.default.parseCommand(...args);
      args[0].push("WITHCODE");
    },
    transformReply: {
      2: (reply) => {
        return reply.map((library) => {
          const unwrapped = library;
          return {
            library_name: unwrapped[1],
            engine: unwrapped[3],
            functions: unwrapped[5].map((fn) => {
              const unwrapped2 = fn;
              return {
                name: unwrapped2[1],
                description: unwrapped2[3],
                flags: unwrapped2[5]
              };
            }),
            library_code: unwrapped[7]
          };
        });
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/FUNCTION_LOAD.js
var require_FUNCTION_LOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, code, options) {
      parser.push("FUNCTION", "LOAD");
      if (options?.REPLACE) {
        parser.push("REPLACE");
      }
      parser.push(code);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/FUNCTION_RESTORE.js
var require_FUNCTION_RESTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, dump, options) {
      parser.push("FUNCTION", "RESTORE", dump);
      if (options?.mode) {
        parser.push(options.mode);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/FUNCTION_STATS.js
var require_FUNCTION_STATS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("FUNCTION", "STATS");
    },
    transformReply: {
      2: (reply) => {
        return {
          running_script: transformRunningScript(reply[1]),
          engines: transformEngines(reply[3])
        };
      },
      3: undefined
    }
  };
  function transformRunningScript(reply) {
    if ((0, generic_transformers_1.isNullReply)(reply)) {
      return null;
    }
    const unwraped = reply;
    return {
      name: unwraped[1],
      command: unwraped[3],
      duration_ms: unwraped[5]
    };
  }
  function transformEngines(reply) {
    const unwraped = reply;
    const engines = Object.create(null);
    for (let i = 0;i < unwraped.length; i++) {
      const name = unwraped[i], stats = unwraped[++i], unwrapedStats = stats;
      engines[name.toString()] = {
        libraries_count: unwrapedStats[1],
        functions_count: unwrapedStats[3]
      };
    }
    return engines;
  }
});

// ../../node_modules/@redis/client/dist/lib/commands/HDEL.js
var require_HDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, field) {
      parser.push("HDEL");
      parser.pushKey(key);
      parser.pushVariadic(field);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HELLO.js
var require_HELLO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, protover, options) {
      parser.push("HELLO");
      if (protover) {
        parser.push(protover.toString());
        if (options?.AUTH) {
          parser.push("AUTH", options.AUTH.username, options.AUTH.password);
        }
        if (options?.SETNAME) {
          parser.push("SETNAME", options.SETNAME);
        }
      }
    },
    transformReply: {
      2: (reply) => ({
        server: reply[1],
        version: reply[3],
        proto: reply[5],
        id: reply[7],
        mode: reply[9],
        role: reply[11],
        modules: reply[13]
      }),
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HEXISTS.js
var require_HEXISTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, field) {
      parser.push("HEXISTS");
      parser.pushKey(key);
      parser.push(field);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HEXPIRE.js
var require_HEXPIRE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HASH_EXPIRATION = undefined;
  exports.HASH_EXPIRATION = {
    FIELD_NOT_EXISTS: -2,
    CONDITION_NOT_MET: 0,
    UPDATED: 1,
    DELETED: 2
  };
  exports.default = {
    parseCommand(parser, key, fields, seconds, mode) {
      parser.push("HEXPIRE");
      parser.pushKey(key);
      parser.push(seconds.toString());
      if (mode) {
        parser.push(mode);
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HEXPIREAT.js
var require_HEXPIREAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, fields, timestamp, mode) {
      parser.push("HEXPIREAT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformEXAT)(timestamp));
      if (mode) {
        parser.push(mode);
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HEXPIRETIME.js
var require_HEXPIRETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HASH_EXPIRATION_TIME = undefined;
  exports.HASH_EXPIRATION_TIME = {
    FIELD_NOT_EXISTS: -2,
    NO_EXPIRATION: -1
  };
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HEXPIRETIME");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HGET.js
var require_HGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, field) {
      parser.push("HGET");
      parser.pushKey(key);
      parser.push(field);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HGETALL.js
var require_HGETALL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HGETALL");
      parser.pushKey(key);
    },
    TRANSFORM_LEGACY_REPLY: true,
    transformReply: {
      2: generic_transformers_1.transformTuplesReply,
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HGETDEL.js
var require_HGETDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, fields) {
      parser.push("HGETDEL");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HGETEX.js
var require_HGETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, fields, options) {
      parser.push("HGETEX");
      parser.pushKey(key);
      if (options?.expiration) {
        if (typeof options.expiration === "string") {
          parser.push(options.expiration);
        } else if (options.expiration.type === "PERSIST") {
          parser.push("PERSIST");
        } else {
          parser.push(options.expiration.type, options.expiration.value.toString());
        }
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HINCRBY.js
var require_HINCRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, field, increment) {
      parser.push("HINCRBY");
      parser.pushKey(key);
      parser.push(field, increment.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HINCRBYFLOAT.js
var require_HINCRBYFLOAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, field, increment) {
      parser.push("HINCRBYFLOAT");
      parser.pushKey(key);
      parser.push(field, increment.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HKEYS.js
var require_HKEYS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HKEYS");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HLEN.js
var require_HLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HLEN");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HMGET.js
var require_HMGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HMGET");
      parser.pushKey(key);
      parser.pushVariadic(fields);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HPERSIST.js
var require_HPERSIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, fields) {
      parser.push("HPERSIST");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HPEXPIRE.js
var require_HPEXPIRE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, fields, ms, mode) {
      parser.push("HPEXPIRE");
      parser.pushKey(key);
      parser.push(ms.toString());
      if (mode) {
        parser.push(mode);
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HPEXPIREAT.js
var require_HPEXPIREAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields, timestamp, mode) {
      parser.push("HPEXPIREAT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformPXAT)(timestamp));
      if (mode) {
        parser.push(mode);
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HPEXPIRETIME.js
var require_HPEXPIRETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HPEXPIRETIME");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HPTTL.js
var require_HPTTL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HPTTL");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HRANDFIELD_COUNT_WITHVALUES.js
var require_HRANDFIELD_COUNT_WITHVALUES = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, count) {
      parser.push("HRANDFIELD");
      parser.pushKey(key);
      parser.push(count.toString(), "WITHVALUES");
    },
    transformReply: {
      2: (rawReply) => {
        const reply = [];
        let i = 0;
        while (i < rawReply.length) {
          reply.push({
            field: rawReply[i++],
            value: rawReply[i++]
          });
        }
        return reply;
      },
      3: (reply) => {
        return reply.map((entry) => {
          const [field, value] = entry;
          return {
            field,
            value
          };
        });
      }
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HRANDFIELD_COUNT.js
var require_HRANDFIELD_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, count) {
      parser.push("HRANDFIELD");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HRANDFIELD.js
var require_HRANDFIELD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HRANDFIELD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SCAN.js
var require_SCAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushScanArguments = exports.parseScanArguments = undefined;
  function parseScanArguments(parser, cursor, options) {
    parser.push(cursor);
    if (options?.MATCH) {
      parser.push("MATCH", options.MATCH);
    }
    if (options?.COUNT) {
      parser.push("COUNT", options.COUNT.toString());
    }
  }
  exports.parseScanArguments = parseScanArguments;
  function pushScanArguments(args, cursor, options) {
    args.push(cursor.toString());
    if (options?.MATCH) {
      args.push("MATCH", options.MATCH);
    }
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  }
  exports.pushScanArguments = pushScanArguments;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, cursor, options) {
      parser.push("SCAN");
      parseScanArguments(parser, cursor, options);
      if (options?.TYPE) {
        parser.push("TYPE", options.TYPE);
      }
    },
    transformReply([cursor, keys]) {
      return {
        cursor,
        keys
      };
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HSCAN.js
var require_HSCAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SCAN_1 = require_SCAN();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, cursor, options) {
      parser.push("HSCAN");
      parser.pushKey(key);
      (0, SCAN_1.parseScanArguments)(parser, cursor, options);
    },
    transformReply([cursor, rawEntries]) {
      const entries = [];
      let i = 0;
      while (i < rawEntries.length) {
        entries.push({
          field: rawEntries[i++],
          value: rawEntries[i++]
        });
      }
      return {
        cursor,
        entries
      };
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HSCAN_NOVALUES.js
var require_HSCAN_NOVALUES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var HSCAN_1 = __importDefault(require_HSCAN());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      HSCAN_1.default.parseCommand(...args);
      parser.push("NOVALUES");
    },
    transformReply([cursor, fields]) {
      return {
        cursor,
        fields
      };
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HSET.js
var require_HSET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, ...[key, value, fieldValue]) {
      parser.push("HSET");
      parser.pushKey(key);
      if (typeof value === "string" || typeof value === "number" || value instanceof Buffer) {
        parser.push(convertValue(value), convertValue(fieldValue));
      } else if (value instanceof Map) {
        pushMap(parser, value);
      } else if (Array.isArray(value)) {
        pushTuples(parser, value);
      } else {
        pushObject(parser, value);
      }
    },
    transformReply: undefined
  };
  function pushMap(parser, map) {
    for (const [key, value] of map.entries()) {
      parser.push(convertValue(key), convertValue(value));
    }
  }
  function pushTuples(parser, tuples) {
    for (const tuple of tuples) {
      if (Array.isArray(tuple)) {
        pushTuples(parser, tuple);
        continue;
      }
      parser.push(convertValue(tuple));
    }
  }
  function pushObject(parser, object) {
    for (const key of Object.keys(object)) {
      parser.push(convertValue(key), convertValue(object[key]));
    }
  }
  function convertValue(value) {
    return typeof value === "number" ? value.toString() : value;
  }
});

// ../../node_modules/@redis/client/dist/lib/commands/HSETEX.js
var require_HSETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var parser_1 = require_parser();
  exports.default = {
    parseCommand(parser, key, fields, options) {
      parser.push("HSETEX");
      parser.pushKey(key);
      if (options?.mode) {
        parser.push(options.mode);
      }
      if (options?.expiration) {
        if (typeof options.expiration === "string") {
          parser.push(options.expiration);
        } else if (options.expiration.type === "KEEPTTL") {
          parser.push("KEEPTTL");
        } else {
          parser.push(options.expiration.type, options.expiration.value.toString());
        }
      }
      parser.push("FIELDS");
      if (fields instanceof Map) {
        pushMap(parser, fields);
      } else if (Array.isArray(fields)) {
        pushTuples(parser, fields);
      } else {
        pushObject(parser, fields);
      }
    },
    transformReply: undefined
  };
  function pushMap(parser, map) {
    parser.push(map.size.toString());
    for (const [key, value] of map.entries()) {
      parser.push(convertValue(key), convertValue(value));
    }
  }
  function pushTuples(parser, tuples) {
    const tmpParser = new parser_1.BasicCommandParser;
    _pushTuples(tmpParser, tuples);
    if (tmpParser.redisArgs.length % 2 != 0) {
      throw Error("invalid number of arguments, expected key value ....[key value] pairs, got key without value");
    }
    parser.push((tmpParser.redisArgs.length / 2).toString());
    parser.push(...tmpParser.redisArgs);
  }
  function _pushTuples(parser, tuples) {
    for (const tuple of tuples) {
      if (Array.isArray(tuple)) {
        _pushTuples(parser, tuple);
        continue;
      }
      parser.push(convertValue(tuple));
    }
  }
  function pushObject(parser, object) {
    const len = Object.keys(object).length;
    if (len == 0) {
      throw Error("object without keys");
    }
    parser.push(len.toString());
    for (const key of Object.keys(object)) {
      parser.push(convertValue(key), convertValue(object[key]));
    }
  }
  function convertValue(value) {
    return typeof value === "number" ? value.toString() : value;
  }
});

// ../../node_modules/@redis/client/dist/lib/commands/HSETNX.js
var require_HSETNX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, field, value) {
      parser.push("HSETNX");
      parser.pushKey(key);
      parser.push(field, value);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HSTRLEN.js
var require_HSTRLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, field) {
      parser.push("HSTRLEN");
      parser.pushKey(key);
      parser.push(field);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HTTL.js
var require_HTTL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HTTL");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/HVALS.js
var require_HVALS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HVALS");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/INCR.js
var require_INCR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("INCR");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/INCRBY.js
var require_INCRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, increment) {
      parser.push("INCRBY");
      parser.pushKey(key);
      parser.push(increment.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/INCRBYFLOAT.js
var require_INCRBYFLOAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, increment) {
      parser.push("INCRBYFLOAT");
      parser.pushKey(key);
      parser.push(increment.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/INFO.js
var require_INFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, section) {
      parser.push("INFO");
      if (section) {
        parser.push(section);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/KEYS.js
var require_KEYS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, pattern) {
      parser.push("KEYS", pattern);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LASTSAVE.js
var require_LASTSAVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("LASTSAVE");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LATENCY_DOCTOR.js
var require_LATENCY_DOCTOR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("LATENCY", "DOCTOR");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LATENCY_GRAPH.js
var require_LATENCY_GRAPH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LATENCY_EVENTS = undefined;
  exports.LATENCY_EVENTS = {
    ACTIVE_DEFRAG_CYCLE: "active-defrag-cycle",
    AOF_FSYNC_ALWAYS: "aof-fsync-always",
    AOF_STAT: "aof-stat",
    AOF_REWRITE_DIFF_WRITE: "aof-rewrite-diff-write",
    AOF_RENAME: "aof-rename",
    AOF_WRITE: "aof-write",
    AOF_WRITE_ACTIVE_CHILD: "aof-write-active-child",
    AOF_WRITE_ALONE: "aof-write-alone",
    AOF_WRITE_PENDING_FSYNC: "aof-write-pending-fsync",
    COMMAND: "command",
    EXPIRE_CYCLE: "expire-cycle",
    EVICTION_CYCLE: "eviction-cycle",
    EVICTION_DEL: "eviction-del",
    FAST_COMMAND: "fast-command",
    FORK: "fork",
    RDB_UNLINK_TEMP_FILE: "rdb-unlink-temp-file"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, event) {
      parser.push("LATENCY", "GRAPH", event);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LATENCY_HISTORY.js
var require_LATENCY_HISTORY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, event) {
      parser.push("LATENCY", "HISTORY", event);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LATENCY_LATEST.js
var require_LATENCY_LATEST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("LATENCY", "LATEST");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LCS.js
var require_LCS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key1, key2) {
      parser.push("LCS");
      parser.pushKeys([key1, key2]);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LCS_IDX.js
var require_LCS_IDX = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LCS_1 = __importDefault(require_LCS());
  exports.default = {
    IS_READ_ONLY: LCS_1.default.IS_READ_ONLY,
    parseCommand(parser, key1, key2, options) {
      LCS_1.default.parseCommand(parser, key1, key2);
      parser.push("IDX");
      if (options?.MINMATCHLEN) {
        parser.push("MINMATCHLEN", options.MINMATCHLEN.toString());
      }
    },
    transformReply: {
      2: (reply) => ({
        matches: reply[1],
        len: reply[3]
      }),
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LCS_IDX_WITHMATCHLEN.js
var require_LCS_IDX_WITHMATCHLEN = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LCS_IDX_1 = __importDefault(require_LCS_IDX());
  exports.default = {
    IS_READ_ONLY: LCS_IDX_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      LCS_IDX_1.default.parseCommand(...args);
      parser.push("WITHMATCHLEN");
    },
    transformReply: {
      2: (reply) => ({
        matches: reply[1],
        len: reply[3]
      }),
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LCS_LEN.js
var require_LCS_LEN = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LCS_1 = __importDefault(require_LCS());
  exports.default = {
    IS_READ_ONLY: LCS_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      LCS_1.default.parseCommand(...args);
      parser.push("LEN");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LINDEX.js
var require_LINDEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, index) {
      parser.push("LINDEX");
      parser.pushKey(key);
      parser.push(index.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LINSERT.js
var require_LINSERT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, position, pivot, element) {
      parser.push("LINSERT");
      parser.pushKey(key);
      parser.push(position, pivot, element);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LLEN.js
var require_LLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("LLEN");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LMOVE.js
var require_LMOVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, sourceSide, destinationSide) {
      parser.push("LMOVE");
      parser.pushKeys([source, destination]);
      parser.push(sourceSide, destinationSide);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LOLWUT.js
var require_LOLWUT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, version, ...optionalArguments) {
      parser.push("LOLWUT");
      if (version) {
        parser.push("VERSION", version.toString());
        parser.pushVariadic(optionalArguments.map(String));
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LPOP.js
var require_LPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("LPOP");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LPOP_COUNT.js
var require_LPOP_COUNT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LPOP_1 = __importDefault(require_LPOP());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, count) {
      LPOP_1.default.parseCommand(parser, key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LPOS.js
var require_LPOS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, element, options) {
      parser.push("LPOS");
      parser.pushKey(key);
      parser.push(element);
      if (options?.RANK !== undefined) {
        parser.push("RANK", options.RANK.toString());
      }
      if (options?.MAXLEN !== undefined) {
        parser.push("MAXLEN", options.MAXLEN.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LPOS_COUNT.js
var require_LPOS_COUNT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LPOS_1 = __importDefault(require_LPOS());
  exports.default = {
    CACHEABLE: LPOS_1.default.CACHEABLE,
    IS_READ_ONLY: LPOS_1.default.IS_READ_ONLY,
    parseCommand(parser, key, element, count, options) {
      LPOS_1.default.parseCommand(parser, key, element, options);
      parser.push("COUNT", count.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LPUSH.js
var require_LPUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, elements) {
      parser.push("LPUSH");
      parser.pushKey(key);
      parser.pushVariadic(elements);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LPUSHX.js
var require_LPUSHX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, elements) {
      parser.push("LPUSHX");
      parser.pushKey(key);
      parser.pushVariadic(elements);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LRANGE.js
var require_LRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, start, stop) {
      parser.push("LRANGE");
      parser.pushKey(key);
      parser.push(start.toString(), stop.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LREM.js
var require_LREM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, count, element) {
      parser.push("LREM");
      parser.pushKey(key);
      parser.push(count.toString());
      parser.push(element);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LSET.js
var require_LSET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, index, element) {
      parser.push("LSET");
      parser.pushKey(key);
      parser.push(index.toString(), element);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/LTRIM.js
var require_LTRIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, start, stop) {
      parser.push("LTRIM");
      parser.pushKey(key);
      parser.push(start.toString(), stop.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/MEMORY_DOCTOR.js
var require_MEMORY_DOCTOR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("MEMORY", "DOCTOR");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/MEMORY_MALLOC-STATS.js
var require_MEMORY_MALLOC_STATS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("MEMORY", "MALLOC-STATS");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/MEMORY_PURGE.js
var require_MEMORY_PURGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser) {
      parser.push("MEMORY", "PURGE");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/MEMORY_STATS.js
var require_MEMORY_STATS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("MEMORY", "STATS");
    },
    transformReply: {
      2: (rawReply, preserve, typeMapping) => {
        const reply = {};
        let i = 0;
        while (i < rawReply.length) {
          switch (rawReply[i].toString()) {
            case "dataset.percentage":
            case "peak.percentage":
            case "allocator-fragmentation.ratio":
            case "allocator-rss.ratio":
            case "rss-overhead.ratio":
            case "fragmentation":
              reply[rawReply[i++]] = generic_transformers_1.transformDoubleReply[2](rawReply[i++], preserve, typeMapping);
              break;
            default:
              reply[rawReply[i++]] = rawReply[i++];
          }
        }
        return reply;
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/MEMORY_USAGE.js
var require_MEMORY_USAGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("MEMORY", "USAGE");
      parser.pushKey(key);
      if (options?.SAMPLES) {
        parser.push("SAMPLES", options.SAMPLES.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/MGET.js
var require_MGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("MGET");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/MIGRATE.js
var require_MIGRATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, host, port, key, destinationDb, timeout, options) {
      parser.push("MIGRATE", host, port.toString());
      const isKeyArray = Array.isArray(key);
      if (isKeyArray) {
        parser.push("");
      } else {
        parser.push(key);
      }
      parser.push(destinationDb.toString(), timeout.toString());
      if (options?.COPY) {
        parser.push("COPY");
      }
      if (options?.REPLACE) {
        parser.push("REPLACE");
      }
      if (options?.AUTH) {
        if (options.AUTH.username) {
          parser.push("AUTH2", options.AUTH.username, options.AUTH.password);
        } else {
          parser.push("AUTH", options.AUTH.password);
        }
      }
      if (isKeyArray) {
        parser.push("KEYS");
        parser.pushVariadic(key);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/MODULE_LIST.js
var require_MODULE_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("MODULE", "LIST");
    },
    transformReply: {
      2: (reply) => {
        return reply.map((module2) => {
          const unwrapped = module2;
          return {
            name: unwrapped[1],
            ver: unwrapped[3]
          };
        });
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/MODULE_LOAD.js
var require_MODULE_LOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, path, moduleArguments) {
      parser.push("MODULE", "LOAD", path);
      if (moduleArguments) {
        parser.push(...moduleArguments);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/MODULE_UNLOAD.js
var require_MODULE_UNLOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, name) {
      parser.push("MODULE", "UNLOAD", name);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/MOVE.js
var require_MOVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, db) {
      parser.push("MOVE");
      parser.pushKey(key);
      parser.push(db.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/MSET.js
var require_MSET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseMSetArguments = undefined;
  function parseMSetArguments(parser, toSet) {
    if (Array.isArray(toSet)) {
      if (toSet.length == 0) {
        throw new Error("empty toSet Argument");
      }
      if (Array.isArray(toSet[0])) {
        for (const tuple of toSet) {
          parser.pushKey(tuple[0]);
          parser.push(tuple[1]);
        }
      } else {
        const arr = toSet;
        for (let i = 0;i < arr.length; i += 2) {
          parser.pushKey(arr[i]);
          parser.push(arr[i + 1]);
        }
      }
    } else {
      for (const tuple of Object.entries(toSet)) {
        parser.pushKey(tuple[0]);
        parser.push(tuple[1]);
      }
    }
  }
  exports.parseMSetArguments = parseMSetArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, toSet) {
      parser.push("MSET");
      return parseMSetArguments(parser, toSet);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/MSETNX.js
var require_MSETNX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var MSET_1 = require_MSET();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, toSet) {
      parser.push("MSETNX");
      return (0, MSET_1.parseMSetArguments)(parser, toSet);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/OBJECT_ENCODING.js
var require_OBJECT_ENCODING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("OBJECT", "ENCODING");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/OBJECT_FREQ.js
var require_OBJECT_FREQ = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("OBJECT", "FREQ");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/OBJECT_IDLETIME.js
var require_OBJECT_IDLETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("OBJECT", "IDLETIME");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/OBJECT_REFCOUNT.js
var require_OBJECT_REFCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("OBJECT", "REFCOUNT");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PERSIST.js
var require_PERSIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("PERSIST");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PEXPIRE.js
var require_PEXPIRE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, ms, mode) {
      parser.push("PEXPIRE");
      parser.pushKey(key);
      parser.push(ms.toString());
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PEXPIREAT.js
var require_PEXPIREAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, msTimestamp, mode) {
      parser.push("PEXPIREAT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformPXAT)(msTimestamp));
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PEXPIRETIME.js
var require_PEXPIRETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("PEXPIRETIME");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PFADD.js
var require_PFADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, element) {
      parser.push("PFADD");
      parser.pushKey(key);
      if (element) {
        parser.pushVariadic(element);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PFCOUNT.js
var require_PFCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("PFCOUNT");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PFMERGE.js
var require_PFMERGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, destination, sources) {
      parser.push("PFMERGE");
      parser.pushKey(destination);
      if (sources) {
        parser.pushKeys(sources);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PING.js
var require_PING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, message) {
      parser.push("PING");
      if (message) {
        parser.push(message);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PSETEX.js
var require_PSETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, ms, value) {
      parser.push("PSETEX");
      parser.pushKey(key);
      parser.push(ms.toString(), value);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PTTL.js
var require_PTTL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("PTTL");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PUBLISH.js
var require_PUBLISH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    IS_FORWARD_COMMAND: true,
    parseCommand(parser, channel, message) {
      parser.push("PUBLISH", channel, message);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PUBSUB_CHANNELS.js
var require_PUBSUB_CHANNELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, pattern) {
      parser.push("PUBSUB", "CHANNELS");
      if (pattern) {
        parser.push(pattern);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PUBSUB_NUMPAT.js
var require_PUBSUB_NUMPAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("PUBSUB", "NUMPAT");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PUBSUB_NUMSUB.js
var require_PUBSUB_NUMSUB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, channels) {
      parser.push("PUBSUB", "NUMSUB");
      if (channels) {
        parser.pushVariadic(channels);
      }
    },
    transformReply(rawReply) {
      const reply = Object.create(null);
      let i = 0;
      while (i < rawReply.length) {
        reply[rawReply[i++].toString()] = rawReply[i++].toString();
      }
      return reply;
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PUBSUB_SHARDNUMSUB.js
var require_PUBSUB_SHARDNUMSUB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, channels) {
      parser.push("PUBSUB", "SHARDNUMSUB");
      if (channels) {
        parser.pushVariadic(channels);
      }
    },
    transformReply(reply) {
      const transformedReply = Object.create(null);
      for (let i = 0;i < reply.length; i += 2) {
        transformedReply[reply[i].toString()] = reply[i + 1];
      }
      return transformedReply;
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/PUBSUB_SHARDCHANNELS.js
var require_PUBSUB_SHARDCHANNELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, pattern) {
      parser.push("PUBSUB", "SHARDCHANNELS");
      if (pattern) {
        parser.push(pattern);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/RANDOMKEY.js
var require_RANDOMKEY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("RANDOMKEY");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/READONLY.js
var require_READONLY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("READONLY");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/RENAME.js
var require_RENAME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, newKey) {
      parser.push("RENAME");
      parser.pushKeys([key, newKey]);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/RENAMENX.js
var require_RENAMENX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, newKey) {
      parser.push("RENAMENX");
      parser.pushKeys([key, newKey]);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/REPLICAOF.js
var require_REPLICAOF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, host, port) {
      parser.push("REPLICAOF", host, port.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/RESTORE-ASKING.js
var require_RESTORE_ASKING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("RESTORE-ASKING");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/RESTORE.js
var require_RESTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, ttl, serializedValue, options) {
      parser.push("RESTORE");
      parser.pushKey(key);
      parser.push(ttl.toString(), serializedValue);
      if (options?.REPLACE) {
        parser.push("REPLACE");
      }
      if (options?.ABSTTL) {
        parser.push("ABSTTL");
      }
      if (options?.IDLETIME) {
        parser.push("IDLETIME", options.IDLETIME.toString());
      }
      if (options?.FREQ) {
        parser.push("FREQ", options.FREQ.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ROLE.js
var require_ROLE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ROLE");
    },
    transformReply(reply) {
      switch (reply[0]) {
        case "master": {
          const [role, replicationOffest, replicas] = reply;
          return {
            role,
            replicationOffest,
            replicas: replicas.map((replica) => {
              const [host, port, replicationOffest2] = replica;
              return {
                host,
                port: Number(port),
                replicationOffest: Number(replicationOffest2)
              };
            })
          };
        }
        case "slave": {
          const [role, masterHost, masterPort, state, dataReceived] = reply;
          return {
            role,
            master: {
              host: masterHost,
              port: masterPort
            },
            state,
            dataReceived
          };
        }
        case "sentinel": {
          const [role, masterNames] = reply;
          return {
            role,
            masterNames
          };
        }
      }
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/RPOP_COUNT.js
var require_RPOP_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, count) {
      parser.push("RPOP");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/RPOP.js
var require_RPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("RPOP");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/RPOPLPUSH.js
var require_RPOPLPUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, source, destination) {
      parser.push("RPOPLPUSH");
      parser.pushKeys([source, destination]);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/RPUSH.js
var require_RPUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, element) {
      parser.push("RPUSH");
      parser.pushKey(key);
      parser.pushVariadic(element);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/RPUSHX.js
var require_RPUSHX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, element) {
      parser.push("RPUSHX");
      parser.pushKey(key);
      parser.pushVariadic(element);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SADD.js
var require_SADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, members) {
      parser.push("SADD");
      parser.pushKey(key);
      parser.pushVariadic(members);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SCARD.js
var require_SCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("SCARD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SCRIPT_DEBUG.js
var require_SCRIPT_DEBUG = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, mode) {
      parser.push("SCRIPT", "DEBUG", mode);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SCRIPT_EXISTS.js
var require_SCRIPT_EXISTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, sha1) {
      parser.push("SCRIPT", "EXISTS");
      parser.pushVariadic(sha1);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SCRIPT_FLUSH.js
var require_SCRIPT_FLUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, mode) {
      parser.push("SCRIPT", "FLUSH");
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SCRIPT_KILL.js
var require_SCRIPT_KILL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("SCRIPT", "KILL");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SCRIPT_LOAD.js
var require_SCRIPT_LOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, script) {
      parser.push("SCRIPT", "LOAD", script);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SDIFF.js
var require_SDIFF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("SDIFF");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SDIFFSTORE.js
var require_SDIFFSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, destination, keys) {
      parser.push("SDIFFSTORE");
      parser.pushKey(destination);
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SET.js
var require_SET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, value, options) {
      parser.push("SET");
      parser.pushKey(key);
      parser.push(typeof value === "number" ? value.toString() : value);
      if (options?.expiration) {
        if (typeof options.expiration === "string") {
          parser.push(options.expiration);
        } else if (options.expiration.type === "KEEPTTL") {
          parser.push("KEEPTTL");
        } else {
          parser.push(options.expiration.type, options.expiration.value.toString());
        }
      } else if (options?.EX !== undefined) {
        parser.push("EX", options.EX.toString());
      } else if (options?.PX !== undefined) {
        parser.push("PX", options.PX.toString());
      } else if (options?.EXAT !== undefined) {
        parser.push("EXAT", options.EXAT.toString());
      } else if (options?.PXAT !== undefined) {
        parser.push("PXAT", options.PXAT.toString());
      } else if (options?.KEEPTTL) {
        parser.push("KEEPTTL");
      }
      if (options?.condition) {
        parser.push(options.condition);
      } else if (options?.NX) {
        parser.push("NX");
      } else if (options?.XX) {
        parser.push("XX");
      }
      if (options?.GET) {
        parser.push("GET");
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SETBIT.js
var require_SETBIT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, offset, value) {
      parser.push("SETBIT");
      parser.pushKey(key);
      parser.push(offset.toString(), value.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SETEX.js
var require_SETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, seconds, value) {
      parser.push("SETEX");
      parser.pushKey(key);
      parser.push(seconds.toString(), value);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SETNX.js
var require_SETNX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, value) {
      parser.push("SETNX");
      parser.pushKey(key);
      parser.push(value);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SETRANGE.js
var require_SETRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, offset, value) {
      parser.push("SETRANGE");
      parser.pushKey(key);
      parser.push(offset.toString(), value);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SINTER.js
var require_SINTER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("SINTER");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SINTERCARD.js
var require_SINTERCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, options) {
      parser.push("SINTERCARD");
      parser.pushKeysLength(keys);
      if (typeof options === "number") {
        parser.push("LIMIT", options.toString());
      } else if (options?.LIMIT !== undefined) {
        parser.push("LIMIT", options.LIMIT.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SINTERSTORE.js
var require_SINTERSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, keys) {
      parser.push("SINTERSTORE");
      parser.pushKey(destination);
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SISMEMBER.js
var require_SISMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("SISMEMBER");
      parser.pushKey(key);
      parser.push(member);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SMEMBERS.js
var require_SMEMBERS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("SMEMBERS");
      parser.pushKey(key);
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SMISMEMBER.js
var require_SMISMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, members) {
      parser.push("SMISMEMBER");
      parser.pushKey(key);
      parser.pushVariadic(members);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SMOVE.js
var require_SMOVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, member) {
      parser.push("SMOVE");
      parser.pushKeys([source, destination]);
      parser.push(member);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SORT.js
var require_SORT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseSortArguments = undefined;
  function parseSortArguments(parser, key, options) {
    parser.pushKey(key);
    if (options?.BY) {
      parser.push("BY", options.BY);
    }
    if (options?.LIMIT) {
      parser.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    if (options?.GET) {
      if (Array.isArray(options.GET)) {
        for (const pattern of options.GET) {
          parser.push("GET", pattern);
        }
      } else {
        parser.push("GET", options.GET);
      }
    }
    if (options?.DIRECTION) {
      parser.push(options.DIRECTION);
    }
    if (options?.ALPHA) {
      parser.push("ALPHA");
    }
  }
  exports.parseSortArguments = parseSortArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("SORT");
      parseSortArguments(parser, key, options);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SORT_RO.js
var require_SORT_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SORT_1 = __importStar(require_SORT());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("SORT_RO");
      (0, SORT_1.parseSortArguments)(...args);
    },
    transformReply: SORT_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SORT_STORE.js
var require_SORT_STORE = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SORT_1 = __importDefault(require_SORT());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, options) {
      SORT_1.default.parseCommand(parser, source, options);
      parser.push("STORE", destination);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SPOP_COUNT.js
var require_SPOP_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, count) {
      parser.push("SPOP");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SPOP.js
var require_SPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("SPOP");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SPUBLISH.js
var require_SPUBLISH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, channel, message) {
      parser.push("SPUBLISH");
      parser.pushKey(channel);
      parser.push(message);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SRANDMEMBER.js
var require_SRANDMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("SRANDMEMBER");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SRANDMEMBER_COUNT.js
var require_SRANDMEMBER_COUNT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SRANDMEMBER_1 = __importDefault(require_SRANDMEMBER());
  exports.default = {
    IS_READ_ONLY: SRANDMEMBER_1.default.IS_READ_ONLY,
    parseCommand(parser, key, count) {
      SRANDMEMBER_1.default.parseCommand(parser, key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SREM.js
var require_SREM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, members) {
      parser.push("SREM");
      parser.pushKey(key);
      parser.pushVariadic(members);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SSCAN.js
var require_SSCAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SCAN_1 = require_SCAN();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, cursor, options) {
      parser.push("SSCAN");
      parser.pushKey(key);
      (0, SCAN_1.parseScanArguments)(parser, cursor, options);
    },
    transformReply([cursor, members]) {
      return {
        cursor,
        members
      };
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/STRLEN.js
var require_STRLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("STRLEN");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SUNION.js
var require_SUNION = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("SUNION");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SUNIONSTORE.js
var require_SUNIONSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, keys) {
      parser.push("SUNIONSTORE");
      parser.pushKey(destination);
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/SWAPDB.js
var require_SWAPDB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, index1, index2) {
      parser.push("SWAPDB", index1.toString(), index2.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/TIME.js
var require_TIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("TIME");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/TOUCH.js
var require_TOUCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("TOUCH");
      parser.pushKeys(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/TTL.js
var require_TTL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TTL");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/TYPE.js
var require_TYPE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TYPE");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/UNLINK.js
var require_UNLINK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, keys) {
      parser.push("UNLINK");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/WAIT.js
var require_WAIT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, numberOfReplicas, timeout) {
      parser.push("WAIT", numberOfReplicas.toString(), timeout.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XACK.js
var require_XACK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, id) {
      parser.push("XACK");
      parser.pushKey(key);
      parser.push(group);
      parser.pushVariadic(id);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XADD.js
var require_XADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseXAddArguments = undefined;
  function parseXAddArguments(optional, parser, key, id, message, options) {
    parser.push("XADD");
    parser.pushKey(key);
    if (optional) {
      parser.push(optional);
    }
    if (options?.TRIM) {
      if (options.TRIM.strategy) {
        parser.push(options.TRIM.strategy);
      }
      if (options.TRIM.strategyModifier) {
        parser.push(options.TRIM.strategyModifier);
      }
      parser.push(options.TRIM.threshold.toString());
      if (options.TRIM.limit) {
        parser.push("LIMIT", options.TRIM.limit.toString());
      }
    }
    parser.push(id);
    for (const [key2, value] of Object.entries(message)) {
      parser.push(key2, value);
    }
  }
  exports.parseXAddArguments = parseXAddArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      return parseXAddArguments(undefined, ...args);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XADD_NOMKSTREAM.js
var require_XADD_NOMKSTREAM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var XADD_1 = require_XADD();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      return (0, XADD_1.parseXAddArguments)("NOMKSTREAM", ...args);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XAUTOCLAIM.js
var require_XAUTOCLAIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, consumer, minIdleTime, start, options) {
      parser.push("XAUTOCLAIM");
      parser.pushKey(key);
      parser.push(group, consumer, minIdleTime.toString(), start);
      if (options?.COUNT) {
        parser.push("COUNT", options.COUNT.toString());
      }
    },
    transformReply(reply, preserve, typeMapping) {
      return {
        nextId: reply[0],
        messages: reply[1].map(generic_transformers_1.transformStreamMessageNullReply.bind(undefined, typeMapping)),
        deletedMessages: reply[2]
      };
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XAUTOCLAIM_JUSTID.js
var require_XAUTOCLAIM_JUSTID = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var XAUTOCLAIM_1 = __importDefault(require_XAUTOCLAIM());
  exports.default = {
    IS_READ_ONLY: XAUTOCLAIM_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      XAUTOCLAIM_1.default.parseCommand(...args);
      parser.push("JUSTID");
    },
    transformReply(reply) {
      return {
        nextId: reply[0],
        messages: reply[1],
        deletedMessages: reply[2]
      };
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XCLAIM.js
var require_XCLAIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, consumer, minIdleTime, id, options) {
      parser.push("XCLAIM");
      parser.pushKey(key);
      parser.push(group, consumer, minIdleTime.toString());
      parser.pushVariadic(id);
      if (options?.IDLE !== undefined) {
        parser.push("IDLE", options.IDLE.toString());
      }
      if (options?.TIME !== undefined) {
        parser.push("TIME", (options.TIME instanceof Date ? options.TIME.getTime() : options.TIME).toString());
      }
      if (options?.RETRYCOUNT !== undefined) {
        parser.push("RETRYCOUNT", options.RETRYCOUNT.toString());
      }
      if (options?.FORCE) {
        parser.push("FORCE");
      }
      if (options?.LASTID !== undefined) {
        parser.push("LASTID", options.LASTID);
      }
    },
    transformReply(reply, preserve, typeMapping) {
      return reply.map(generic_transformers_1.transformStreamMessageNullReply.bind(undefined, typeMapping));
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XCLAIM_JUSTID.js
var require_XCLAIM_JUSTID = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var XCLAIM_1 = __importDefault(require_XCLAIM());
  exports.default = {
    IS_READ_ONLY: XCLAIM_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      XCLAIM_1.default.parseCommand(...args);
      parser.push("JUSTID");
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XDEL.js
var require_XDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, id) {
      parser.push("XDEL");
      parser.pushKey(key);
      parser.pushVariadic(id);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XGROUP_CREATE.js
var require_XGROUP_CREATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, id, options) {
      parser.push("XGROUP", "CREATE");
      parser.pushKey(key);
      parser.push(group, id);
      if (options?.MKSTREAM) {
        parser.push("MKSTREAM");
      }
      if (options?.ENTRIESREAD) {
        parser.push("ENTRIESREAD", options.ENTRIESREAD.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XGROUP_CREATECONSUMER.js
var require_XGROUP_CREATECONSUMER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, consumer) {
      parser.push("XGROUP", "CREATECONSUMER");
      parser.pushKey(key);
      parser.push(group, consumer);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XGROUP_DELCONSUMER.js
var require_XGROUP_DELCONSUMER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, consumer) {
      parser.push("XGROUP", "DELCONSUMER");
      parser.pushKey(key);
      parser.push(group, consumer);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XGROUP_DESTROY.js
var require_XGROUP_DESTROY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group) {
      parser.push("XGROUP", "DESTROY");
      parser.pushKey(key);
      parser.push(group);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XGROUP_SETID.js
var require_XGROUP_SETID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, id, options) {
      parser.push("XGROUP", "SETID");
      parser.pushKey(key);
      parser.push(group, id);
      if (options?.ENTRIESREAD) {
        parser.push("ENTRIESREAD", options.ENTRIESREAD.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XINFO_CONSUMERS.js
var require_XINFO_CONSUMERS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, group) {
      parser.push("XINFO", "CONSUMERS");
      parser.pushKey(key);
      parser.push(group);
    },
    transformReply: {
      2: (reply) => {
        return reply.map((consumer) => {
          const unwrapped = consumer;
          return {
            name: unwrapped[1],
            pending: unwrapped[3],
            idle: unwrapped[5],
            inactive: unwrapped[7]
          };
        });
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XINFO_GROUPS.js
var require_XINFO_GROUPS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("XINFO", "GROUPS");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply) => {
        return reply.map((group) => {
          const unwrapped = group;
          return {
            name: unwrapped[1],
            consumers: unwrapped[3],
            pending: unwrapped[5],
            "last-delivered-id": unwrapped[7],
            "entries-read": unwrapped[9],
            lag: unwrapped[11]
          };
        });
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XINFO_STREAM.js
var require_XINFO_STREAM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("XINFO", "STREAM");
      parser.pushKey(key);
    },
    transformReply: {
      2(reply) {
        const parsedReply = {};
        for (let i = 0;i < reply.length; i += 2) {
          switch (reply[i]) {
            case "first-entry":
            case "last-entry":
              parsedReply[reply[i]] = transformEntry(reply[i + 1]);
              break;
            default:
              parsedReply[reply[i]] = reply[i + 1];
              break;
          }
        }
        return parsedReply;
      },
      3(reply) {
        if (reply instanceof Map) {
          reply.set("first-entry", transformEntry(reply.get("first-entry")));
          reply.set("last-entry", transformEntry(reply.get("last-entry")));
        } else if (reply instanceof Array) {
          reply[17] = transformEntry(reply[17]);
          reply[19] = transformEntry(reply[19]);
        } else {
          reply["first-entry"] = transformEntry(reply["first-entry"]);
          reply["last-entry"] = transformEntry(reply["last-entry"]);
        }
        return reply;
      }
    }
  };
  function transformEntry(entry) {
    if ((0, generic_transformers_1.isNullReply)(entry))
      return entry;
    const [id, message] = entry;
    return {
      id,
      message: (0, generic_transformers_1.transformTuplesReply)(message)
    };
  }
});

// ../../node_modules/@redis/client/dist/lib/commands/XLEN.js
var require_XLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("XLEN");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XPENDING_RANGE.js
var require_XPENDING_RANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, group, start, end, count, options) {
      parser.push("XPENDING");
      parser.pushKey(key);
      parser.push(group);
      if (options?.IDLE !== undefined) {
        parser.push("IDLE", options.IDLE.toString());
      }
      parser.push(start, end, count.toString());
      if (options?.consumer) {
        parser.push(options.consumer);
      }
    },
    transformReply(reply) {
      return reply.map((pending) => {
        const unwrapped = pending;
        return {
          id: unwrapped[0],
          consumer: unwrapped[1],
          millisecondsSinceLastDelivery: unwrapped[2],
          deliveriesCounter: unwrapped[3]
        };
      });
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XPENDING.js
var require_XPENDING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, group) {
      parser.push("XPENDING");
      parser.pushKey(key);
      parser.push(group);
    },
    transformReply(reply) {
      const consumers = reply[3];
      return {
        pending: reply[0],
        firstId: reply[1],
        lastId: reply[2],
        consumers: consumers === null ? null : consumers.map((consumer) => {
          const [name, deliveriesCounter] = consumer;
          return {
            name,
            deliveriesCounter: Number(deliveriesCounter)
          };
        })
      };
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XRANGE.js
var require_XRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.xRangeArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function xRangeArguments(start, end, options) {
    const args = [start, end];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  }
  exports.xRangeArguments = xRangeArguments;
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, ...args) {
      parser.push("XRANGE");
      parser.pushKey(key);
      parser.pushVariadic(xRangeArguments(args[0], args[1], args[2]));
    },
    transformReply(reply, preserve, typeMapping) {
      return reply.map(generic_transformers_1.transformStreamMessageReply.bind(undefined, typeMapping));
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XREAD.js
var require_XREAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushXReadStreams = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function pushXReadStreams(parser, streams) {
    parser.push("STREAMS");
    if (Array.isArray(streams)) {
      for (let i = 0;i < streams.length; i++) {
        parser.pushKey(streams[i].key);
      }
      for (let i = 0;i < streams.length; i++) {
        parser.push(streams[i].id);
      }
    } else {
      parser.pushKey(streams.key);
      parser.push(streams.id);
    }
  }
  exports.pushXReadStreams = pushXReadStreams;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, streams, options) {
      parser.push("XREAD");
      if (options?.COUNT) {
        parser.push("COUNT", options.COUNT.toString());
      }
      if (options?.BLOCK !== undefined) {
        parser.push("BLOCK", options.BLOCK.toString());
      }
      pushXReadStreams(parser, streams);
    },
    transformReply: {
      2: generic_transformers_1.transformStreamsMessagesReplyResp2,
      3: undefined
    },
    unstableResp3: true
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XREADGROUP.js
var require_XREADGROUP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var XREAD_1 = require_XREAD();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, group, consumer, streams, options) {
      parser.push("XREADGROUP", "GROUP", group, consumer);
      if (options?.COUNT !== undefined) {
        parser.push("COUNT", options.COUNT.toString());
      }
      if (options?.BLOCK !== undefined) {
        parser.push("BLOCK", options.BLOCK.toString());
      }
      if (options?.NOACK) {
        parser.push("NOACK");
      }
      (0, XREAD_1.pushXReadStreams)(parser, streams);
    },
    transformReply: {
      2: generic_transformers_1.transformStreamsMessagesReplyResp2,
      3: undefined
    },
    unstableResp3: true
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XREVRANGE.js
var require_XREVRANGE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var XRANGE_1 = __importStar(require_XRANGE());
  exports.default = {
    CACHEABLE: XRANGE_1.default.CACHEABLE,
    IS_READ_ONLY: XRANGE_1.default.IS_READ_ONLY,
    parseCommand(parser, key, ...args) {
      parser.push("XREVRANGE");
      parser.pushKey(key);
      parser.pushVariadic((0, XRANGE_1.xRangeArguments)(args[0], args[1], args[2]));
    },
    transformReply: XRANGE_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XSETID.js
var require_XSETID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, lastId, options) {
      parser.push("XSETID");
      parser.pushKey(key);
      parser.push(lastId);
      if (options?.ENTRIESADDED) {
        parser.push("ENTRIESADDED", options.ENTRIESADDED.toString());
      }
      if (options?.MAXDELETEDID) {
        parser.push("MAXDELETEDID", options.MAXDELETEDID);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/XTRIM.js
var require_XTRIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, strategy, threshold, options) {
      parser.push("XTRIM");
      parser.pushKey(key);
      parser.push(strategy);
      if (options?.strategyModifier) {
        parser.push(options.strategyModifier);
      }
      parser.push(threshold.toString());
      if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZADD.js
var require_ZADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushMembers = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, members, options) {
      parser.push("ZADD");
      parser.pushKey(key);
      if (options?.condition) {
        parser.push(options.condition);
      } else if (options?.NX) {
        parser.push("NX");
      } else if (options?.XX) {
        parser.push("XX");
      }
      if (options?.comparison) {
        parser.push(options.comparison);
      } else if (options?.LT) {
        parser.push("LT");
      } else if (options?.GT) {
        parser.push("GT");
      }
      if (options?.CH) {
        parser.push("CH");
      }
      pushMembers(parser, members);
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
  function pushMembers(parser, members) {
    if (Array.isArray(members)) {
      for (const member of members) {
        pushMember(parser, member);
      }
    } else {
      pushMember(parser, members);
    }
  }
  exports.pushMembers = pushMembers;
  function pushMember(parser, member) {
    parser.push((0, generic_transformers_1.transformDoubleArgument)(member.score), member.value);
  }
});

// ../../node_modules/@redis/client/dist/lib/commands/ZADD_INCR.js
var require_ZADD_INCR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZADD_1 = require_ZADD();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, members, options) {
      parser.push("ZADD");
      parser.pushKey(key);
      if (options?.condition) {
        parser.push(options.condition);
      }
      if (options?.comparison) {
        parser.push(options.comparison);
      }
      if (options?.CH) {
        parser.push("CH");
      }
      parser.push("INCR");
      (0, ZADD_1.pushMembers)(parser, members);
    },
    transformReply: generic_transformers_1.transformNullableDoubleReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZCARD.js
var require_ZCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("ZCARD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZCOUNT.js
var require_ZCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max) {
      parser.push("ZCOUNT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZDIFF.js
var require_ZDIFF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("ZDIFF");
      parser.pushKeysLength(keys);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZDIFF_WITHSCORES.js
var require_ZDIFF_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZDIFF_1 = __importDefault(require_ZDIFF());
  exports.default = {
    IS_READ_ONLY: ZDIFF_1.default.IS_READ_ONLY,
    parseCommand(parser, keys) {
      ZDIFF_1.default.parseCommand(parser, keys);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZDIFFSTORE.js
var require_ZDIFFSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, destination, inputKeys) {
      parser.push("ZDIFFSTORE");
      parser.pushKey(destination);
      parser.pushKeysLength(inputKeys);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZINCRBY.js
var require_ZINCRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, increment, member) {
      parser.push("ZINCRBY");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformDoubleArgument)(increment), member);
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZINTER.js
var require_ZINTER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseZInterArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function parseZInterArguments(parser, keys, options) {
    (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
    if (options?.AGGREGATE) {
      parser.push("AGGREGATE", options.AGGREGATE);
    }
  }
  exports.parseZInterArguments = parseZInterArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, options) {
      parser.push("ZINTER");
      parseZInterArguments(parser, keys, options);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZINTER_WITHSCORES.js
var require_ZINTER_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZINTER_1 = __importDefault(require_ZINTER());
  exports.default = {
    IS_READ_ONLY: ZINTER_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      ZINTER_1.default.parseCommand(...args);
      args[0].push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZINTERCARD.js
var require_ZINTERCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, options) {
      parser.push("ZINTERCARD");
      parser.pushKeysLength(keys);
      if (typeof options === "number") {
        parser.push("LIMIT", options.toString());
      } else if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZINTERSTORE.js
var require_ZINTERSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZINTER_1 = require_ZINTER();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, keys, options) {
      parser.push("ZINTERSTORE");
      parser.pushKey(destination);
      (0, ZINTER_1.parseZInterArguments)(parser, keys, options);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZLEXCOUNT.js
var require_ZLEXCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max) {
      parser.push("ZLEXCOUNT");
      parser.pushKey(key);
      parser.push(min);
      parser.push(max);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZMSCORE.js
var require_ZMSCORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("ZMSCORE");
      parser.pushKey(key);
      parser.pushVariadic(member);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        return reply.map((0, generic_transformers_1.createTransformNullableDoubleReplyResp2Func)(preserve, typeMapping));
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZPOPMAX_COUNT.js
var require_ZPOPMAX_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, count) {
      parser.push("ZPOPMAX");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZPOPMAX.js
var require_ZPOPMAX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("ZPOPMAX");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        if (reply.length === 0)
          return null;
        return {
          value: reply[0],
          score: generic_transformers_1.transformDoubleReply[2](reply[1], preserve, typeMapping)
        };
      },
      3: (reply) => {
        if (reply.length === 0)
          return null;
        return {
          value: reply[0],
          score: reply[1]
        };
      }
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZPOPMIN_COUNT.js
var require_ZPOPMIN_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, count) {
      parser.push("ZPOPMIN");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZPOPMIN.js
var require_ZPOPMIN = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZPOPMAX_1 = __importDefault(require_ZPOPMAX());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("ZPOPMIN");
      parser.pushKey(key);
    },
    transformReply: ZPOPMAX_1.default.transformReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER.js
var require_ZRANDMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("ZRANDMEMBER");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER_COUNT.js
var require_ZRANDMEMBER_COUNT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZRANDMEMBER_1 = __importDefault(require_ZRANDMEMBER());
  exports.default = {
    IS_READ_ONLY: ZRANDMEMBER_1.default.IS_READ_ONLY,
    parseCommand(parser, key, count) {
      ZRANDMEMBER_1.default.parseCommand(parser, key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER_COUNT_WITHSCORES.js
var require_ZRANDMEMBER_COUNT_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZRANDMEMBER_COUNT_1 = __importDefault(require_ZRANDMEMBER_COUNT());
  exports.default = {
    IS_READ_ONLY: ZRANDMEMBER_COUNT_1.default.IS_READ_ONLY,
    parseCommand(parser, key, count) {
      ZRANDMEMBER_COUNT_1.default.parseCommand(parser, key, count);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZRANGE.js
var require_ZRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zRangeArgument = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function zRangeArgument(min, max, options) {
    const args = [
      (0, generic_transformers_1.transformStringDoubleArgument)(min),
      (0, generic_transformers_1.transformStringDoubleArgument)(max)
    ];
    switch (options?.BY) {
      case "SCORE":
        args.push("BYSCORE");
        break;
      case "LEX":
        args.push("BYLEX");
        break;
    }
    if (options?.REV) {
      args.push("REV");
    }
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    return args;
  }
  exports.zRangeArgument = zRangeArgument;
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max, options) {
      parser.push("ZRANGE");
      parser.pushKey(key);
      parser.pushVariadic(zRangeArgument(min, max, options));
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZRANGE_WITHSCORES.js
var require_ZRANGE_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZRANGE_1 = __importDefault(require_ZRANGE());
  exports.default = {
    CACHEABLE: ZRANGE_1.default.CACHEABLE,
    IS_READ_ONLY: ZRANGE_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      ZRANGE_1.default.parseCommand(...args);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZRANGEBYLEX.js
var require_ZRANGEBYLEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max, options) {
      parser.push("ZRANGEBYLEX");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
      if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZRANGEBYSCORE.js
var require_ZRANGEBYSCORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max, options) {
      parser.push("ZRANGEBYSCORE");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
      if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZRANGEBYSCORE_WITHSCORES.js
var require_ZRANGEBYSCORE_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZRANGEBYSCORE_1 = __importDefault(require_ZRANGEBYSCORE());
  exports.default = {
    CACHEABLE: ZRANGEBYSCORE_1.default.CACHEABLE,
    IS_READ_ONLY: ZRANGEBYSCORE_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      ZRANGEBYSCORE_1.default.parseCommand(...args);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZRANGESTORE.js
var require_ZRANGESTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, source, min, max, options) {
      parser.push("ZRANGESTORE");
      parser.pushKey(destination);
      parser.pushKey(source);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
      switch (options?.BY) {
        case "SCORE":
          parser.push("BYSCORE");
          break;
        case "LEX":
          parser.push("BYLEX");
          break;
      }
      if (options?.REV) {
        parser.push("REV");
      }
      if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYSCORE.js
var require_ZREMRANGEBYSCORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, min, max) {
      parser.push("ZREMRANGEBYSCORE");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZRANK.js
var require_ZRANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("ZRANK");
      parser.pushKey(key);
      parser.push(member);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZRANK_WITHSCORE.js
var require_ZRANK_WITHSCORE = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZRANK_1 = __importDefault(require_ZRANK());
  exports.default = {
    CACHEABLE: ZRANK_1.default.CACHEABLE,
    IS_READ_ONLY: ZRANK_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      ZRANK_1.default.parseCommand(...args);
      parser.push("WITHSCORE");
    },
    transformReply: {
      2: (reply) => {
        if (reply === null)
          return null;
        return {
          rank: reply[0],
          score: Number(reply[1])
        };
      },
      3: (reply) => {
        if (reply === null)
          return null;
        return {
          rank: reply[0],
          score: reply[1]
        };
      }
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZREM.js
var require_ZREM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, member) {
      parser.push("ZREM");
      parser.pushKey(key);
      parser.pushVariadic(member);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYLEX.js
var require_ZREMRANGEBYLEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, min, max) {
      parser.push("ZREMRANGEBYLEX");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYRANK.js
var require_ZREMRANGEBYRANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, start, stop) {
      parser.push("ZREMRANGEBYRANK");
      parser.pushKey(key);
      parser.push(start.toString(), stop.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZREVRANK.js
var require_ZREVRANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("ZREVRANK");
      parser.pushKey(key);
      parser.push(member);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZSCAN.js
var require_ZSCAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SCAN_1 = require_SCAN();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, cursor, options) {
      parser.push("ZSCAN");
      parser.pushKey(key);
      (0, SCAN_1.parseScanArguments)(parser, cursor, options);
    },
    transformReply([cursor, rawMembers]) {
      return {
        cursor,
        members: generic_transformers_1.transformSortedSetReply[2](rawMembers)
      };
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZSCORE.js
var require_ZSCORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("ZSCORE");
      parser.pushKey(key);
      parser.push(member);
    },
    transformReply: generic_transformers_1.transformNullableDoubleReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZUNION.js
var require_ZUNION = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, options) {
      parser.push("ZUNION");
      (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
      if (options?.AGGREGATE) {
        parser.push("AGGREGATE", options.AGGREGATE);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZUNION_WITHSCORES.js
var require_ZUNION_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZUNION_1 = __importDefault(require_ZUNION());
  exports.default = {
    IS_READ_ONLY: ZUNION_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      ZUNION_1.default.parseCommand(...args);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/ZUNIONSTORE.js
var require_ZUNIONSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, keys, options) {
      parser.push("ZUNIONSTORE");
      parser.pushKey(destination);
      (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
      if (options?.AGGREGATE) {
        parser.push("AGGREGATE", options.AGGREGATE);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VADD.js
var require_VADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, vector, element, options) {
      parser.push("VADD");
      parser.pushKey(key);
      if (options?.REDUCE !== undefined) {
        parser.push("REDUCE", options.REDUCE.toString());
      }
      parser.push("VALUES", vector.length.toString());
      for (const value of vector) {
        parser.push((0, generic_transformers_1.transformDoubleArgument)(value));
      }
      parser.push(element);
      if (options?.CAS) {
        parser.push("CAS");
      }
      options?.QUANT && parser.push(options.QUANT);
      if (options?.EF !== undefined) {
        parser.push("EF", options.EF.toString());
      }
      if (options?.SETATTR) {
        parser.push("SETATTR", JSON.stringify(options.SETATTR));
      }
      if (options?.M !== undefined) {
        parser.push("M", options.M.toString());
      }
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VCARD.js
var require_VCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("VCARD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VDIM.js
var require_VDIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("VDIM");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VEMB.js
var require_VEMB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, element) {
      parser.push("VEMB");
      parser.pushKey(key);
      parser.push(element);
    },
    transformReply: generic_transformers_1.transformDoubleArrayReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VEMB_RAW.js
var require_VEMB_RAW = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var VEMB_1 = __importDefault(require_VEMB());
  var transformRawVembReply = {
    2: (reply) => {
      return {
        quantization: reply[0],
        raw: reply[1],
        l2Norm: generic_transformers_1.transformDoubleReply[2](reply[2]),
        ...reply[3] !== undefined && { quantizationRange: generic_transformers_1.transformDoubleReply[2](reply[3]) }
      };
    },
    3: (reply) => {
      return {
        quantization: reply[0],
        raw: reply[1],
        l2Norm: reply[2],
        quantizationRange: reply[3]
      };
    }
  };
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, element) {
      VEMB_1.default.parseCommand(parser, key, element);
      parser.push("RAW");
    },
    transformReply: transformRawVembReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VGETATTR.js
var require_VGETATTR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, element) {
      parser.push("VGETATTR");
      parser.pushKey(key);
      parser.push(element);
    },
    transformReply: generic_transformers_1.transformRedisJsonNullReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VINFO.js
var require_VINFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("VINFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply) => {
        const ret = Object.create(null);
        for (let i = 0;i < reply.length; i += 2) {
          ret[reply[i].toString()] = reply[i + 1];
        }
        return ret;
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VLINKS.js
var require_VLINKS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, element) {
      parser.push("VLINKS");
      parser.pushKey(key);
      parser.push(element);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VLINKS_WITHSCORES.js
var require_VLINKS_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var VLINKS_1 = __importDefault(require_VLINKS());
  function transformVLinksWithScoresReply(reply) {
    const layers = [];
    for (const layer of reply) {
      const obj = Object.create(null);
      for (let i = 0;i < layer.length; i += 2) {
        const element = layer[i];
        const score = generic_transformers_1.transformDoubleReply[2](layer[i + 1]);
        obj[element.toString()] = score;
      }
      layers.push(obj);
    }
    return layers;
  }
  exports.default = {
    IS_READ_ONLY: VLINKS_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      VLINKS_1.default.parseCommand(...args);
      parser.push("WITHSCORES");
    },
    transformReply: {
      2: transformVLinksWithScoresReply,
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VRANDMEMBER.js
var require_VRANDMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, count) {
      parser.push("VRANDMEMBER");
      parser.pushKey(key);
      if (count !== undefined) {
        parser.push(count.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VREM.js
var require_VREM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, element) {
      parser.push("VREM");
      parser.pushKey(key);
      parser.push(element);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VSETATTR.js
var require_VSETATTR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, element, attributes) {
      parser.push("VSETATTR");
      parser.pushKey(key);
      parser.push(element);
      if (typeof attributes === "object" && attributes !== null) {
        parser.push(JSON.stringify(attributes));
      } else {
        parser.push(attributes);
      }
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VSIM.js
var require_VSIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, query, options) {
      parser.push("VSIM");
      parser.pushKey(key);
      if (Array.isArray(query)) {
        parser.push("VALUES", query.length.toString());
        for (const value of query) {
          parser.push((0, generic_transformers_1.transformDoubleArgument)(value));
        }
      } else {
        parser.push("ELE", query);
      }
      if (options?.COUNT !== undefined) {
        parser.push("COUNT", options.COUNT.toString());
      }
      if (options?.EF !== undefined) {
        parser.push("EF", options.EF.toString());
      }
      if (options?.FILTER) {
        parser.push("FILTER", options.FILTER);
      }
      if (options?.["FILTER-EF"] !== undefined) {
        parser.push("FILTER-EF", options["FILTER-EF"].toString());
      }
      if (options?.TRUTH) {
        parser.push("TRUTH");
      }
      if (options?.NOTHREAD) {
        parser.push("NOTHREAD");
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/VSIM_WITHSCORES.js
var require_VSIM_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var VSIM_1 = __importDefault(require_VSIM());
  exports.default = {
    IS_READ_ONLY: VSIM_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      VSIM_1.default.parseCommand(...args);
      parser.push("WITHSCORES");
    },
    transformReply: {
      2: (reply) => {
        const inferred = reply;
        const members = {};
        for (let i = 0;i < inferred.length; i += 2) {
          members[inferred[i].toString()] = generic_transformers_1.transformDoubleReply[2](inferred[i + 1]);
        }
        return members;
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/commands/index.js
var require_commands = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ACL_CAT_1 = __importDefault(require_ACL_CAT());
  var ACL_DELUSER_1 = __importDefault(require_ACL_DELUSER());
  var ACL_DRYRUN_1 = __importDefault(require_ACL_DRYRUN());
  var ACL_GENPASS_1 = __importDefault(require_ACL_GENPASS());
  var ACL_GETUSER_1 = __importDefault(require_ACL_GETUSER());
  var ACL_LIST_1 = __importDefault(require_ACL_LIST());
  var ACL_LOAD_1 = __importDefault(require_ACL_LOAD());
  var ACL_LOG_RESET_1 = __importDefault(require_ACL_LOG_RESET());
  var ACL_LOG_1 = __importDefault(require_ACL_LOG());
  var ACL_SAVE_1 = __importDefault(require_ACL_SAVE());
  var ACL_SETUSER_1 = __importDefault(require_ACL_SETUSER());
  var ACL_USERS_1 = __importDefault(require_ACL_USERS());
  var ACL_WHOAMI_1 = __importDefault(require_ACL_WHOAMI());
  var APPEND_1 = __importDefault(require_APPEND());
  var ASKING_1 = __importDefault(require_ASKING());
  var AUTH_1 = __importDefault(require_AUTH());
  var BGREWRITEAOF_1 = __importDefault(require_BGREWRITEAOF());
  var BGSAVE_1 = __importDefault(require_BGSAVE());
  var BITCOUNT_1 = __importDefault(require_BITCOUNT());
  var BITFIELD_RO_1 = __importDefault(require_BITFIELD_RO());
  var BITFIELD_1 = __importDefault(require_BITFIELD());
  var BITOP_1 = __importDefault(require_BITOP());
  var BITPOS_1 = __importDefault(require_BITPOS());
  var BLMOVE_1 = __importDefault(require_BLMOVE());
  var BLMPOP_1 = __importDefault(require_BLMPOP());
  var BLPOP_1 = __importDefault(require_BLPOP());
  var BRPOP_1 = __importDefault(require_BRPOP());
  var BRPOPLPUSH_1 = __importDefault(require_BRPOPLPUSH());
  var BZMPOP_1 = __importDefault(require_BZMPOP());
  var BZPOPMAX_1 = __importDefault(require_BZPOPMAX());
  var BZPOPMIN_1 = __importDefault(require_BZPOPMIN());
  var CLIENT_CACHING_1 = __importDefault(require_CLIENT_CACHING());
  var CLIENT_GETNAME_1 = __importDefault(require_CLIENT_GETNAME());
  var CLIENT_GETREDIR_1 = __importDefault(require_CLIENT_GETREDIR());
  var CLIENT_ID_1 = __importDefault(require_CLIENT_ID());
  var CLIENT_INFO_1 = __importDefault(require_CLIENT_INFO());
  var CLIENT_KILL_1 = __importDefault(require_CLIENT_KILL());
  var CLIENT_LIST_1 = __importDefault(require_CLIENT_LIST());
  var CLIENT_NO_EVICT_1 = __importDefault(require_CLIENT_NO_EVICT());
  var CLIENT_NO_TOUCH_1 = __importDefault(require_CLIENT_NO_TOUCH());
  var CLIENT_PAUSE_1 = __importDefault(require_CLIENT_PAUSE());
  var CLIENT_SETNAME_1 = __importDefault(require_CLIENT_SETNAME());
  var CLIENT_TRACKING_1 = __importDefault(require_CLIENT_TRACKING());
  var CLIENT_TRACKINGINFO_1 = __importDefault(require_CLIENT_TRACKINGINFO());
  var CLIENT_UNPAUSE_1 = __importDefault(require_CLIENT_UNPAUSE());
  var CLUSTER_ADDSLOTS_1 = __importDefault(require_CLUSTER_ADDSLOTS());
  var CLUSTER_ADDSLOTSRANGE_1 = __importDefault(require_CLUSTER_ADDSLOTSRANGE());
  var CLUSTER_BUMPEPOCH_1 = __importDefault(require_CLUSTER_BUMPEPOCH());
  var CLUSTER_COUNT_FAILURE_REPORTS_1 = __importDefault(require_CLUSTER_COUNT_FAILURE_REPORTS());
  var CLUSTER_COUNTKEYSINSLOT_1 = __importDefault(require_CLUSTER_COUNTKEYSINSLOT());
  var CLUSTER_DELSLOTS_1 = __importDefault(require_CLUSTER_DELSLOTS());
  var CLUSTER_DELSLOTSRANGE_1 = __importDefault(require_CLUSTER_DELSLOTSRANGE());
  var CLUSTER_FAILOVER_1 = __importDefault(require_CLUSTER_FAILOVER());
  var CLUSTER_FLUSHSLOTS_1 = __importDefault(require_CLUSTER_FLUSHSLOTS());
  var CLUSTER_FORGET_1 = __importDefault(require_CLUSTER_FORGET());
  var CLUSTER_GETKEYSINSLOT_1 = __importDefault(require_CLUSTER_GETKEYSINSLOT());
  var CLUSTER_INFO_1 = __importDefault(require_CLUSTER_INFO());
  var CLUSTER_KEYSLOT_1 = __importDefault(require_CLUSTER_KEYSLOT());
  var CLUSTER_LINKS_1 = __importDefault(require_CLUSTER_LINKS());
  var CLUSTER_MEET_1 = __importDefault(require_CLUSTER_MEET());
  var CLUSTER_MYID_1 = __importDefault(require_CLUSTER_MYID());
  var CLUSTER_MYSHARDID_1 = __importDefault(require_CLUSTER_MYSHARDID());
  var CLUSTER_NODES_1 = __importDefault(require_CLUSTER_NODES());
  var CLUSTER_REPLICAS_1 = __importDefault(require_CLUSTER_REPLICAS());
  var CLUSTER_REPLICATE_1 = __importDefault(require_CLUSTER_REPLICATE());
  var CLUSTER_RESET_1 = __importDefault(require_CLUSTER_RESET());
  var CLUSTER_SAVECONFIG_1 = __importDefault(require_CLUSTER_SAVECONFIG());
  var CLUSTER_SET_CONFIG_EPOCH_1 = __importDefault(require_CLUSTER_SET_CONFIG_EPOCH());
  var CLUSTER_SETSLOT_1 = __importDefault(require_CLUSTER_SETSLOT());
  var CLUSTER_SLOTS_1 = __importDefault(require_CLUSTER_SLOTS());
  var COMMAND_COUNT_1 = __importDefault(require_COMMAND_COUNT());
  var COMMAND_GETKEYS_1 = __importDefault(require_COMMAND_GETKEYS());
  var COMMAND_GETKEYSANDFLAGS_1 = __importDefault(require_COMMAND_GETKEYSANDFLAGS());
  var COMMAND_INFO_1 = __importDefault(require_COMMAND_INFO());
  var COMMAND_LIST_1 = __importDefault(require_COMMAND_LIST());
  var COMMAND_1 = __importDefault(require_COMMAND());
  var CONFIG_GET_1 = __importDefault(require_CONFIG_GET());
  var CONFIG_RESETSTAT_1 = __importDefault(require_CONFIG_RESETSTAT());
  var CONFIG_REWRITE_1 = __importDefault(require_CONFIG_REWRITE());
  var CONFIG_SET_1 = __importDefault(require_CONFIG_SET());
  var COPY_1 = __importDefault(require_COPY());
  var DBSIZE_1 = __importDefault(require_DBSIZE());
  var DECR_1 = __importDefault(require_DECR());
  var DECRBY_1 = __importDefault(require_DECRBY());
  var DEL_1 = __importDefault(require_DEL());
  var DUMP_1 = __importDefault(require_DUMP());
  var ECHO_1 = __importDefault(require_ECHO());
  var EVAL_RO_1 = __importDefault(require_EVAL_RO());
  var EVAL_1 = __importDefault(require_EVAL());
  var EVALSHA_RO_1 = __importDefault(require_EVALSHA_RO());
  var EVALSHA_1 = __importDefault(require_EVALSHA());
  var GEOADD_1 = __importDefault(require_GEOADD());
  var GEODIST_1 = __importDefault(require_GEODIST());
  var GEOHASH_1 = __importDefault(require_GEOHASH());
  var GEOPOS_1 = __importDefault(require_GEOPOS());
  var GEORADIUS_RO_WITH_1 = __importDefault(require_GEORADIUS_RO_WITH());
  var GEORADIUS_RO_1 = __importDefault(require_GEORADIUS_RO());
  var GEORADIUS_STORE_1 = __importDefault(require_GEORADIUS_STORE());
  var GEORADIUS_WITH_1 = __importDefault(require_GEORADIUS_WITH());
  var GEORADIUS_1 = __importDefault(require_GEORADIUS());
  var GEORADIUSBYMEMBER_RO_WITH_1 = __importDefault(require_GEORADIUSBYMEMBER_RO_WITH());
  var GEORADIUSBYMEMBER_RO_1 = __importDefault(require_GEORADIUSBYMEMBER_RO());
  var GEORADIUSBYMEMBER_STORE_1 = __importDefault(require_GEORADIUSBYMEMBER_STORE());
  var GEORADIUSBYMEMBER_WITH_1 = __importDefault(require_GEORADIUSBYMEMBER_WITH());
  var GEORADIUSBYMEMBER_1 = __importDefault(require_GEORADIUSBYMEMBER());
  var GEOSEARCH_WITH_1 = __importDefault(require_GEOSEARCH_WITH());
  var GEOSEARCH_1 = __importDefault(require_GEOSEARCH());
  var GEOSEARCHSTORE_1 = __importDefault(require_GEOSEARCHSTORE());
  var GET_1 = __importDefault(require_GET());
  var GETBIT_1 = __importDefault(require_GETBIT());
  var GETDEL_1 = __importDefault(require_GETDEL());
  var GETEX_1 = __importDefault(require_GETEX());
  var GETRANGE_1 = __importDefault(require_GETRANGE());
  var GETSET_1 = __importDefault(require_GETSET());
  var EXISTS_1 = __importDefault(require_EXISTS());
  var EXPIRE_1 = __importDefault(require_EXPIRE());
  var EXPIREAT_1 = __importDefault(require_EXPIREAT());
  var EXPIRETIME_1 = __importDefault(require_EXPIRETIME());
  var FLUSHALL_1 = __importDefault(require_FLUSHALL());
  var FLUSHDB_1 = __importDefault(require_FLUSHDB());
  var FCALL_1 = __importDefault(require_FCALL());
  var FCALL_RO_1 = __importDefault(require_FCALL_RO());
  var FUNCTION_DELETE_1 = __importDefault(require_FUNCTION_DELETE());
  var FUNCTION_DUMP_1 = __importDefault(require_FUNCTION_DUMP());
  var FUNCTION_FLUSH_1 = __importDefault(require_FUNCTION_FLUSH());
  var FUNCTION_KILL_1 = __importDefault(require_FUNCTION_KILL());
  var FUNCTION_LIST_WITHCODE_1 = __importDefault(require_FUNCTION_LIST_WITHCODE());
  var FUNCTION_LIST_1 = __importDefault(require_FUNCTION_LIST());
  var FUNCTION_LOAD_1 = __importDefault(require_FUNCTION_LOAD());
  var FUNCTION_RESTORE_1 = __importDefault(require_FUNCTION_RESTORE());
  var FUNCTION_STATS_1 = __importDefault(require_FUNCTION_STATS());
  var HDEL_1 = __importDefault(require_HDEL());
  var HELLO_1 = __importDefault(require_HELLO());
  var HEXISTS_1 = __importDefault(require_HEXISTS());
  var HEXPIRE_1 = __importDefault(require_HEXPIRE());
  var HEXPIREAT_1 = __importDefault(require_HEXPIREAT());
  var HEXPIRETIME_1 = __importDefault(require_HEXPIRETIME());
  var HGET_1 = __importDefault(require_HGET());
  var HGETALL_1 = __importDefault(require_HGETALL());
  var HGETDEL_1 = __importDefault(require_HGETDEL());
  var HGETEX_1 = __importDefault(require_HGETEX());
  var HINCRBY_1 = __importDefault(require_HINCRBY());
  var HINCRBYFLOAT_1 = __importDefault(require_HINCRBYFLOAT());
  var HKEYS_1 = __importDefault(require_HKEYS());
  var HLEN_1 = __importDefault(require_HLEN());
  var HMGET_1 = __importDefault(require_HMGET());
  var HPERSIST_1 = __importDefault(require_HPERSIST());
  var HPEXPIRE_1 = __importDefault(require_HPEXPIRE());
  var HPEXPIREAT_1 = __importDefault(require_HPEXPIREAT());
  var HPEXPIRETIME_1 = __importDefault(require_HPEXPIRETIME());
  var HPTTL_1 = __importDefault(require_HPTTL());
  var HRANDFIELD_COUNT_WITHVALUES_1 = __importDefault(require_HRANDFIELD_COUNT_WITHVALUES());
  var HRANDFIELD_COUNT_1 = __importDefault(require_HRANDFIELD_COUNT());
  var HRANDFIELD_1 = __importDefault(require_HRANDFIELD());
  var HSCAN_1 = __importDefault(require_HSCAN());
  var HSCAN_NOVALUES_1 = __importDefault(require_HSCAN_NOVALUES());
  var HSET_1 = __importDefault(require_HSET());
  var HSETEX_1 = __importDefault(require_HSETEX());
  var HSETNX_1 = __importDefault(require_HSETNX());
  var HSTRLEN_1 = __importDefault(require_HSTRLEN());
  var HTTL_1 = __importDefault(require_HTTL());
  var HVALS_1 = __importDefault(require_HVALS());
  var INCR_1 = __importDefault(require_INCR());
  var INCRBY_1 = __importDefault(require_INCRBY());
  var INCRBYFLOAT_1 = __importDefault(require_INCRBYFLOAT());
  var INFO_1 = __importDefault(require_INFO());
  var KEYS_1 = __importDefault(require_KEYS());
  var LASTSAVE_1 = __importDefault(require_LASTSAVE());
  var LATENCY_DOCTOR_1 = __importDefault(require_LATENCY_DOCTOR());
  var LATENCY_GRAPH_1 = __importDefault(require_LATENCY_GRAPH());
  var LATENCY_HISTORY_1 = __importDefault(require_LATENCY_HISTORY());
  var LATENCY_LATEST_1 = __importDefault(require_LATENCY_LATEST());
  var LCS_IDX_WITHMATCHLEN_1 = __importDefault(require_LCS_IDX_WITHMATCHLEN());
  var LCS_IDX_1 = __importDefault(require_LCS_IDX());
  var LCS_LEN_1 = __importDefault(require_LCS_LEN());
  var LCS_1 = __importDefault(require_LCS());
  var LINDEX_1 = __importDefault(require_LINDEX());
  var LINSERT_1 = __importDefault(require_LINSERT());
  var LLEN_1 = __importDefault(require_LLEN());
  var LMOVE_1 = __importDefault(require_LMOVE());
  var LMPOP_1 = __importDefault(require_LMPOP());
  var LOLWUT_1 = __importDefault(require_LOLWUT());
  var LPOP_COUNT_1 = __importDefault(require_LPOP_COUNT());
  var LPOP_1 = __importDefault(require_LPOP());
  var LPOS_COUNT_1 = __importDefault(require_LPOS_COUNT());
  var LPOS_1 = __importDefault(require_LPOS());
  var LPUSH_1 = __importDefault(require_LPUSH());
  var LPUSHX_1 = __importDefault(require_LPUSHX());
  var LRANGE_1 = __importDefault(require_LRANGE());
  var LREM_1 = __importDefault(require_LREM());
  var LSET_1 = __importDefault(require_LSET());
  var LTRIM_1 = __importDefault(require_LTRIM());
  var MEMORY_DOCTOR_1 = __importDefault(require_MEMORY_DOCTOR());
  var MEMORY_MALLOC_STATS_1 = __importDefault(require_MEMORY_MALLOC_STATS());
  var MEMORY_PURGE_1 = __importDefault(require_MEMORY_PURGE());
  var MEMORY_STATS_1 = __importDefault(require_MEMORY_STATS());
  var MEMORY_USAGE_1 = __importDefault(require_MEMORY_USAGE());
  var MGET_1 = __importDefault(require_MGET());
  var MIGRATE_1 = __importDefault(require_MIGRATE());
  var MODULE_LIST_1 = __importDefault(require_MODULE_LIST());
  var MODULE_LOAD_1 = __importDefault(require_MODULE_LOAD());
  var MODULE_UNLOAD_1 = __importDefault(require_MODULE_UNLOAD());
  var MOVE_1 = __importDefault(require_MOVE());
  var MSET_1 = __importDefault(require_MSET());
  var MSETNX_1 = __importDefault(require_MSETNX());
  var OBJECT_ENCODING_1 = __importDefault(require_OBJECT_ENCODING());
  var OBJECT_FREQ_1 = __importDefault(require_OBJECT_FREQ());
  var OBJECT_IDLETIME_1 = __importDefault(require_OBJECT_IDLETIME());
  var OBJECT_REFCOUNT_1 = __importDefault(require_OBJECT_REFCOUNT());
  var PERSIST_1 = __importDefault(require_PERSIST());
  var PEXPIRE_1 = __importDefault(require_PEXPIRE());
  var PEXPIREAT_1 = __importDefault(require_PEXPIREAT());
  var PEXPIRETIME_1 = __importDefault(require_PEXPIRETIME());
  var PFADD_1 = __importDefault(require_PFADD());
  var PFCOUNT_1 = __importDefault(require_PFCOUNT());
  var PFMERGE_1 = __importDefault(require_PFMERGE());
  var PING_1 = __importDefault(require_PING());
  var PSETEX_1 = __importDefault(require_PSETEX());
  var PTTL_1 = __importDefault(require_PTTL());
  var PUBLISH_1 = __importDefault(require_PUBLISH());
  var PUBSUB_CHANNELS_1 = __importDefault(require_PUBSUB_CHANNELS());
  var PUBSUB_NUMPAT_1 = __importDefault(require_PUBSUB_NUMPAT());
  var PUBSUB_NUMSUB_1 = __importDefault(require_PUBSUB_NUMSUB());
  var PUBSUB_SHARDNUMSUB_1 = __importDefault(require_PUBSUB_SHARDNUMSUB());
  var PUBSUB_SHARDCHANNELS_1 = __importDefault(require_PUBSUB_SHARDCHANNELS());
  var RANDOMKEY_1 = __importDefault(require_RANDOMKEY());
  var READONLY_1 = __importDefault(require_READONLY());
  var RENAME_1 = __importDefault(require_RENAME());
  var RENAMENX_1 = __importDefault(require_RENAMENX());
  var REPLICAOF_1 = __importDefault(require_REPLICAOF());
  var RESTORE_ASKING_1 = __importDefault(require_RESTORE_ASKING());
  var RESTORE_1 = __importDefault(require_RESTORE());
  var ROLE_1 = __importDefault(require_ROLE());
  var RPOP_COUNT_1 = __importDefault(require_RPOP_COUNT());
  var RPOP_1 = __importDefault(require_RPOP());
  var RPOPLPUSH_1 = __importDefault(require_RPOPLPUSH());
  var RPUSH_1 = __importDefault(require_RPUSH());
  var RPUSHX_1 = __importDefault(require_RPUSHX());
  var SADD_1 = __importDefault(require_SADD());
  var SCAN_1 = __importDefault(require_SCAN());
  var SCARD_1 = __importDefault(require_SCARD());
  var SCRIPT_DEBUG_1 = __importDefault(require_SCRIPT_DEBUG());
  var SCRIPT_EXISTS_1 = __importDefault(require_SCRIPT_EXISTS());
  var SCRIPT_FLUSH_1 = __importDefault(require_SCRIPT_FLUSH());
  var SCRIPT_KILL_1 = __importDefault(require_SCRIPT_KILL());
  var SCRIPT_LOAD_1 = __importDefault(require_SCRIPT_LOAD());
  var SDIFF_1 = __importDefault(require_SDIFF());
  var SDIFFSTORE_1 = __importDefault(require_SDIFFSTORE());
  var SET_1 = __importDefault(require_SET());
  var SETBIT_1 = __importDefault(require_SETBIT());
  var SETEX_1 = __importDefault(require_SETEX());
  var SETNX_1 = __importDefault(require_SETNX());
  var SETRANGE_1 = __importDefault(require_SETRANGE());
  var SINTER_1 = __importDefault(require_SINTER());
  var SINTERCARD_1 = __importDefault(require_SINTERCARD());
  var SINTERSTORE_1 = __importDefault(require_SINTERSTORE());
  var SISMEMBER_1 = __importDefault(require_SISMEMBER());
  var SMEMBERS_1 = __importDefault(require_SMEMBERS());
  var SMISMEMBER_1 = __importDefault(require_SMISMEMBER());
  var SMOVE_1 = __importDefault(require_SMOVE());
  var SORT_RO_1 = __importDefault(require_SORT_RO());
  var SORT_STORE_1 = __importDefault(require_SORT_STORE());
  var SORT_1 = __importDefault(require_SORT());
  var SPOP_COUNT_1 = __importDefault(require_SPOP_COUNT());
  var SPOP_1 = __importDefault(require_SPOP());
  var SPUBLISH_1 = __importDefault(require_SPUBLISH());
  var SRANDMEMBER_COUNT_1 = __importDefault(require_SRANDMEMBER_COUNT());
  var SRANDMEMBER_1 = __importDefault(require_SRANDMEMBER());
  var SREM_1 = __importDefault(require_SREM());
  var SSCAN_1 = __importDefault(require_SSCAN());
  var STRLEN_1 = __importDefault(require_STRLEN());
  var SUNION_1 = __importDefault(require_SUNION());
  var SUNIONSTORE_1 = __importDefault(require_SUNIONSTORE());
  var SWAPDB_1 = __importDefault(require_SWAPDB());
  var TIME_1 = __importDefault(require_TIME());
  var TOUCH_1 = __importDefault(require_TOUCH());
  var TTL_1 = __importDefault(require_TTL());
  var TYPE_1 = __importDefault(require_TYPE());
  var UNLINK_1 = __importDefault(require_UNLINK());
  var WAIT_1 = __importDefault(require_WAIT());
  var XACK_1 = __importDefault(require_XACK());
  var XADD_NOMKSTREAM_1 = __importDefault(require_XADD_NOMKSTREAM());
  var XADD_1 = __importDefault(require_XADD());
  var XAUTOCLAIM_JUSTID_1 = __importDefault(require_XAUTOCLAIM_JUSTID());
  var XAUTOCLAIM_1 = __importDefault(require_XAUTOCLAIM());
  var XCLAIM_JUSTID_1 = __importDefault(require_XCLAIM_JUSTID());
  var XCLAIM_1 = __importDefault(require_XCLAIM());
  var XDEL_1 = __importDefault(require_XDEL());
  var XGROUP_CREATE_1 = __importDefault(require_XGROUP_CREATE());
  var XGROUP_CREATECONSUMER_1 = __importDefault(require_XGROUP_CREATECONSUMER());
  var XGROUP_DELCONSUMER_1 = __importDefault(require_XGROUP_DELCONSUMER());
  var XGROUP_DESTROY_1 = __importDefault(require_XGROUP_DESTROY());
  var XGROUP_SETID_1 = __importDefault(require_XGROUP_SETID());
  var XINFO_CONSUMERS_1 = __importDefault(require_XINFO_CONSUMERS());
  var XINFO_GROUPS_1 = __importDefault(require_XINFO_GROUPS());
  var XINFO_STREAM_1 = __importDefault(require_XINFO_STREAM());
  var XLEN_1 = __importDefault(require_XLEN());
  var XPENDING_RANGE_1 = __importDefault(require_XPENDING_RANGE());
  var XPENDING_1 = __importDefault(require_XPENDING());
  var XRANGE_1 = __importDefault(require_XRANGE());
  var XREAD_1 = __importDefault(require_XREAD());
  var XREADGROUP_1 = __importDefault(require_XREADGROUP());
  var XREVRANGE_1 = __importDefault(require_XREVRANGE());
  var XSETID_1 = __importDefault(require_XSETID());
  var XTRIM_1 = __importDefault(require_XTRIM());
  var ZADD_INCR_1 = __importDefault(require_ZADD_INCR());
  var ZADD_1 = __importDefault(require_ZADD());
  var ZCARD_1 = __importDefault(require_ZCARD());
  var ZCOUNT_1 = __importDefault(require_ZCOUNT());
  var ZDIFF_WITHSCORES_1 = __importDefault(require_ZDIFF_WITHSCORES());
  var ZDIFF_1 = __importDefault(require_ZDIFF());
  var ZDIFFSTORE_1 = __importDefault(require_ZDIFFSTORE());
  var ZINCRBY_1 = __importDefault(require_ZINCRBY());
  var ZINTER_WITHSCORES_1 = __importDefault(require_ZINTER_WITHSCORES());
  var ZINTER_1 = __importDefault(require_ZINTER());
  var ZINTERCARD_1 = __importDefault(require_ZINTERCARD());
  var ZINTERSTORE_1 = __importDefault(require_ZINTERSTORE());
  var ZLEXCOUNT_1 = __importDefault(require_ZLEXCOUNT());
  var ZMPOP_1 = __importDefault(require_ZMPOP());
  var ZMSCORE_1 = __importDefault(require_ZMSCORE());
  var ZPOPMAX_COUNT_1 = __importDefault(require_ZPOPMAX_COUNT());
  var ZPOPMAX_1 = __importDefault(require_ZPOPMAX());
  var ZPOPMIN_COUNT_1 = __importDefault(require_ZPOPMIN_COUNT());
  var ZPOPMIN_1 = __importDefault(require_ZPOPMIN());
  var ZRANDMEMBER_COUNT_WITHSCORES_1 = __importDefault(require_ZRANDMEMBER_COUNT_WITHSCORES());
  var ZRANDMEMBER_COUNT_1 = __importDefault(require_ZRANDMEMBER_COUNT());
  var ZRANDMEMBER_1 = __importDefault(require_ZRANDMEMBER());
  var ZRANGE_WITHSCORES_1 = __importDefault(require_ZRANGE_WITHSCORES());
  var ZRANGE_1 = __importDefault(require_ZRANGE());
  var ZRANGEBYLEX_1 = __importDefault(require_ZRANGEBYLEX());
  var ZRANGEBYSCORE_WITHSCORES_1 = __importDefault(require_ZRANGEBYSCORE_WITHSCORES());
  var ZRANGEBYSCORE_1 = __importDefault(require_ZRANGEBYSCORE());
  var ZRANGESTORE_1 = __importDefault(require_ZRANGESTORE());
  var ZREMRANGEBYSCORE_1 = __importDefault(require_ZREMRANGEBYSCORE());
  var ZRANK_WITHSCORE_1 = __importDefault(require_ZRANK_WITHSCORE());
  var ZRANK_1 = __importDefault(require_ZRANK());
  var ZREM_1 = __importDefault(require_ZREM());
  var ZREMRANGEBYLEX_1 = __importDefault(require_ZREMRANGEBYLEX());
  var ZREMRANGEBYRANK_1 = __importDefault(require_ZREMRANGEBYRANK());
  var ZREVRANK_1 = __importDefault(require_ZREVRANK());
  var ZSCAN_1 = __importDefault(require_ZSCAN());
  var ZSCORE_1 = __importDefault(require_ZSCORE());
  var ZUNION_WITHSCORES_1 = __importDefault(require_ZUNION_WITHSCORES());
  var ZUNION_1 = __importDefault(require_ZUNION());
  var ZUNIONSTORE_1 = __importDefault(require_ZUNIONSTORE());
  var VADD_1 = __importDefault(require_VADD());
  var VCARD_1 = __importDefault(require_VCARD());
  var VDIM_1 = __importDefault(require_VDIM());
  var VEMB_1 = __importDefault(require_VEMB());
  var VEMB_RAW_1 = __importDefault(require_VEMB_RAW());
  var VGETATTR_1 = __importDefault(require_VGETATTR());
  var VINFO_1 = __importDefault(require_VINFO());
  var VLINKS_1 = __importDefault(require_VLINKS());
  var VLINKS_WITHSCORES_1 = __importDefault(require_VLINKS_WITHSCORES());
  var VRANDMEMBER_1 = __importDefault(require_VRANDMEMBER());
  var VREM_1 = __importDefault(require_VREM());
  var VSETATTR_1 = __importDefault(require_VSETATTR());
  var VSIM_1 = __importDefault(require_VSIM());
  var VSIM_WITHSCORES_1 = __importDefault(require_VSIM_WITHSCORES());
  exports.default = {
    ACL_CAT: ACL_CAT_1.default,
    aclCat: ACL_CAT_1.default,
    ACL_DELUSER: ACL_DELUSER_1.default,
    aclDelUser: ACL_DELUSER_1.default,
    ACL_DRYRUN: ACL_DRYRUN_1.default,
    aclDryRun: ACL_DRYRUN_1.default,
    ACL_GENPASS: ACL_GENPASS_1.default,
    aclGenPass: ACL_GENPASS_1.default,
    ACL_GETUSER: ACL_GETUSER_1.default,
    aclGetUser: ACL_GETUSER_1.default,
    ACL_LIST: ACL_LIST_1.default,
    aclList: ACL_LIST_1.default,
    ACL_LOAD: ACL_LOAD_1.default,
    aclLoad: ACL_LOAD_1.default,
    ACL_LOG_RESET: ACL_LOG_RESET_1.default,
    aclLogReset: ACL_LOG_RESET_1.default,
    ACL_LOG: ACL_LOG_1.default,
    aclLog: ACL_LOG_1.default,
    ACL_SAVE: ACL_SAVE_1.default,
    aclSave: ACL_SAVE_1.default,
    ACL_SETUSER: ACL_SETUSER_1.default,
    aclSetUser: ACL_SETUSER_1.default,
    ACL_USERS: ACL_USERS_1.default,
    aclUsers: ACL_USERS_1.default,
    ACL_WHOAMI: ACL_WHOAMI_1.default,
    aclWhoAmI: ACL_WHOAMI_1.default,
    APPEND: APPEND_1.default,
    append: APPEND_1.default,
    ASKING: ASKING_1.default,
    asking: ASKING_1.default,
    AUTH: AUTH_1.default,
    auth: AUTH_1.default,
    BGREWRITEAOF: BGREWRITEAOF_1.default,
    bgRewriteAof: BGREWRITEAOF_1.default,
    BGSAVE: BGSAVE_1.default,
    bgSave: BGSAVE_1.default,
    BITCOUNT: BITCOUNT_1.default,
    bitCount: BITCOUNT_1.default,
    BITFIELD_RO: BITFIELD_RO_1.default,
    bitFieldRo: BITFIELD_RO_1.default,
    BITFIELD: BITFIELD_1.default,
    bitField: BITFIELD_1.default,
    BITOP: BITOP_1.default,
    bitOp: BITOP_1.default,
    BITPOS: BITPOS_1.default,
    bitPos: BITPOS_1.default,
    BLMOVE: BLMOVE_1.default,
    blMove: BLMOVE_1.default,
    BLMPOP: BLMPOP_1.default,
    blmPop: BLMPOP_1.default,
    BLPOP: BLPOP_1.default,
    blPop: BLPOP_1.default,
    BRPOP: BRPOP_1.default,
    brPop: BRPOP_1.default,
    BRPOPLPUSH: BRPOPLPUSH_1.default,
    brPopLPush: BRPOPLPUSH_1.default,
    BZMPOP: BZMPOP_1.default,
    bzmPop: BZMPOP_1.default,
    BZPOPMAX: BZPOPMAX_1.default,
    bzPopMax: BZPOPMAX_1.default,
    BZPOPMIN: BZPOPMIN_1.default,
    bzPopMin: BZPOPMIN_1.default,
    CLIENT_CACHING: CLIENT_CACHING_1.default,
    clientCaching: CLIENT_CACHING_1.default,
    CLIENT_GETNAME: CLIENT_GETNAME_1.default,
    clientGetName: CLIENT_GETNAME_1.default,
    CLIENT_GETREDIR: CLIENT_GETREDIR_1.default,
    clientGetRedir: CLIENT_GETREDIR_1.default,
    CLIENT_ID: CLIENT_ID_1.default,
    clientId: CLIENT_ID_1.default,
    CLIENT_INFO: CLIENT_INFO_1.default,
    clientInfo: CLIENT_INFO_1.default,
    CLIENT_KILL: CLIENT_KILL_1.default,
    clientKill: CLIENT_KILL_1.default,
    CLIENT_LIST: CLIENT_LIST_1.default,
    clientList: CLIENT_LIST_1.default,
    "CLIENT_NO-EVICT": CLIENT_NO_EVICT_1.default,
    clientNoEvict: CLIENT_NO_EVICT_1.default,
    "CLIENT_NO-TOUCH": CLIENT_NO_TOUCH_1.default,
    clientNoTouch: CLIENT_NO_TOUCH_1.default,
    CLIENT_PAUSE: CLIENT_PAUSE_1.default,
    clientPause: CLIENT_PAUSE_1.default,
    CLIENT_SETNAME: CLIENT_SETNAME_1.default,
    clientSetName: CLIENT_SETNAME_1.default,
    CLIENT_TRACKING: CLIENT_TRACKING_1.default,
    clientTracking: CLIENT_TRACKING_1.default,
    CLIENT_TRACKINGINFO: CLIENT_TRACKINGINFO_1.default,
    clientTrackingInfo: CLIENT_TRACKINGINFO_1.default,
    CLIENT_UNPAUSE: CLIENT_UNPAUSE_1.default,
    clientUnpause: CLIENT_UNPAUSE_1.default,
    CLUSTER_ADDSLOTS: CLUSTER_ADDSLOTS_1.default,
    clusterAddSlots: CLUSTER_ADDSLOTS_1.default,
    CLUSTER_ADDSLOTSRANGE: CLUSTER_ADDSLOTSRANGE_1.default,
    clusterAddSlotsRange: CLUSTER_ADDSLOTSRANGE_1.default,
    CLUSTER_BUMPEPOCH: CLUSTER_BUMPEPOCH_1.default,
    clusterBumpEpoch: CLUSTER_BUMPEPOCH_1.default,
    "CLUSTER_COUNT-FAILURE-REPORTS": CLUSTER_COUNT_FAILURE_REPORTS_1.default,
    clusterCountFailureReports: CLUSTER_COUNT_FAILURE_REPORTS_1.default,
    CLUSTER_COUNTKEYSINSLOT: CLUSTER_COUNTKEYSINSLOT_1.default,
    clusterCountKeysInSlot: CLUSTER_COUNTKEYSINSLOT_1.default,
    CLUSTER_DELSLOTS: CLUSTER_DELSLOTS_1.default,
    clusterDelSlots: CLUSTER_DELSLOTS_1.default,
    CLUSTER_DELSLOTSRANGE: CLUSTER_DELSLOTSRANGE_1.default,
    clusterDelSlotsRange: CLUSTER_DELSLOTSRANGE_1.default,
    CLUSTER_FAILOVER: CLUSTER_FAILOVER_1.default,
    clusterFailover: CLUSTER_FAILOVER_1.default,
    CLUSTER_FLUSHSLOTS: CLUSTER_FLUSHSLOTS_1.default,
    clusterFlushSlots: CLUSTER_FLUSHSLOTS_1.default,
    CLUSTER_FORGET: CLUSTER_FORGET_1.default,
    clusterForget: CLUSTER_FORGET_1.default,
    CLUSTER_GETKEYSINSLOT: CLUSTER_GETKEYSINSLOT_1.default,
    clusterGetKeysInSlot: CLUSTER_GETKEYSINSLOT_1.default,
    CLUSTER_INFO: CLUSTER_INFO_1.default,
    clusterInfo: CLUSTER_INFO_1.default,
    CLUSTER_KEYSLOT: CLUSTER_KEYSLOT_1.default,
    clusterKeySlot: CLUSTER_KEYSLOT_1.default,
    CLUSTER_LINKS: CLUSTER_LINKS_1.default,
    clusterLinks: CLUSTER_LINKS_1.default,
    CLUSTER_MEET: CLUSTER_MEET_1.default,
    clusterMeet: CLUSTER_MEET_1.default,
    CLUSTER_MYID: CLUSTER_MYID_1.default,
    clusterMyId: CLUSTER_MYID_1.default,
    CLUSTER_MYSHARDID: CLUSTER_MYSHARDID_1.default,
    clusterMyShardId: CLUSTER_MYSHARDID_1.default,
    CLUSTER_NODES: CLUSTER_NODES_1.default,
    clusterNodes: CLUSTER_NODES_1.default,
    CLUSTER_REPLICAS: CLUSTER_REPLICAS_1.default,
    clusterReplicas: CLUSTER_REPLICAS_1.default,
    CLUSTER_REPLICATE: CLUSTER_REPLICATE_1.default,
    clusterReplicate: CLUSTER_REPLICATE_1.default,
    CLUSTER_RESET: CLUSTER_RESET_1.default,
    clusterReset: CLUSTER_RESET_1.default,
    CLUSTER_SAVECONFIG: CLUSTER_SAVECONFIG_1.default,
    clusterSaveConfig: CLUSTER_SAVECONFIG_1.default,
    "CLUSTER_SET-CONFIG-EPOCH": CLUSTER_SET_CONFIG_EPOCH_1.default,
    clusterSetConfigEpoch: CLUSTER_SET_CONFIG_EPOCH_1.default,
    CLUSTER_SETSLOT: CLUSTER_SETSLOT_1.default,
    clusterSetSlot: CLUSTER_SETSLOT_1.default,
    CLUSTER_SLOTS: CLUSTER_SLOTS_1.default,
    clusterSlots: CLUSTER_SLOTS_1.default,
    COMMAND_COUNT: COMMAND_COUNT_1.default,
    commandCount: COMMAND_COUNT_1.default,
    COMMAND_GETKEYS: COMMAND_GETKEYS_1.default,
    commandGetKeys: COMMAND_GETKEYS_1.default,
    COMMAND_GETKEYSANDFLAGS: COMMAND_GETKEYSANDFLAGS_1.default,
    commandGetKeysAndFlags: COMMAND_GETKEYSANDFLAGS_1.default,
    COMMAND_INFO: COMMAND_INFO_1.default,
    commandInfo: COMMAND_INFO_1.default,
    COMMAND_LIST: COMMAND_LIST_1.default,
    commandList: COMMAND_LIST_1.default,
    COMMAND: COMMAND_1.default,
    command: COMMAND_1.default,
    CONFIG_GET: CONFIG_GET_1.default,
    configGet: CONFIG_GET_1.default,
    CONFIG_RESETASTAT: CONFIG_RESETSTAT_1.default,
    configResetStat: CONFIG_RESETSTAT_1.default,
    CONFIG_REWRITE: CONFIG_REWRITE_1.default,
    configRewrite: CONFIG_REWRITE_1.default,
    CONFIG_SET: CONFIG_SET_1.default,
    configSet: CONFIG_SET_1.default,
    COPY: COPY_1.default,
    copy: COPY_1.default,
    DBSIZE: DBSIZE_1.default,
    dbSize: DBSIZE_1.default,
    DECR: DECR_1.default,
    decr: DECR_1.default,
    DECRBY: DECRBY_1.default,
    decrBy: DECRBY_1.default,
    DEL: DEL_1.default,
    del: DEL_1.default,
    DUMP: DUMP_1.default,
    dump: DUMP_1.default,
    ECHO: ECHO_1.default,
    echo: ECHO_1.default,
    EVAL_RO: EVAL_RO_1.default,
    evalRo: EVAL_RO_1.default,
    EVAL: EVAL_1.default,
    eval: EVAL_1.default,
    EVALSHA_RO: EVALSHA_RO_1.default,
    evalShaRo: EVALSHA_RO_1.default,
    EVALSHA: EVALSHA_1.default,
    evalSha: EVALSHA_1.default,
    EXISTS: EXISTS_1.default,
    exists: EXISTS_1.default,
    EXPIRE: EXPIRE_1.default,
    expire: EXPIRE_1.default,
    EXPIREAT: EXPIREAT_1.default,
    expireAt: EXPIREAT_1.default,
    EXPIRETIME: EXPIRETIME_1.default,
    expireTime: EXPIRETIME_1.default,
    FLUSHALL: FLUSHALL_1.default,
    flushAll: FLUSHALL_1.default,
    FLUSHDB: FLUSHDB_1.default,
    flushDb: FLUSHDB_1.default,
    FCALL: FCALL_1.default,
    fCall: FCALL_1.default,
    FCALL_RO: FCALL_RO_1.default,
    fCallRo: FCALL_RO_1.default,
    FUNCTION_DELETE: FUNCTION_DELETE_1.default,
    functionDelete: FUNCTION_DELETE_1.default,
    FUNCTION_DUMP: FUNCTION_DUMP_1.default,
    functionDump: FUNCTION_DUMP_1.default,
    FUNCTION_FLUSH: FUNCTION_FLUSH_1.default,
    functionFlush: FUNCTION_FLUSH_1.default,
    FUNCTION_KILL: FUNCTION_KILL_1.default,
    functionKill: FUNCTION_KILL_1.default,
    FUNCTION_LIST_WITHCODE: FUNCTION_LIST_WITHCODE_1.default,
    functionListWithCode: FUNCTION_LIST_WITHCODE_1.default,
    FUNCTION_LIST: FUNCTION_LIST_1.default,
    functionList: FUNCTION_LIST_1.default,
    FUNCTION_LOAD: FUNCTION_LOAD_1.default,
    functionLoad: FUNCTION_LOAD_1.default,
    FUNCTION_RESTORE: FUNCTION_RESTORE_1.default,
    functionRestore: FUNCTION_RESTORE_1.default,
    FUNCTION_STATS: FUNCTION_STATS_1.default,
    functionStats: FUNCTION_STATS_1.default,
    GEOADD: GEOADD_1.default,
    geoAdd: GEOADD_1.default,
    GEODIST: GEODIST_1.default,
    geoDist: GEODIST_1.default,
    GEOHASH: GEOHASH_1.default,
    geoHash: GEOHASH_1.default,
    GEOPOS: GEOPOS_1.default,
    geoPos: GEOPOS_1.default,
    GEORADIUS_RO_WITH: GEORADIUS_RO_WITH_1.default,
    geoRadiusRoWith: GEORADIUS_RO_WITH_1.default,
    GEORADIUS_RO: GEORADIUS_RO_1.default,
    geoRadiusRo: GEORADIUS_RO_1.default,
    GEORADIUS_STORE: GEORADIUS_STORE_1.default,
    geoRadiusStore: GEORADIUS_STORE_1.default,
    GEORADIUS_WITH: GEORADIUS_WITH_1.default,
    geoRadiusWith: GEORADIUS_WITH_1.default,
    GEORADIUS: GEORADIUS_1.default,
    geoRadius: GEORADIUS_1.default,
    GEORADIUSBYMEMBER_RO_WITH: GEORADIUSBYMEMBER_RO_WITH_1.default,
    geoRadiusByMemberRoWith: GEORADIUSBYMEMBER_RO_WITH_1.default,
    GEORADIUSBYMEMBER_RO: GEORADIUSBYMEMBER_RO_1.default,
    geoRadiusByMemberRo: GEORADIUSBYMEMBER_RO_1.default,
    GEORADIUSBYMEMBER_STORE: GEORADIUSBYMEMBER_STORE_1.default,
    geoRadiusByMemberStore: GEORADIUSBYMEMBER_STORE_1.default,
    GEORADIUSBYMEMBER_WITH: GEORADIUSBYMEMBER_WITH_1.default,
    geoRadiusByMemberWith: GEORADIUSBYMEMBER_WITH_1.default,
    GEORADIUSBYMEMBER: GEORADIUSBYMEMBER_1.default,
    geoRadiusByMember: GEORADIUSBYMEMBER_1.default,
    GEOSEARCH_WITH: GEOSEARCH_WITH_1.default,
    geoSearchWith: GEOSEARCH_WITH_1.default,
    GEOSEARCH: GEOSEARCH_1.default,
    geoSearch: GEOSEARCH_1.default,
    GEOSEARCHSTORE: GEOSEARCHSTORE_1.default,
    geoSearchStore: GEOSEARCHSTORE_1.default,
    GET: GET_1.default,
    get: GET_1.default,
    GETBIT: GETBIT_1.default,
    getBit: GETBIT_1.default,
    GETDEL: GETDEL_1.default,
    getDel: GETDEL_1.default,
    GETEX: GETEX_1.default,
    getEx: GETEX_1.default,
    GETRANGE: GETRANGE_1.default,
    getRange: GETRANGE_1.default,
    GETSET: GETSET_1.default,
    getSet: GETSET_1.default,
    HDEL: HDEL_1.default,
    hDel: HDEL_1.default,
    HELLO: HELLO_1.default,
    hello: HELLO_1.default,
    HEXISTS: HEXISTS_1.default,
    hExists: HEXISTS_1.default,
    HEXPIRE: HEXPIRE_1.default,
    hExpire: HEXPIRE_1.default,
    HEXPIREAT: HEXPIREAT_1.default,
    hExpireAt: HEXPIREAT_1.default,
    HEXPIRETIME: HEXPIRETIME_1.default,
    hExpireTime: HEXPIRETIME_1.default,
    HGET: HGET_1.default,
    hGet: HGET_1.default,
    HGETALL: HGETALL_1.default,
    hGetAll: HGETALL_1.default,
    HGETDEL: HGETDEL_1.default,
    hGetDel: HGETDEL_1.default,
    HGETEX: HGETEX_1.default,
    hGetEx: HGETEX_1.default,
    HINCRBY: HINCRBY_1.default,
    hIncrBy: HINCRBY_1.default,
    HINCRBYFLOAT: HINCRBYFLOAT_1.default,
    hIncrByFloat: HINCRBYFLOAT_1.default,
    HKEYS: HKEYS_1.default,
    hKeys: HKEYS_1.default,
    HLEN: HLEN_1.default,
    hLen: HLEN_1.default,
    HMGET: HMGET_1.default,
    hmGet: HMGET_1.default,
    HPERSIST: HPERSIST_1.default,
    hPersist: HPERSIST_1.default,
    HPEXPIRE: HPEXPIRE_1.default,
    hpExpire: HPEXPIRE_1.default,
    HPEXPIREAT: HPEXPIREAT_1.default,
    hpExpireAt: HPEXPIREAT_1.default,
    HPEXPIRETIME: HPEXPIRETIME_1.default,
    hpExpireTime: HPEXPIRETIME_1.default,
    HPTTL: HPTTL_1.default,
    hpTTL: HPTTL_1.default,
    HRANDFIELD_COUNT_WITHVALUES: HRANDFIELD_COUNT_WITHVALUES_1.default,
    hRandFieldCountWithValues: HRANDFIELD_COUNT_WITHVALUES_1.default,
    HRANDFIELD_COUNT: HRANDFIELD_COUNT_1.default,
    hRandFieldCount: HRANDFIELD_COUNT_1.default,
    HRANDFIELD: HRANDFIELD_1.default,
    hRandField: HRANDFIELD_1.default,
    HSCAN: HSCAN_1.default,
    hScan: HSCAN_1.default,
    HSCAN_NOVALUES: HSCAN_NOVALUES_1.default,
    hScanNoValues: HSCAN_NOVALUES_1.default,
    HSET: HSET_1.default,
    hSet: HSET_1.default,
    HSETEX: HSETEX_1.default,
    hSetEx: HSETEX_1.default,
    HSETNX: HSETNX_1.default,
    hSetNX: HSETNX_1.default,
    HSTRLEN: HSTRLEN_1.default,
    hStrLen: HSTRLEN_1.default,
    HTTL: HTTL_1.default,
    hTTL: HTTL_1.default,
    HVALS: HVALS_1.default,
    hVals: HVALS_1.default,
    INCR: INCR_1.default,
    incr: INCR_1.default,
    INCRBY: INCRBY_1.default,
    incrBy: INCRBY_1.default,
    INCRBYFLOAT: INCRBYFLOAT_1.default,
    incrByFloat: INCRBYFLOAT_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    KEYS: KEYS_1.default,
    keys: KEYS_1.default,
    LASTSAVE: LASTSAVE_1.default,
    lastSave: LASTSAVE_1.default,
    LATENCY_DOCTOR: LATENCY_DOCTOR_1.default,
    latencyDoctor: LATENCY_DOCTOR_1.default,
    LATENCY_GRAPH: LATENCY_GRAPH_1.default,
    latencyGraph: LATENCY_GRAPH_1.default,
    LATENCY_HISTORY: LATENCY_HISTORY_1.default,
    latencyHistory: LATENCY_HISTORY_1.default,
    LATENCY_LATEST: LATENCY_LATEST_1.default,
    latencyLatest: LATENCY_LATEST_1.default,
    LCS_IDX_WITHMATCHLEN: LCS_IDX_WITHMATCHLEN_1.default,
    lcsIdxWithMatchLen: LCS_IDX_WITHMATCHLEN_1.default,
    LCS_IDX: LCS_IDX_1.default,
    lcsIdx: LCS_IDX_1.default,
    LCS_LEN: LCS_LEN_1.default,
    lcsLen: LCS_LEN_1.default,
    LCS: LCS_1.default,
    lcs: LCS_1.default,
    LINDEX: LINDEX_1.default,
    lIndex: LINDEX_1.default,
    LINSERT: LINSERT_1.default,
    lInsert: LINSERT_1.default,
    LLEN: LLEN_1.default,
    lLen: LLEN_1.default,
    LMOVE: LMOVE_1.default,
    lMove: LMOVE_1.default,
    LMPOP: LMPOP_1.default,
    lmPop: LMPOP_1.default,
    LOLWUT: LOLWUT_1.default,
    LPOP_COUNT: LPOP_COUNT_1.default,
    lPopCount: LPOP_COUNT_1.default,
    LPOP: LPOP_1.default,
    lPop: LPOP_1.default,
    LPOS_COUNT: LPOS_COUNT_1.default,
    lPosCount: LPOS_COUNT_1.default,
    LPOS: LPOS_1.default,
    lPos: LPOS_1.default,
    LPUSH: LPUSH_1.default,
    lPush: LPUSH_1.default,
    LPUSHX: LPUSHX_1.default,
    lPushX: LPUSHX_1.default,
    LRANGE: LRANGE_1.default,
    lRange: LRANGE_1.default,
    LREM: LREM_1.default,
    lRem: LREM_1.default,
    LSET: LSET_1.default,
    lSet: LSET_1.default,
    LTRIM: LTRIM_1.default,
    lTrim: LTRIM_1.default,
    MEMORY_DOCTOR: MEMORY_DOCTOR_1.default,
    memoryDoctor: MEMORY_DOCTOR_1.default,
    "MEMORY_MALLOC-STATS": MEMORY_MALLOC_STATS_1.default,
    memoryMallocStats: MEMORY_MALLOC_STATS_1.default,
    MEMORY_PURGE: MEMORY_PURGE_1.default,
    memoryPurge: MEMORY_PURGE_1.default,
    MEMORY_STATS: MEMORY_STATS_1.default,
    memoryStats: MEMORY_STATS_1.default,
    MEMORY_USAGE: MEMORY_USAGE_1.default,
    memoryUsage: MEMORY_USAGE_1.default,
    MGET: MGET_1.default,
    mGet: MGET_1.default,
    MIGRATE: MIGRATE_1.default,
    migrate: MIGRATE_1.default,
    MODULE_LIST: MODULE_LIST_1.default,
    moduleList: MODULE_LIST_1.default,
    MODULE_LOAD: MODULE_LOAD_1.default,
    moduleLoad: MODULE_LOAD_1.default,
    MODULE_UNLOAD: MODULE_UNLOAD_1.default,
    moduleUnload: MODULE_UNLOAD_1.default,
    MOVE: MOVE_1.default,
    move: MOVE_1.default,
    MSET: MSET_1.default,
    mSet: MSET_1.default,
    MSETNX: MSETNX_1.default,
    mSetNX: MSETNX_1.default,
    OBJECT_ENCODING: OBJECT_ENCODING_1.default,
    objectEncoding: OBJECT_ENCODING_1.default,
    OBJECT_FREQ: OBJECT_FREQ_1.default,
    objectFreq: OBJECT_FREQ_1.default,
    OBJECT_IDLETIME: OBJECT_IDLETIME_1.default,
    objectIdleTime: OBJECT_IDLETIME_1.default,
    OBJECT_REFCOUNT: OBJECT_REFCOUNT_1.default,
    objectRefCount: OBJECT_REFCOUNT_1.default,
    PERSIST: PERSIST_1.default,
    persist: PERSIST_1.default,
    PEXPIRE: PEXPIRE_1.default,
    pExpire: PEXPIRE_1.default,
    PEXPIREAT: PEXPIREAT_1.default,
    pExpireAt: PEXPIREAT_1.default,
    PEXPIRETIME: PEXPIRETIME_1.default,
    pExpireTime: PEXPIRETIME_1.default,
    PFADD: PFADD_1.default,
    pfAdd: PFADD_1.default,
    PFCOUNT: PFCOUNT_1.default,
    pfCount: PFCOUNT_1.default,
    PFMERGE: PFMERGE_1.default,
    pfMerge: PFMERGE_1.default,
    PING: PING_1.default,
    ping: PING_1.default,
    PSETEX: PSETEX_1.default,
    pSetEx: PSETEX_1.default,
    PTTL: PTTL_1.default,
    pTTL: PTTL_1.default,
    PUBLISH: PUBLISH_1.default,
    publish: PUBLISH_1.default,
    PUBSUB_CHANNELS: PUBSUB_CHANNELS_1.default,
    pubSubChannels: PUBSUB_CHANNELS_1.default,
    PUBSUB_NUMPAT: PUBSUB_NUMPAT_1.default,
    pubSubNumPat: PUBSUB_NUMPAT_1.default,
    PUBSUB_NUMSUB: PUBSUB_NUMSUB_1.default,
    pubSubNumSub: PUBSUB_NUMSUB_1.default,
    PUBSUB_SHARDNUMSUB: PUBSUB_SHARDNUMSUB_1.default,
    pubSubShardNumSub: PUBSUB_SHARDNUMSUB_1.default,
    PUBSUB_SHARDCHANNELS: PUBSUB_SHARDCHANNELS_1.default,
    pubSubShardChannels: PUBSUB_SHARDCHANNELS_1.default,
    RANDOMKEY: RANDOMKEY_1.default,
    randomKey: RANDOMKEY_1.default,
    READONLY: READONLY_1.default,
    readonly: READONLY_1.default,
    RENAME: RENAME_1.default,
    rename: RENAME_1.default,
    RENAMENX: RENAMENX_1.default,
    renameNX: RENAMENX_1.default,
    REPLICAOF: REPLICAOF_1.default,
    replicaOf: REPLICAOF_1.default,
    "RESTORE-ASKING": RESTORE_ASKING_1.default,
    restoreAsking: RESTORE_ASKING_1.default,
    RESTORE: RESTORE_1.default,
    restore: RESTORE_1.default,
    RPOP_COUNT: RPOP_COUNT_1.default,
    rPopCount: RPOP_COUNT_1.default,
    ROLE: ROLE_1.default,
    role: ROLE_1.default,
    RPOP: RPOP_1.default,
    rPop: RPOP_1.default,
    RPOPLPUSH: RPOPLPUSH_1.default,
    rPopLPush: RPOPLPUSH_1.default,
    RPUSH: RPUSH_1.default,
    rPush: RPUSH_1.default,
    RPUSHX: RPUSHX_1.default,
    rPushX: RPUSHX_1.default,
    SADD: SADD_1.default,
    sAdd: SADD_1.default,
    SCAN: SCAN_1.default,
    scan: SCAN_1.default,
    SCARD: SCARD_1.default,
    sCard: SCARD_1.default,
    SCRIPT_DEBUG: SCRIPT_DEBUG_1.default,
    scriptDebug: SCRIPT_DEBUG_1.default,
    SCRIPT_EXISTS: SCRIPT_EXISTS_1.default,
    scriptExists: SCRIPT_EXISTS_1.default,
    SCRIPT_FLUSH: SCRIPT_FLUSH_1.default,
    scriptFlush: SCRIPT_FLUSH_1.default,
    SCRIPT_KILL: SCRIPT_KILL_1.default,
    scriptKill: SCRIPT_KILL_1.default,
    SCRIPT_LOAD: SCRIPT_LOAD_1.default,
    scriptLoad: SCRIPT_LOAD_1.default,
    SDIFF: SDIFF_1.default,
    sDiff: SDIFF_1.default,
    SDIFFSTORE: SDIFFSTORE_1.default,
    sDiffStore: SDIFFSTORE_1.default,
    SET: SET_1.default,
    set: SET_1.default,
    SETBIT: SETBIT_1.default,
    setBit: SETBIT_1.default,
    SETEX: SETEX_1.default,
    setEx: SETEX_1.default,
    SETNX: SETNX_1.default,
    setNX: SETNX_1.default,
    SETRANGE: SETRANGE_1.default,
    setRange: SETRANGE_1.default,
    SINTER: SINTER_1.default,
    sInter: SINTER_1.default,
    SINTERCARD: SINTERCARD_1.default,
    sInterCard: SINTERCARD_1.default,
    SINTERSTORE: SINTERSTORE_1.default,
    sInterStore: SINTERSTORE_1.default,
    SISMEMBER: SISMEMBER_1.default,
    sIsMember: SISMEMBER_1.default,
    SMEMBERS: SMEMBERS_1.default,
    sMembers: SMEMBERS_1.default,
    SMISMEMBER: SMISMEMBER_1.default,
    smIsMember: SMISMEMBER_1.default,
    SMOVE: SMOVE_1.default,
    sMove: SMOVE_1.default,
    SORT_RO: SORT_RO_1.default,
    sortRo: SORT_RO_1.default,
    SORT_STORE: SORT_STORE_1.default,
    sortStore: SORT_STORE_1.default,
    SORT: SORT_1.default,
    sort: SORT_1.default,
    SPOP_COUNT: SPOP_COUNT_1.default,
    sPopCount: SPOP_COUNT_1.default,
    SPOP: SPOP_1.default,
    sPop: SPOP_1.default,
    SPUBLISH: SPUBLISH_1.default,
    sPublish: SPUBLISH_1.default,
    SRANDMEMBER_COUNT: SRANDMEMBER_COUNT_1.default,
    sRandMemberCount: SRANDMEMBER_COUNT_1.default,
    SRANDMEMBER: SRANDMEMBER_1.default,
    sRandMember: SRANDMEMBER_1.default,
    SREM: SREM_1.default,
    sRem: SREM_1.default,
    SSCAN: SSCAN_1.default,
    sScan: SSCAN_1.default,
    STRLEN: STRLEN_1.default,
    strLen: STRLEN_1.default,
    SUNION: SUNION_1.default,
    sUnion: SUNION_1.default,
    SUNIONSTORE: SUNIONSTORE_1.default,
    sUnionStore: SUNIONSTORE_1.default,
    SWAPDB: SWAPDB_1.default,
    swapDb: SWAPDB_1.default,
    TIME: TIME_1.default,
    time: TIME_1.default,
    TOUCH: TOUCH_1.default,
    touch: TOUCH_1.default,
    TTL: TTL_1.default,
    ttl: TTL_1.default,
    TYPE: TYPE_1.default,
    type: TYPE_1.default,
    UNLINK: UNLINK_1.default,
    unlink: UNLINK_1.default,
    WAIT: WAIT_1.default,
    wait: WAIT_1.default,
    XACK: XACK_1.default,
    xAck: XACK_1.default,
    XADD_NOMKSTREAM: XADD_NOMKSTREAM_1.default,
    xAddNoMkStream: XADD_NOMKSTREAM_1.default,
    XADD: XADD_1.default,
    xAdd: XADD_1.default,
    XAUTOCLAIM_JUSTID: XAUTOCLAIM_JUSTID_1.default,
    xAutoClaimJustId: XAUTOCLAIM_JUSTID_1.default,
    XAUTOCLAIM: XAUTOCLAIM_1.default,
    xAutoClaim: XAUTOCLAIM_1.default,
    XCLAIM_JUSTID: XCLAIM_JUSTID_1.default,
    xClaimJustId: XCLAIM_JUSTID_1.default,
    XCLAIM: XCLAIM_1.default,
    xClaim: XCLAIM_1.default,
    XDEL: XDEL_1.default,
    xDel: XDEL_1.default,
    XGROUP_CREATE: XGROUP_CREATE_1.default,
    xGroupCreate: XGROUP_CREATE_1.default,
    XGROUP_CREATECONSUMER: XGROUP_CREATECONSUMER_1.default,
    xGroupCreateConsumer: XGROUP_CREATECONSUMER_1.default,
    XGROUP_DELCONSUMER: XGROUP_DELCONSUMER_1.default,
    xGroupDelConsumer: XGROUP_DELCONSUMER_1.default,
    XGROUP_DESTROY: XGROUP_DESTROY_1.default,
    xGroupDestroy: XGROUP_DESTROY_1.default,
    XGROUP_SETID: XGROUP_SETID_1.default,
    xGroupSetId: XGROUP_SETID_1.default,
    XINFO_CONSUMERS: XINFO_CONSUMERS_1.default,
    xInfoConsumers: XINFO_CONSUMERS_1.default,
    XINFO_GROUPS: XINFO_GROUPS_1.default,
    xInfoGroups: XINFO_GROUPS_1.default,
    XINFO_STREAM: XINFO_STREAM_1.default,
    xInfoStream: XINFO_STREAM_1.default,
    XLEN: XLEN_1.default,
    xLen: XLEN_1.default,
    XPENDING_RANGE: XPENDING_RANGE_1.default,
    xPendingRange: XPENDING_RANGE_1.default,
    XPENDING: XPENDING_1.default,
    xPending: XPENDING_1.default,
    XRANGE: XRANGE_1.default,
    xRange: XRANGE_1.default,
    XREAD: XREAD_1.default,
    xRead: XREAD_1.default,
    XREADGROUP: XREADGROUP_1.default,
    xReadGroup: XREADGROUP_1.default,
    XREVRANGE: XREVRANGE_1.default,
    xRevRange: XREVRANGE_1.default,
    XSETID: XSETID_1.default,
    xSetId: XSETID_1.default,
    XTRIM: XTRIM_1.default,
    xTrim: XTRIM_1.default,
    ZADD_INCR: ZADD_INCR_1.default,
    zAddIncr: ZADD_INCR_1.default,
    ZADD: ZADD_1.default,
    zAdd: ZADD_1.default,
    ZCARD: ZCARD_1.default,
    zCard: ZCARD_1.default,
    ZCOUNT: ZCOUNT_1.default,
    zCount: ZCOUNT_1.default,
    ZDIFF_WITHSCORES: ZDIFF_WITHSCORES_1.default,
    zDiffWithScores: ZDIFF_WITHSCORES_1.default,
    ZDIFF: ZDIFF_1.default,
    zDiff: ZDIFF_1.default,
    ZDIFFSTORE: ZDIFFSTORE_1.default,
    zDiffStore: ZDIFFSTORE_1.default,
    ZINCRBY: ZINCRBY_1.default,
    zIncrBy: ZINCRBY_1.default,
    ZINTER_WITHSCORES: ZINTER_WITHSCORES_1.default,
    zInterWithScores: ZINTER_WITHSCORES_1.default,
    ZINTER: ZINTER_1.default,
    zInter: ZINTER_1.default,
    ZINTERCARD: ZINTERCARD_1.default,
    zInterCard: ZINTERCARD_1.default,
    ZINTERSTORE: ZINTERSTORE_1.default,
    zInterStore: ZINTERSTORE_1.default,
    ZLEXCOUNT: ZLEXCOUNT_1.default,
    zLexCount: ZLEXCOUNT_1.default,
    ZMPOP: ZMPOP_1.default,
    zmPop: ZMPOP_1.default,
    ZMSCORE: ZMSCORE_1.default,
    zmScore: ZMSCORE_1.default,
    ZPOPMAX_COUNT: ZPOPMAX_COUNT_1.default,
    zPopMaxCount: ZPOPMAX_COUNT_1.default,
    ZPOPMAX: ZPOPMAX_1.default,
    zPopMax: ZPOPMAX_1.default,
    ZPOPMIN_COUNT: ZPOPMIN_COUNT_1.default,
    zPopMinCount: ZPOPMIN_COUNT_1.default,
    ZPOPMIN: ZPOPMIN_1.default,
    zPopMin: ZPOPMIN_1.default,
    ZRANDMEMBER_COUNT_WITHSCORES: ZRANDMEMBER_COUNT_WITHSCORES_1.default,
    zRandMemberCountWithScores: ZRANDMEMBER_COUNT_WITHSCORES_1.default,
    ZRANDMEMBER_COUNT: ZRANDMEMBER_COUNT_1.default,
    zRandMemberCount: ZRANDMEMBER_COUNT_1.default,
    ZRANDMEMBER: ZRANDMEMBER_1.default,
    zRandMember: ZRANDMEMBER_1.default,
    ZRANGE_WITHSCORES: ZRANGE_WITHSCORES_1.default,
    zRangeWithScores: ZRANGE_WITHSCORES_1.default,
    ZRANGE: ZRANGE_1.default,
    zRange: ZRANGE_1.default,
    ZRANGEBYLEX: ZRANGEBYLEX_1.default,
    zRangeByLex: ZRANGEBYLEX_1.default,
    ZRANGEBYSCORE_WITHSCORES: ZRANGEBYSCORE_WITHSCORES_1.default,
    zRangeByScoreWithScores: ZRANGEBYSCORE_WITHSCORES_1.default,
    ZRANGEBYSCORE: ZRANGEBYSCORE_1.default,
    zRangeByScore: ZRANGEBYSCORE_1.default,
    ZRANGESTORE: ZRANGESTORE_1.default,
    zRangeStore: ZRANGESTORE_1.default,
    ZRANK_WITHSCORE: ZRANK_WITHSCORE_1.default,
    zRankWithScore: ZRANK_WITHSCORE_1.default,
    ZRANK: ZRANK_1.default,
    zRank: ZRANK_1.default,
    ZREM: ZREM_1.default,
    zRem: ZREM_1.default,
    ZREMRANGEBYLEX: ZREMRANGEBYLEX_1.default,
    zRemRangeByLex: ZREMRANGEBYLEX_1.default,
    ZREMRANGEBYRANK: ZREMRANGEBYRANK_1.default,
    zRemRangeByRank: ZREMRANGEBYRANK_1.default,
    ZREMRANGEBYSCORE: ZREMRANGEBYSCORE_1.default,
    zRemRangeByScore: ZREMRANGEBYSCORE_1.default,
    ZREVRANK: ZREVRANK_1.default,
    zRevRank: ZREVRANK_1.default,
    ZSCAN: ZSCAN_1.default,
    zScan: ZSCAN_1.default,
    ZSCORE: ZSCORE_1.default,
    zScore: ZSCORE_1.default,
    ZUNION_WITHSCORES: ZUNION_WITHSCORES_1.default,
    zUnionWithScores: ZUNION_WITHSCORES_1.default,
    ZUNION: ZUNION_1.default,
    zUnion: ZUNION_1.default,
    ZUNIONSTORE: ZUNIONSTORE_1.default,
    zUnionStore: ZUNIONSTORE_1.default,
    VADD: VADD_1.default,
    vAdd: VADD_1.default,
    VCARD: VCARD_1.default,
    vCard: VCARD_1.default,
    VDIM: VDIM_1.default,
    vDim: VDIM_1.default,
    VEMB: VEMB_1.default,
    vEmb: VEMB_1.default,
    VEMB_RAW: VEMB_RAW_1.default,
    vEmbRaw: VEMB_RAW_1.default,
    VGETATTR: VGETATTR_1.default,
    vGetAttr: VGETATTR_1.default,
    VINFO: VINFO_1.default,
    vInfo: VINFO_1.default,
    VLINKS: VLINKS_1.default,
    vLinks: VLINKS_1.default,
    VLINKS_WITHSCORES: VLINKS_WITHSCORES_1.default,
    vLinksWithScores: VLINKS_WITHSCORES_1.default,
    VRANDMEMBER: VRANDMEMBER_1.default,
    vRandMember: VRANDMEMBER_1.default,
    VREM: VREM_1.default,
    vRem: VREM_1.default,
    VSETATTR: VSETATTR_1.default,
    vSetAttr: VSETATTR_1.default,
    VSIM: VSIM_1.default,
    vSim: VSIM_1.default,
    VSIM_WITHSCORES: VSIM_WITHSCORES_1.default,
    vSimWithScores: VSIM_WITHSCORES_1.default
  };
});

// ../../node_modules/@redis/client/dist/lib/client/socket.js
var require_socket = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var node_events_1 = __require("events");
  var node_net_1 = __importDefault(__require("net"));
  var node_tls_1 = __importDefault(__require("tls"));
  var errors_1 = require_errors();
  var promises_1 = __require("timers/promises");

  class RedisSocket extends node_events_1.EventEmitter {
    #initiator;
    #connectTimeout;
    #reconnectStrategy;
    #socketFactory;
    #socketTimeout;
    #socket;
    #isOpen = false;
    get isOpen() {
      return this.#isOpen;
    }
    #isReady = false;
    get isReady() {
      return this.#isReady;
    }
    #isSocketUnrefed = false;
    #socketEpoch = 0;
    get socketEpoch() {
      return this.#socketEpoch;
    }
    constructor(initiator, options) {
      super();
      this.#initiator = initiator;
      this.#connectTimeout = options?.connectTimeout ?? 5000;
      this.#reconnectStrategy = this.#createReconnectStrategy(options);
      this.#socketFactory = this.#createSocketFactory(options);
      this.#socketTimeout = options?.socketTimeout;
    }
    #createReconnectStrategy(options) {
      const strategy = options?.reconnectStrategy;
      if (strategy === false || typeof strategy === "number") {
        return () => strategy;
      }
      if (strategy) {
        return (retries, cause) => {
          try {
            const retryIn = strategy(retries, cause);
            if (retryIn !== false && !(retryIn instanceof Error) && typeof retryIn !== "number") {
              throw new TypeError(`Reconnect strategy should return \`false | Error | number\`, got ${retryIn} instead`);
            }
            return retryIn;
          } catch (err) {
            this.emit("error", err);
            return this.defaultReconnectStrategy(retries, err);
          }
        };
      }
      return this.defaultReconnectStrategy;
    }
    #createSocketFactory(options) {
      if (options?.tls === true) {
        const withDefaults2 = {
          ...options,
          port: options?.port ?? 6379,
          noDelay: options?.noDelay ?? true,
          keepAlive: options?.keepAlive ?? true,
          keepAliveInitialDelay: options?.keepAliveInitialDelay ?? 5000,
          timeout: undefined,
          onread: undefined,
          readable: true,
          writable: true
        };
        return {
          create() {
            return node_tls_1.default.connect(withDefaults2);
          },
          event: "secureConnect"
        };
      }
      if (options && "path" in options) {
        const withDefaults2 = {
          ...options,
          timeout: undefined,
          onread: undefined,
          readable: true,
          writable: true
        };
        return {
          create() {
            return node_net_1.default.createConnection(withDefaults2);
          },
          event: "connect"
        };
      }
      const withDefaults = {
        ...options,
        port: options?.port ?? 6379,
        noDelay: options?.noDelay ?? true,
        keepAlive: options?.keepAlive ?? true,
        keepAliveInitialDelay: options?.keepAliveInitialDelay ?? 5000,
        timeout: undefined,
        onread: undefined,
        readable: true,
        writable: true
      };
      return {
        create() {
          return node_net_1.default.createConnection(withDefaults);
        },
        event: "connect"
      };
    }
    #shouldReconnect(retries, cause) {
      const retryIn = this.#reconnectStrategy(retries, cause);
      if (retryIn === false) {
        this.#isOpen = false;
        this.emit("error", cause);
        return cause;
      } else if (retryIn instanceof Error) {
        this.#isOpen = false;
        this.emit("error", cause);
        return new errors_1.ReconnectStrategyError(retryIn, cause);
      }
      return retryIn;
    }
    async connect() {
      if (this.#isOpen) {
        throw new Error("Socket already opened");
      }
      this.#isOpen = true;
      return this.#connect();
    }
    async#connect() {
      let retries = 0;
      do {
        try {
          this.#socket = await this.#createSocket();
          this.emit("connect");
          try {
            await this.#initiator();
          } catch (err) {
            this.#socket.destroy();
            this.#socket = undefined;
            throw err;
          }
          this.#isReady = true;
          this.#socketEpoch++;
          this.emit("ready");
        } catch (err) {
          const retryIn = this.#shouldReconnect(retries++, err);
          if (typeof retryIn !== "number") {
            throw retryIn;
          }
          this.emit("error", err);
          await (0, promises_1.setTimeout)(retryIn);
          this.emit("reconnecting");
        }
      } while (this.#isOpen && !this.#isReady);
    }
    async#createSocket() {
      const socket = this.#socketFactory.create();
      let onTimeout;
      if (this.#connectTimeout !== undefined) {
        onTimeout = () => socket.destroy(new errors_1.ConnectionTimeoutError);
        socket.once("timeout", onTimeout);
        socket.setTimeout(this.#connectTimeout);
      }
      if (this.#isSocketUnrefed) {
        socket.unref();
      }
      await (0, node_events_1.once)(socket, this.#socketFactory.event);
      if (onTimeout) {
        socket.removeListener("timeout", onTimeout);
      }
      if (this.#socketTimeout) {
        socket.once("timeout", () => {
          socket.destroy(new errors_1.SocketTimeoutError(this.#socketTimeout));
        });
        socket.setTimeout(this.#socketTimeout);
      }
      socket.once("error", (err) => this.#onSocketError(err)).once("close", (hadError) => {
        if (hadError || !this.#isOpen || this.#socket !== socket)
          return;
        this.#onSocketError(new errors_1.SocketClosedUnexpectedlyError);
      }).on("drain", () => this.emit("drain")).on("data", (data) => this.emit("data", data));
      return socket;
    }
    #onSocketError(err) {
      const wasReady = this.#isReady;
      this.#isReady = false;
      this.emit("error", err);
      if (!wasReady || !this.#isOpen || typeof this.#shouldReconnect(0, err) !== "number")
        return;
      this.emit("reconnecting");
      this.#connect().catch(() => {});
    }
    write(iterable) {
      if (!this.#socket)
        return;
      this.#socket.cork();
      for (const args of iterable) {
        for (const toWrite of args) {
          this.#socket.write(toWrite);
        }
        if (this.#socket.writableNeedDrain)
          break;
      }
      this.#socket.uncork();
    }
    async quit(fn) {
      if (!this.#isOpen) {
        throw new errors_1.ClientClosedError;
      }
      this.#isOpen = false;
      const reply = await fn();
      this.destroySocket();
      return reply;
    }
    close() {
      if (!this.#isOpen) {
        throw new errors_1.ClientClosedError;
      }
      this.#isOpen = false;
    }
    destroy() {
      if (!this.#isOpen) {
        throw new errors_1.ClientClosedError;
      }
      this.#isOpen = false;
      this.destroySocket();
    }
    destroySocket() {
      this.#isReady = false;
      if (this.#socket) {
        this.#socket.destroy();
        this.#socket = undefined;
      }
      this.emit("end");
    }
    ref() {
      this.#isSocketUnrefed = false;
      this.#socket?.ref();
    }
    unref() {
      this.#isSocketUnrefed = true;
      this.#socket?.unref();
    }
    defaultReconnectStrategy(retries, cause) {
      if (cause instanceof errors_1.SocketTimeoutError) {
        return false;
      }
      const jitter = Math.floor(Math.random() * 200);
      const delay = Math.min(Math.pow(2, retries) * 50, 2000);
      return delay + jitter;
    }
  }
  exports.default = RedisSocket;
});

// ../../node_modules/@redis/client/dist/lib/authx/token.js
var require_token = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Token = undefined;

  class Token {
    value;
    expiresAtMs;
    receivedAtMs;
    constructor(value, expiresAtMs, receivedAtMs) {
      this.value = value;
      this.expiresAtMs = expiresAtMs;
      this.receivedAtMs = receivedAtMs;
    }
    getTtlMs(now) {
      if (this.expiresAtMs < now) {
        return 0;
      }
      return this.expiresAtMs - now;
    }
  }
  exports.Token = Token;
});

// ../../node_modules/@redis/client/dist/lib/authx/token-manager.js
var require_token_manager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TokenManager = exports.IDPError = undefined;
  var token_1 = require_token();

  class IDPError extends Error {
    message;
    isRetryable;
    constructor(message, isRetryable) {
      super(message);
      this.message = message;
      this.isRetryable = isRetryable;
      this.name = "IDPError";
    }
  }
  exports.IDPError = IDPError;

  class TokenManager {
    identityProvider;
    config;
    currentToken = null;
    refreshTimeout = null;
    listener = null;
    retryAttempt = 0;
    constructor(identityProvider, config) {
      this.identityProvider = identityProvider;
      this.config = config;
      if (this.config.expirationRefreshRatio > 1) {
        throw new Error("expirationRefreshRatio must be less than or equal to 1");
      }
      if (this.config.expirationRefreshRatio < 0) {
        throw new Error("expirationRefreshRatio must be greater or equal to 0");
      }
    }
    start(listener, initialDelayMs = 0) {
      if (this.listener) {
        this.stop();
      }
      this.listener = listener;
      this.retryAttempt = 0;
      this.scheduleNextRefresh(initialDelayMs);
      return {
        dispose: () => this.stop()
      };
    }
    calculateRetryDelay() {
      if (!this.config.retry)
        return 0;
      const { initialDelayMs, maxDelayMs, backoffMultiplier, jitterPercentage } = this.config.retry;
      let delay = initialDelayMs * Math.pow(backoffMultiplier, this.retryAttempt - 1);
      delay = Math.min(delay, maxDelayMs);
      if (jitterPercentage) {
        const jitterRange = delay * (jitterPercentage / 100);
        const jitterAmount = Math.random() * jitterRange - jitterRange / 2;
        delay += jitterAmount;
      }
      let result = Math.max(0, Math.floor(delay));
      return result;
    }
    shouldRetry(error) {
      if (!this.config.retry)
        return false;
      const { maxAttempts, isRetryable } = this.config.retry;
      if (this.retryAttempt >= maxAttempts) {
        return false;
      }
      if (isRetryable) {
        return isRetryable(error, this.retryAttempt);
      }
      return false;
    }
    isRunning() {
      return this.listener !== null;
    }
    async refresh() {
      if (!this.listener) {
        throw new Error("TokenManager is not running, but refresh was called");
      }
      try {
        await this.identityProvider.requestToken().then(this.handleNewToken);
        this.retryAttempt = 0;
      } catch (error) {
        if (this.shouldRetry(error)) {
          this.retryAttempt++;
          const retryDelay = this.calculateRetryDelay();
          this.notifyError(`Token refresh failed (attempt ${this.retryAttempt}), retrying in ${retryDelay}ms: ${error}`, true);
          this.scheduleNextRefresh(retryDelay);
        } else {
          this.notifyError(error, false);
          this.stop();
        }
      }
    }
    handleNewToken = async ({ token: nativeToken, ttlMs }) => {
      if (!this.listener) {
        throw new Error("TokenManager is not running, but a new token was received");
      }
      const token = this.wrapAndSetCurrentToken(nativeToken, ttlMs);
      this.listener.onNext(token);
      this.scheduleNextRefresh(this.calculateRefreshTime(token));
    };
    wrapAndSetCurrentToken(nativeToken, ttlMs) {
      const now = Date.now();
      const token = new token_1.Token(nativeToken, now + ttlMs, now);
      this.currentToken = token;
      return token;
    }
    scheduleNextRefresh(delayMs) {
      if (this.refreshTimeout) {
        clearTimeout(this.refreshTimeout);
        this.refreshTimeout = null;
      }
      if (delayMs === 0) {
        this.refresh();
      } else {
        this.refreshTimeout = setTimeout(() => this.refresh(), delayMs);
      }
    }
    calculateRefreshTime(token, now = Date.now()) {
      const ttlMs = token.getTtlMs(now);
      return Math.floor(ttlMs * this.config.expirationRefreshRatio);
    }
    stop() {
      if (this.refreshTimeout) {
        clearTimeout(this.refreshTimeout);
        this.refreshTimeout = null;
      }
      this.listener = null;
      this.currentToken = null;
      this.retryAttempt = 0;
    }
    getCurrentToken() {
      return this.currentToken;
    }
    notifyError(error, isRetryable) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (!this.listener) {
        throw new Error(`TokenManager is not running but received an error: ${errorMessage}`);
      }
      this.listener.onError(new IDPError(errorMessage, isRetryable));
    }
  }
  exports.TokenManager = TokenManager;
});

// ../../node_modules/@redis/client/dist/lib/authx/credentials-provider.js
var require_credentials_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnableToObtainNewCredentialsError = exports.CredentialsError = undefined;

  class CredentialsError extends Error {
    constructor(message) {
      super(`Re-authentication with latest credentials failed: ${message}`);
      this.name = "CredentialsError";
    }
  }
  exports.CredentialsError = CredentialsError;

  class UnableToObtainNewCredentialsError extends Error {
    constructor(message) {
      super(`Unable to obtain new credentials : ${message}`);
      this.name = "UnableToObtainNewCredentialsError";
    }
  }
  exports.UnableToObtainNewCredentialsError = UnableToObtainNewCredentialsError;
});

// ../../node_modules/@redis/client/dist/lib/authx/index.js
var require_authx = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Token = exports.CredentialsError = exports.UnableToObtainNewCredentialsError = exports.IDPError = exports.TokenManager = undefined;
  var token_manager_1 = require_token_manager();
  Object.defineProperty(exports, "TokenManager", { enumerable: true, get: function() {
    return token_manager_1.TokenManager;
  } });
  Object.defineProperty(exports, "IDPError", { enumerable: true, get: function() {
    return token_manager_1.IDPError;
  } });
  var credentials_provider_1 = require_credentials_provider();
  Object.defineProperty(exports, "UnableToObtainNewCredentialsError", { enumerable: true, get: function() {
    return credentials_provider_1.UnableToObtainNewCredentialsError;
  } });
  Object.defineProperty(exports, "CredentialsError", { enumerable: true, get: function() {
    return credentials_provider_1.CredentialsError;
  } });
  var token_1 = require_token();
  Object.defineProperty(exports, "Token", { enumerable: true, get: function() {
    return token_1.Token;
  } });
});

// ../../node_modules/@redis/client/dist/lib/client/linked-list.js
var require_linked_list = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SinglyLinkedList = exports.DoublyLinkedList = undefined;

  class DoublyLinkedList {
    #length = 0;
    get length() {
      return this.#length;
    }
    #head;
    get head() {
      return this.#head;
    }
    #tail;
    get tail() {
      return this.#tail;
    }
    push(value) {
      ++this.#length;
      if (this.#tail === undefined) {
        return this.#tail = this.#head = {
          previous: this.#head,
          next: undefined,
          value
        };
      }
      return this.#tail = this.#tail.next = {
        previous: this.#tail,
        next: undefined,
        value
      };
    }
    unshift(value) {
      ++this.#length;
      if (this.#head === undefined) {
        return this.#head = this.#tail = {
          previous: undefined,
          next: undefined,
          value
        };
      }
      return this.#head = this.#head.previous = {
        previous: undefined,
        next: this.#head,
        value
      };
    }
    add(value, prepend = false) {
      return prepend ? this.unshift(value) : this.push(value);
    }
    shift() {
      if (this.#head === undefined)
        return;
      --this.#length;
      const node = this.#head;
      if (node.next) {
        node.next.previous = node.previous;
        this.#head = node.next;
        node.next = undefined;
      } else {
        this.#head = this.#tail = undefined;
      }
      return node.value;
    }
    remove(node) {
      --this.#length;
      if (this.#tail === node) {
        this.#tail = node.previous;
      }
      if (this.#head === node) {
        this.#head = node.next;
      } else {
        node.previous.next = node.next;
        node.previous = undefined;
      }
      node.next = undefined;
    }
    reset() {
      this.#length = 0;
      this.#head = this.#tail = undefined;
    }
    *[Symbol.iterator]() {
      let node = this.#head;
      while (node !== undefined) {
        yield node.value;
        node = node.next;
      }
    }
  }
  exports.DoublyLinkedList = DoublyLinkedList;

  class SinglyLinkedList {
    #length = 0;
    get length() {
      return this.#length;
    }
    #head;
    get head() {
      return this.#head;
    }
    #tail;
    get tail() {
      return this.#tail;
    }
    push(value) {
      ++this.#length;
      const node = {
        value,
        next: undefined,
        removed: false
      };
      if (this.#head === undefined) {
        return this.#head = this.#tail = node;
      }
      return this.#tail.next = this.#tail = node;
    }
    remove(node, parent) {
      if (node.removed) {
        throw new Error("node already removed");
      }
      --this.#length;
      if (this.#head === node) {
        if (this.#tail === node) {
          this.#head = this.#tail = undefined;
        } else {
          this.#head = node.next;
        }
      } else if (this.#tail === node) {
        this.#tail = parent;
        parent.next = undefined;
      } else {
        parent.next = node.next;
      }
      node.removed = true;
    }
    shift() {
      if (this.#head === undefined)
        return;
      const node = this.#head;
      if (--this.#length === 0) {
        this.#head = this.#tail = undefined;
      } else {
        this.#head = node.next;
      }
      node.removed = true;
      return node.value;
    }
    reset() {
      this.#length = 0;
      this.#head = this.#tail = undefined;
    }
    *[Symbol.iterator]() {
      let node = this.#head;
      while (node !== undefined) {
        yield node.value;
        node = node.next;
      }
    }
  }
  exports.SinglyLinkedList = SinglyLinkedList;
});

// ../../node_modules/@redis/client/dist/lib/RESP/encoder.js
var require_encoder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CRLF2 = `\r
`;
  function encodeCommand(args) {
    const toWrite = [];
    let strings = "*" + args.length + CRLF2;
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      if (typeof arg === "string") {
        strings += "$" + Buffer.byteLength(arg) + CRLF2 + arg + CRLF2;
      } else if (arg instanceof Buffer) {
        toWrite.push(strings + "$" + arg.length.toString() + CRLF2, arg);
        strings = CRLF2;
      } else {
        throw new TypeError(`"arguments[${i}]" must be of type "string | Buffer", got ${typeof arg} instead.`);
      }
    }
    toWrite.push(strings);
    return toWrite;
  }
  exports.default = encodeCommand;
});

// ../../node_modules/@redis/client/dist/lib/client/pub-sub.js
var require_pub_sub = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PubSub = exports.PUBSUB_TYPE = undefined;
  exports.PUBSUB_TYPE = {
    CHANNELS: "CHANNELS",
    PATTERNS: "PATTERNS",
    SHARDED: "SHARDED"
  };
  var COMMANDS = {
    [exports.PUBSUB_TYPE.CHANNELS]: {
      subscribe: Buffer.from("subscribe"),
      unsubscribe: Buffer.from("unsubscribe"),
      message: Buffer.from("message")
    },
    [exports.PUBSUB_TYPE.PATTERNS]: {
      subscribe: Buffer.from("psubscribe"),
      unsubscribe: Buffer.from("punsubscribe"),
      message: Buffer.from("pmessage")
    },
    [exports.PUBSUB_TYPE.SHARDED]: {
      subscribe: Buffer.from("ssubscribe"),
      unsubscribe: Buffer.from("sunsubscribe"),
      message: Buffer.from("smessage")
    }
  };

  class PubSub {
    static isStatusReply(reply) {
      return COMMANDS[exports.PUBSUB_TYPE.CHANNELS].subscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.CHANNELS].unsubscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.PATTERNS].subscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.PATTERNS].unsubscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.SHARDED].subscribe.equals(reply[0]);
    }
    static isShardedUnsubscribe(reply) {
      return COMMANDS[exports.PUBSUB_TYPE.SHARDED].unsubscribe.equals(reply[0]);
    }
    static #channelsArray(channels) {
      return Array.isArray(channels) ? channels : [channels];
    }
    static #listenersSet(listeners, returnBuffers) {
      return returnBuffers ? listeners.buffers : listeners.strings;
    }
    #subscribing = 0;
    #isActive = false;
    get isActive() {
      return this.#isActive;
    }
    listeners = {
      [exports.PUBSUB_TYPE.CHANNELS]: new Map,
      [exports.PUBSUB_TYPE.PATTERNS]: new Map,
      [exports.PUBSUB_TYPE.SHARDED]: new Map
    };
    subscribe(type, channels, listener, returnBuffers) {
      const args = [COMMANDS[type].subscribe], channelsArray = PubSub.#channelsArray(channels);
      for (const channel of channelsArray) {
        let channelListeners = this.listeners[type].get(channel);
        if (!channelListeners || channelListeners.unsubscribing) {
          args.push(channel);
        }
      }
      if (args.length === 1) {
        for (const channel of channelsArray) {
          PubSub.#listenersSet(this.listeners[type].get(channel), returnBuffers).add(listener);
        }
        return;
      }
      this.#isActive = true;
      this.#subscribing++;
      return {
        args,
        channelsCounter: args.length - 1,
        resolve: () => {
          this.#subscribing--;
          for (const channel of channelsArray) {
            let listeners = this.listeners[type].get(channel);
            if (!listeners) {
              listeners = {
                unsubscribing: false,
                buffers: new Set,
                strings: new Set
              };
              this.listeners[type].set(channel, listeners);
            }
            PubSub.#listenersSet(listeners, returnBuffers).add(listener);
          }
        },
        reject: () => {
          this.#subscribing--;
          this.#updateIsActive();
        }
      };
    }
    extendChannelListeners(type, channel, listeners) {
      if (!this.#extendChannelListeners(type, channel, listeners))
        return;
      this.#isActive = true;
      this.#subscribing++;
      return {
        args: [
          COMMANDS[type].subscribe,
          channel
        ],
        channelsCounter: 1,
        resolve: () => this.#subscribing--,
        reject: () => {
          this.#subscribing--;
          this.#updateIsActive();
        }
      };
    }
    #extendChannelListeners(type, channel, listeners) {
      const existingListeners = this.listeners[type].get(channel);
      if (!existingListeners) {
        this.listeners[type].set(channel, listeners);
        return true;
      }
      for (const listener of listeners.buffers) {
        existingListeners.buffers.add(listener);
      }
      for (const listener of listeners.strings) {
        existingListeners.strings.add(listener);
      }
      return false;
    }
    extendTypeListeners(type, listeners) {
      const args = [COMMANDS[type].subscribe];
      for (const [channel, channelListeners] of listeners) {
        if (this.#extendChannelListeners(type, channel, channelListeners)) {
          args.push(channel);
        }
      }
      if (args.length === 1)
        return;
      this.#isActive = true;
      this.#subscribing++;
      return {
        args,
        channelsCounter: args.length - 1,
        resolve: () => this.#subscribing--,
        reject: () => {
          this.#subscribing--;
          this.#updateIsActive();
        }
      };
    }
    unsubscribe(type, channels, listener, returnBuffers) {
      const listeners = this.listeners[type];
      if (!channels) {
        return this.#unsubscribeCommand([COMMANDS[type].unsubscribe], NaN, () => listeners.clear());
      }
      const channelsArray = PubSub.#channelsArray(channels);
      if (!listener) {
        return this.#unsubscribeCommand([COMMANDS[type].unsubscribe, ...channelsArray], channelsArray.length, () => {
          for (const channel of channelsArray) {
            listeners.delete(channel);
          }
        });
      }
      const args = [COMMANDS[type].unsubscribe];
      for (const channel of channelsArray) {
        const sets = listeners.get(channel);
        if (sets) {
          let current, other;
          if (returnBuffers) {
            current = sets.buffers;
            other = sets.strings;
          } else {
            current = sets.strings;
            other = sets.buffers;
          }
          const currentSize = current.has(listener) ? current.size - 1 : current.size;
          if (currentSize !== 0 || other.size !== 0)
            continue;
          sets.unsubscribing = true;
        }
        args.push(channel);
      }
      if (args.length === 1) {
        for (const channel of channelsArray) {
          PubSub.#listenersSet(listeners.get(channel), returnBuffers).delete(listener);
        }
        return;
      }
      return this.#unsubscribeCommand(args, args.length - 1, () => {
        for (const channel of channelsArray) {
          const sets = listeners.get(channel);
          if (!sets)
            continue;
          (returnBuffers ? sets.buffers : sets.strings).delete(listener);
          if (sets.buffers.size === 0 && sets.strings.size === 0) {
            listeners.delete(channel);
          }
        }
      });
    }
    #unsubscribeCommand(args, channelsCounter, removeListeners) {
      return {
        args,
        channelsCounter,
        resolve: () => {
          removeListeners();
          this.#updateIsActive();
        },
        reject: undefined
      };
    }
    #updateIsActive() {
      this.#isActive = this.listeners[exports.PUBSUB_TYPE.CHANNELS].size !== 0 || this.listeners[exports.PUBSUB_TYPE.PATTERNS].size !== 0 || this.listeners[exports.PUBSUB_TYPE.SHARDED].size !== 0 || this.#subscribing !== 0;
    }
    reset() {
      this.#isActive = false;
      this.#subscribing = 0;
    }
    resubscribe() {
      const commands = [];
      for (const [type, listeners] of Object.entries(this.listeners)) {
        if (!listeners.size)
          continue;
        this.#isActive = true;
        this.#subscribing++;
        const callback = () => this.#subscribing--;
        commands.push({
          args: [
            COMMANDS[type].subscribe,
            ...listeners.keys()
          ],
          channelsCounter: listeners.size,
          resolve: callback,
          reject: callback
        });
      }
      return commands;
    }
    handleMessageReply(reply) {
      if (COMMANDS[exports.PUBSUB_TYPE.CHANNELS].message.equals(reply[0])) {
        this.#emitPubSubMessage(exports.PUBSUB_TYPE.CHANNELS, reply[2], reply[1]);
        return true;
      } else if (COMMANDS[exports.PUBSUB_TYPE.PATTERNS].message.equals(reply[0])) {
        this.#emitPubSubMessage(exports.PUBSUB_TYPE.PATTERNS, reply[3], reply[2], reply[1]);
        return true;
      } else if (COMMANDS[exports.PUBSUB_TYPE.SHARDED].message.equals(reply[0])) {
        this.#emitPubSubMessage(exports.PUBSUB_TYPE.SHARDED, reply[2], reply[1]);
        return true;
      }
      return false;
    }
    removeShardedListeners(channel) {
      const listeners = this.listeners[exports.PUBSUB_TYPE.SHARDED].get(channel);
      this.listeners[exports.PUBSUB_TYPE.SHARDED].delete(channel);
      this.#updateIsActive();
      return listeners;
    }
    #emitPubSubMessage(type, message, channel, pattern) {
      const keyString = (pattern ?? channel).toString(), listeners = this.listeners[type].get(keyString);
      if (!listeners)
        return;
      for (const listener of listeners.buffers) {
        listener(message, channel);
      }
      if (!listeners.strings.size)
        return;
      const channelString = pattern ? channel.toString() : keyString, messageString = channelString === "__redis__:invalidate" ? message === null ? null : message.map((x) => x.toString()) : message.toString();
      for (const listener of listeners.strings) {
        listener(messageString, channelString);
      }
    }
  }
  exports.PubSub = PubSub;
});

// ../../node_modules/@redis/client/dist/lib/client/commands-queue.js
var require_commands_queue = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var linked_list_1 = require_linked_list();
  var encoder_1 = __importDefault(require_encoder());
  var decoder_1 = require_decoder();
  var pub_sub_1 = require_pub_sub();
  var errors_1 = require_errors();
  var PONG = Buffer.from("pong");
  var RESET = Buffer.from("RESET");
  var RESP2_PUSH_TYPE_MAPPING = {
    ...decoder_1.PUSH_TYPE_MAPPING,
    [decoder_1.RESP_TYPES.SIMPLE_STRING]: Buffer
  };

  class RedisCommandsQueue {
    #respVersion;
    #maxLength;
    #toWrite = new linked_list_1.DoublyLinkedList;
    #waitingForReply = new linked_list_1.SinglyLinkedList;
    #onShardedChannelMoved;
    #chainInExecution;
    decoder;
    #pubSub = new pub_sub_1.PubSub;
    get isPubSubActive() {
      return this.#pubSub.isActive;
    }
    #invalidateCallback;
    constructor(respVersion, maxLength, onShardedChannelMoved) {
      this.#respVersion = respVersion;
      this.#maxLength = maxLength;
      this.#onShardedChannelMoved = onShardedChannelMoved;
      this.decoder = this.#initiateDecoder();
    }
    #onReply(reply) {
      this.#waitingForReply.shift().resolve(reply);
    }
    #onErrorReply(err) {
      this.#waitingForReply.shift().reject(err);
    }
    #onPush(push) {
      if (this.#pubSub.handleMessageReply(push))
        return true;
      const isShardedUnsubscribe = pub_sub_1.PubSub.isShardedUnsubscribe(push);
      if (isShardedUnsubscribe && !this.#waitingForReply.length) {
        const channel = push[1].toString();
        this.#onShardedChannelMoved(channel, this.#pubSub.removeShardedListeners(channel));
        return true;
      } else if (isShardedUnsubscribe || pub_sub_1.PubSub.isStatusReply(push)) {
        const head = this.#waitingForReply.head.value;
        if (Number.isNaN(head.channelsCounter) && push[2] === 0 || --head.channelsCounter === 0) {
          this.#waitingForReply.shift().resolve();
        }
        return true;
      }
    }
    #getTypeMapping() {
      return this.#waitingForReply.head.value.typeMapping ?? {};
    }
    #initiateDecoder() {
      return new decoder_1.Decoder({
        onReply: (reply) => this.#onReply(reply),
        onErrorReply: (err) => this.#onErrorReply(err),
        onPush: (push) => {
          if (!this.#onPush(push)) {
            switch (push[0].toString()) {
              case "invalidate": {
                if (this.#invalidateCallback) {
                  if (push[1] !== null) {
                    for (const key of push[1]) {
                      this.#invalidateCallback(key);
                    }
                  } else {
                    this.#invalidateCallback(null);
                  }
                }
                break;
              }
            }
          }
        },
        getTypeMapping: () => this.#getTypeMapping()
      });
    }
    setInvalidateCallback(callback) {
      this.#invalidateCallback = callback;
    }
    addCommand(args, options) {
      if (this.#maxLength && this.#toWrite.length + this.#waitingForReply.length >= this.#maxLength) {
        return Promise.reject(new Error("The queue is full"));
      } else if (options?.abortSignal?.aborted) {
        return Promise.reject(new errors_1.AbortError);
      }
      return new Promise((resolve, reject) => {
        let node;
        const value = {
          args,
          chainId: options?.chainId,
          abort: undefined,
          timeout: undefined,
          resolve,
          reject,
          channelsCounter: undefined,
          typeMapping: options?.typeMapping
        };
        const timeout = options?.timeout;
        if (timeout) {
          const signal2 = AbortSignal.timeout(timeout);
          value.timeout = {
            signal: signal2,
            listener: () => {
              this.#toWrite.remove(node);
              value.reject(new errors_1.TimeoutError);
            }
          };
          signal2.addEventListener("abort", value.timeout.listener, { once: true });
        }
        const signal = options?.abortSignal;
        if (signal) {
          value.abort = {
            signal,
            listener: () => {
              this.#toWrite.remove(node);
              value.reject(new errors_1.AbortError);
            }
          };
          signal.addEventListener("abort", value.abort.listener, { once: true });
        }
        node = this.#toWrite.add(value, options?.asap);
      });
    }
    #addPubSubCommand(command, asap2 = false, chainId) {
      return new Promise((resolve, reject) => {
        this.#toWrite.add({
          args: command.args,
          chainId,
          abort: undefined,
          timeout: undefined,
          resolve() {
            command.resolve();
            resolve();
          },
          reject(err) {
            command.reject?.();
            reject(err);
          },
          channelsCounter: command.channelsCounter,
          typeMapping: decoder_1.PUSH_TYPE_MAPPING
        }, asap2);
      });
    }
    #setupPubSubHandler() {
      if (this.#respVersion !== 2)
        return;
      this.decoder.onReply = (reply) => {
        if (Array.isArray(reply)) {
          if (this.#onPush(reply))
            return;
          if (PONG.equals(reply[0])) {
            const { resolve, typeMapping } = this.#waitingForReply.shift(), buffer = reply[1].length === 0 ? reply[0] : reply[1];
            resolve(typeMapping?.[decoder_1.RESP_TYPES.SIMPLE_STRING] === Buffer ? buffer : buffer.toString());
            return;
          }
        }
        return this.#onReply(reply);
      };
      this.decoder.getTypeMapping = () => RESP2_PUSH_TYPE_MAPPING;
    }
    subscribe(type, channels, listener, returnBuffers) {
      const command = this.#pubSub.subscribe(type, channels, listener, returnBuffers);
      if (!command)
        return;
      this.#setupPubSubHandler();
      return this.#addPubSubCommand(command);
    }
    #resetDecoderCallbacks() {
      this.decoder.onReply = (reply) => this.#onReply(reply);
      this.decoder.getTypeMapping = () => this.#getTypeMapping();
    }
    unsubscribe(type, channels, listener, returnBuffers) {
      const command = this.#pubSub.unsubscribe(type, channels, listener, returnBuffers);
      if (!command)
        return;
      if (command && this.#respVersion === 2) {
        const { resolve } = command;
        command.resolve = () => {
          if (!this.#pubSub.isActive) {
            this.#resetDecoderCallbacks();
          }
          resolve();
        };
      }
      return this.#addPubSubCommand(command);
    }
    resubscribe(chainId) {
      const commands = this.#pubSub.resubscribe();
      if (!commands.length)
        return;
      this.#setupPubSubHandler();
      return Promise.all(commands.map((command) => this.#addPubSubCommand(command, true, chainId)));
    }
    extendPubSubChannelListeners(type, channel, listeners) {
      const command = this.#pubSub.extendChannelListeners(type, channel, listeners);
      if (!command)
        return;
      this.#setupPubSubHandler();
      return this.#addPubSubCommand(command);
    }
    extendPubSubListeners(type, listeners) {
      const command = this.#pubSub.extendTypeListeners(type, listeners);
      if (!command)
        return;
      this.#setupPubSubHandler();
      return this.#addPubSubCommand(command);
    }
    getPubSubListeners(type) {
      return this.#pubSub.listeners[type];
    }
    monitor(callback, options) {
      return new Promise((resolve, reject) => {
        const typeMapping = options?.typeMapping ?? {};
        this.#toWrite.add({
          args: ["MONITOR"],
          chainId: options?.chainId,
          abort: undefined,
          timeout: undefined,
          resolve: () => {
            if (this.#resetFallbackOnReply) {
              this.#resetFallbackOnReply = callback;
            } else {
              this.decoder.onReply = callback;
            }
            this.decoder.getTypeMapping = () => typeMapping;
            resolve();
          },
          reject,
          channelsCounter: undefined,
          typeMapping
        }, options?.asap);
      });
    }
    resetDecoder() {
      this.#resetDecoderCallbacks();
      this.decoder.reset();
    }
    #resetFallbackOnReply;
    async reset(chainId, typeMapping) {
      return new Promise((resolve, reject) => {
        this.#resetFallbackOnReply = this.decoder.onReply;
        this.decoder.onReply = (reply) => {
          if (typeof reply === "string" && reply === "RESET" || reply instanceof Buffer && RESET.equals(reply)) {
            this.#resetDecoderCallbacks();
            this.#resetFallbackOnReply = undefined;
            this.#pubSub.reset();
            this.#waitingForReply.shift().resolve(reply);
            return;
          }
          this.#resetFallbackOnReply(reply);
        };
        this.#toWrite.push({
          args: ["RESET"],
          chainId,
          abort: undefined,
          timeout: undefined,
          resolve,
          reject,
          channelsCounter: undefined,
          typeMapping
        });
      });
    }
    isWaitingToWrite() {
      return this.#toWrite.length > 0;
    }
    *commandsToWrite() {
      let toSend = this.#toWrite.shift();
      while (toSend) {
        let encoded;
        try {
          encoded = (0, encoder_1.default)(toSend.args);
        } catch (err) {
          toSend.reject(err);
          toSend = this.#toWrite.shift();
          continue;
        }
        toSend.args = undefined;
        if (toSend.abort) {
          RedisCommandsQueue.#removeAbortListener(toSend);
          toSend.abort = undefined;
        }
        if (toSend.timeout) {
          RedisCommandsQueue.#removeTimeoutListener(toSend);
          toSend.timeout = undefined;
        }
        this.#chainInExecution = toSend.chainId;
        toSend.chainId = undefined;
        this.#waitingForReply.push(toSend);
        yield encoded;
        toSend = this.#toWrite.shift();
      }
    }
    #flushWaitingForReply(err) {
      for (const node of this.#waitingForReply) {
        node.reject(err);
      }
      this.#waitingForReply.reset();
    }
    static #removeAbortListener(command) {
      command.abort.signal.removeEventListener("abort", command.abort.listener);
    }
    static #removeTimeoutListener(command) {
      command.timeout.signal.removeEventListener("abort", command.timeout.listener);
    }
    static #flushToWrite(toBeSent, err) {
      if (toBeSent.abort) {
        RedisCommandsQueue.#removeAbortListener(toBeSent);
      }
      if (toBeSent.timeout) {
        RedisCommandsQueue.#removeTimeoutListener(toBeSent);
      }
      toBeSent.reject(err);
    }
    flushWaitingForReply(err) {
      this.resetDecoder();
      this.#pubSub.reset();
      this.#flushWaitingForReply(err);
      if (!this.#chainInExecution)
        return;
      while (this.#toWrite.head?.value.chainId === this.#chainInExecution) {
        RedisCommandsQueue.#flushToWrite(this.#toWrite.shift(), err);
      }
      this.#chainInExecution = undefined;
    }
    flushAll(err) {
      this.resetDecoder();
      this.#pubSub.reset();
      this.#flushWaitingForReply(err);
      for (const node of this.#toWrite) {
        RedisCommandsQueue.#flushToWrite(node, err);
      }
      this.#toWrite.reset();
    }
    isEmpty() {
      return this.#toWrite.length === 0 && this.#waitingForReply.length === 0;
    }
  }
  exports.default = RedisCommandsQueue;
});

// ../../node_modules/@redis/client/dist/lib/commander.js
var require_commander = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scriptArgumentsPrefix = exports.functionArgumentsPrefix = exports.getTransformReply = exports.attachConfig = undefined;
  function throwResp3SearchModuleUnstableError() {
    throw new Error("Some RESP3 results for Redis Query Engine responses may change. Refer to the readme for guidance");
  }
  function attachConfig({ BaseClass, commands, createCommand, createModuleCommand, createFunctionCommand, createScriptCommand, config }) {
    const RESP = config?.RESP ?? 2, Class = class extends BaseClass {
    };
    for (const [name, command] of Object.entries(commands)) {
      if (config?.RESP == 3 && command.unstableResp3 && !config.unstableResp3) {
        Class.prototype[name] = throwResp3SearchModuleUnstableError;
      } else {
        Class.prototype[name] = createCommand(command, RESP);
      }
    }
    if (config?.modules) {
      for (const [moduleName, module2] of Object.entries(config.modules)) {
        const fns = Object.create(null);
        for (const [name, command] of Object.entries(module2)) {
          if (config.RESP == 3 && command.unstableResp3 && !config.unstableResp3) {
            fns[name] = throwResp3SearchModuleUnstableError;
          } else {
            fns[name] = createModuleCommand(command, RESP);
          }
        }
        attachNamespace(Class.prototype, moduleName, fns);
      }
    }
    if (config?.functions) {
      for (const [library, commands2] of Object.entries(config.functions)) {
        const fns = Object.create(null);
        for (const [name, command] of Object.entries(commands2)) {
          fns[name] = createFunctionCommand(name, command, RESP);
        }
        attachNamespace(Class.prototype, library, fns);
      }
    }
    if (config?.scripts) {
      for (const [name, script] of Object.entries(config.scripts)) {
        Class.prototype[name] = createScriptCommand(script, RESP);
      }
    }
    return Class;
  }
  exports.attachConfig = attachConfig;
  function attachNamespace(prototype3, name, fns) {
    Object.defineProperty(prototype3, name, {
      get() {
        const value = Object.create(fns);
        value._self = this;
        Object.defineProperty(this, name, { value });
        return value;
      }
    });
  }
  function getTransformReply(command, resp) {
    switch (typeof command.transformReply) {
      case "function":
        return command.transformReply;
      case "object":
        return command.transformReply[resp];
    }
  }
  exports.getTransformReply = getTransformReply;
  function functionArgumentsPrefix(name, fn) {
    const prefix = [
      fn.IS_READ_ONLY ? "FCALL_RO" : "FCALL",
      name
    ];
    if (fn.NUMBER_OF_KEYS !== undefined) {
      prefix.push(fn.NUMBER_OF_KEYS.toString());
    }
    return prefix;
  }
  exports.functionArgumentsPrefix = functionArgumentsPrefix;
  function scriptArgumentsPrefix(script) {
    const prefix = [
      script.IS_READ_ONLY ? "EVALSHA_RO" : "EVALSHA",
      script.SHA1
    ];
    if (script.NUMBER_OF_KEYS !== undefined) {
      prefix.push(script.NUMBER_OF_KEYS.toString());
    }
    return prefix;
  }
  exports.scriptArgumentsPrefix = scriptArgumentsPrefix;
});

// ../../node_modules/@redis/client/dist/lib/multi-command.js
var require_multi_command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_1 = require_errors();

  class RedisMultiCommand {
    typeMapping;
    constructor(typeMapping) {
      this.typeMapping = typeMapping;
    }
    queue = [];
    scriptsInUse = new Set;
    addCommand(args, transformReply) {
      this.queue.push({
        args,
        transformReply
      });
    }
    addScript(script, args, transformReply) {
      const redisArgs = [];
      redisArgs.preserve = args.preserve;
      if (this.scriptsInUse.has(script.SHA1)) {
        redisArgs.push("EVALSHA", script.SHA1);
      } else {
        this.scriptsInUse.add(script.SHA1);
        redisArgs.push("EVAL", script.SCRIPT);
      }
      if (script.NUMBER_OF_KEYS !== undefined) {
        redisArgs.push(script.NUMBER_OF_KEYS.toString());
      }
      redisArgs.push(...args);
      this.addCommand(redisArgs, transformReply);
    }
    transformReplies(rawReplies) {
      const errorIndexes = [], replies = rawReplies.map((reply, i) => {
        if (reply instanceof errors_1.ErrorReply) {
          errorIndexes.push(i);
          return reply;
        }
        const { transformReply, args } = this.queue[i];
        return transformReply ? transformReply(reply, args.preserve, this.typeMapping) : reply;
      });
      if (errorIndexes.length)
        throw new errors_1.MultiErrorReply(replies, errorIndexes);
      return replies;
    }
  }
  exports.default = RedisMultiCommand;
});

// ../../node_modules/@redis/client/dist/lib/client/multi-command.js
var require_multi_command2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var multi_command_1 = __importDefault(require_multi_command());
  var commander_1 = require_commander();
  var parser_1 = require_parser();

  class RedisClientMultiCommand {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this.addCommand(redisArgs, transformReply);
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this._self.addCommand(redisArgs, transformReply);
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this._self.addCommand(redisArgs, transformReply);
      };
    }
    static #createScriptCommand(script, resp) {
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        script.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this.#addScript(script, redisArgs, transformReply);
      };
    }
    static extend(config) {
      return (0, commander_1.attachConfig)({
        BaseClass: RedisClientMultiCommand,
        commands: commands_1.default,
        createCommand: RedisClientMultiCommand.#createCommand,
        createModuleCommand: RedisClientMultiCommand.#createModuleCommand,
        createFunctionCommand: RedisClientMultiCommand.#createFunctionCommand,
        createScriptCommand: RedisClientMultiCommand.#createScriptCommand,
        config
      });
    }
    #multi;
    #executeMulti;
    #executePipeline;
    #selectedDB;
    constructor(executeMulti, executePipeline, typeMapping) {
      this.#multi = new multi_command_1.default(typeMapping);
      this.#executeMulti = executeMulti;
      this.#executePipeline = executePipeline;
    }
    SELECT(db, transformReply) {
      this.#selectedDB = db;
      this.#multi.addCommand(["SELECT", db.toString()], transformReply);
      return this;
    }
    select = this.SELECT;
    addCommand(args, transformReply) {
      this.#multi.addCommand(args, transformReply);
      return this;
    }
    #addScript(script, args, transformReply) {
      this.#multi.addScript(script, args, transformReply);
      return this;
    }
    async exec(execAsPipeline = false) {
      if (execAsPipeline)
        return this.execAsPipeline();
      return this.#multi.transformReplies(await this.#executeMulti(this.#multi.queue, this.#selectedDB));
    }
    EXEC = this.exec;
    execTyped(execAsPipeline = false) {
      return this.exec(execAsPipeline);
    }
    async execAsPipeline() {
      if (this.#multi.queue.length === 0)
        return [];
      return this.#multi.transformReplies(await this.#executePipeline(this.#multi.queue, this.#selectedDB));
    }
    execAsPipelineTyped() {
      return this.execAsPipeline();
    }
  }
  exports.default = RedisClientMultiCommand;
});

// ../../node_modules/@redis/client/dist/lib/client/legacy-mode.js
var require_legacy_mode = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisLegacyClient = undefined;
  var commander_1 = require_commander();
  var commands_1 = __importDefault(require_commands());
  var multi_command_1 = __importDefault(require_multi_command());

  class RedisLegacyClient {
    static #transformArguments(redisArgs, args) {
      let callback;
      if (typeof args[args.length - 1] === "function") {
        callback = args.pop();
      }
      RedisLegacyClient.pushArguments(redisArgs, args);
      return callback;
    }
    static pushArguments(redisArgs, args) {
      for (let i = 0;i < args.length; ++i) {
        const arg = args[i];
        if (Array.isArray(arg)) {
          RedisLegacyClient.pushArguments(redisArgs, arg);
        } else {
          redisArgs.push(typeof arg === "number" || arg instanceof Date ? arg.toString() : arg);
        }
      }
    }
    static getTransformReply(command, resp) {
      return command.TRANSFORM_LEGACY_REPLY ? (0, commander_1.getTransformReply)(command, resp) : undefined;
    }
    static #createCommand(name, command, resp) {
      const transformReply = RedisLegacyClient.getTransformReply(command, resp);
      return function(...args) {
        const redisArgs = [name], callback = RedisLegacyClient.#transformArguments(redisArgs, args), promise = this.#client.sendCommand(redisArgs);
        if (!callback) {
          promise.catch((err) => this.#client.emit("error", err));
          return;
        }
        promise.then((reply) => callback(null, transformReply ? transformReply(reply) : reply)).catch((err) => callback(err));
      };
    }
    #client;
    #Multi;
    constructor(client) {
      this.#client = client;
      const RESP = client.options?.RESP ?? 2;
      for (const [name, command] of Object.entries(commands_1.default)) {
        this[name] = RedisLegacyClient.#createCommand(name, command, RESP);
      }
      this.#Multi = LegacyMultiCommand.factory(RESP);
    }
    sendCommand(...args) {
      const redisArgs = [], callback = RedisLegacyClient.#transformArguments(redisArgs, args), promise = this.#client.sendCommand(redisArgs);
      if (!callback) {
        promise.catch((err) => this.#client.emit("error", err));
        return;
      }
      promise.then((reply) => callback(null, reply)).catch((err) => callback(err));
    }
    multi() {
      return this.#Multi(this.#client);
    }
  }
  exports.RedisLegacyClient = RedisLegacyClient;

  class LegacyMultiCommand {
    static #createCommand(name, command, resp) {
      const transformReply = RedisLegacyClient.getTransformReply(command, resp);
      return function(...args) {
        const redisArgs = [name];
        RedisLegacyClient.pushArguments(redisArgs, args);
        this.#multi.addCommand(redisArgs, transformReply);
        return this;
      };
    }
    static factory(resp) {
      const Multi = class extends LegacyMultiCommand {
      };
      for (const [name, command] of Object.entries(commands_1.default)) {
        Multi.prototype[name] = LegacyMultiCommand.#createCommand(name, command, resp);
      }
      return (client) => {
        return new Multi(client);
      };
    }
    #multi = new multi_command_1.default;
    #client;
    constructor(client) {
      this.#client = client;
    }
    sendCommand(...args) {
      const redisArgs = [];
      RedisLegacyClient.pushArguments(redisArgs, args);
      this.#multi.addCommand(redisArgs);
      return this;
    }
    exec(cb) {
      const promise = this.#client._executeMulti(this.#multi.queue);
      if (!cb) {
        promise.catch((err) => this.#client.emit("error", err));
        return;
      }
      promise.then((results) => cb(null, this.#multi.transformReplies(results))).catch((err) => cb?.(err));
    }
  }
});

// ../../node_modules/@redis/client/dist/lib/client/cache.js
var require_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PooledNoRedirectClientSideCache = exports.BasicPooledClientSideCache = exports.PooledClientSideCacheProvider = exports.BasicClientSideCache = exports.ClientSideCacheProvider = exports.CacheStats = undefined;
  var stream_1 = __require("stream");

  class CacheStats {
    hitCount;
    missCount;
    loadSuccessCount;
    loadFailureCount;
    totalLoadTime;
    evictionCount;
    constructor(hitCount, missCount, loadSuccessCount, loadFailureCount, totalLoadTime, evictionCount) {
      this.hitCount = hitCount;
      this.missCount = missCount;
      this.loadSuccessCount = loadSuccessCount;
      this.loadFailureCount = loadFailureCount;
      this.totalLoadTime = totalLoadTime;
      this.evictionCount = evictionCount;
      if (hitCount < 0 || missCount < 0 || loadSuccessCount < 0 || loadFailureCount < 0 || totalLoadTime < 0 || evictionCount < 0) {
        throw new Error("All statistics values must be non-negative");
      }
    }
    static of(hitCount = 0, missCount = 0, loadSuccessCount = 0, loadFailureCount = 0, totalLoadTime = 0, evictionCount = 0) {
      return new CacheStats(hitCount, missCount, loadSuccessCount, loadFailureCount, totalLoadTime, evictionCount);
    }
    static empty() {
      return CacheStats.EMPTY_STATS;
    }
    static EMPTY_STATS = new CacheStats(0, 0, 0, 0, 0, 0);
    requestCount() {
      return this.hitCount + this.missCount;
    }
    hitRate() {
      const requestCount = this.requestCount();
      return requestCount === 0 ? 1 : this.hitCount / requestCount;
    }
    missRate() {
      const requestCount = this.requestCount();
      return requestCount === 0 ? 0 : this.missCount / requestCount;
    }
    loadCount() {
      return this.loadSuccessCount + this.loadFailureCount;
    }
    loadFailureRate() {
      const loadCount = this.loadCount();
      return loadCount === 0 ? 0 : this.loadFailureCount / loadCount;
    }
    averageLoadPenalty() {
      const loadCount = this.loadCount();
      return loadCount === 0 ? 0 : this.totalLoadTime / loadCount;
    }
    minus(other) {
      return CacheStats.of(Math.max(0, this.hitCount - other.hitCount), Math.max(0, this.missCount - other.missCount), Math.max(0, this.loadSuccessCount - other.loadSuccessCount), Math.max(0, this.loadFailureCount - other.loadFailureCount), Math.max(0, this.totalLoadTime - other.totalLoadTime), Math.max(0, this.evictionCount - other.evictionCount));
    }
    plus(other) {
      return CacheStats.of(this.hitCount + other.hitCount, this.missCount + other.missCount, this.loadSuccessCount + other.loadSuccessCount, this.loadFailureCount + other.loadFailureCount, this.totalLoadTime + other.totalLoadTime, this.evictionCount + other.evictionCount);
    }
  }
  exports.CacheStats = CacheStats;

  class DisabledStatsCounter {
    static INSTANCE = new DisabledStatsCounter;
    constructor() {}
    recordHits(count) {}
    recordMisses(count) {}
    recordLoadSuccess(loadTime) {}
    recordLoadFailure(loadTime) {}
    recordEvictions(count) {}
    snapshot() {
      return CacheStats.empty();
    }
  }
  function disabledStatsCounter() {
    return DisabledStatsCounter.INSTANCE;
  }

  class DefaultStatsCounter {
    #hitCount = 0;
    #missCount = 0;
    #loadSuccessCount = 0;
    #loadFailureCount = 0;
    #totalLoadTime = 0;
    #evictionCount = 0;
    recordHits(count) {
      this.#hitCount += count;
    }
    recordMisses(count) {
      this.#missCount += count;
    }
    recordLoadSuccess(loadTime) {
      this.#loadSuccessCount++;
      this.#totalLoadTime += loadTime;
    }
    recordLoadFailure(loadTime) {
      this.#loadFailureCount++;
      this.#totalLoadTime += loadTime;
    }
    recordEvictions(count) {
      this.#evictionCount += count;
    }
    snapshot() {
      return CacheStats.of(this.#hitCount, this.#missCount, this.#loadSuccessCount, this.#loadFailureCount, this.#totalLoadTime, this.#evictionCount);
    }
    static create() {
      return new DefaultStatsCounter;
    }
  }
  function generateCacheKey(redisArgs) {
    const tmp = new Array(redisArgs.length * 2);
    for (let i = 0;i < redisArgs.length; i++) {
      tmp[i] = redisArgs[i].length;
      tmp[i + redisArgs.length] = redisArgs[i];
    }
    return tmp.join("_");
  }

  class ClientSideCacheEntryBase {
    #invalidated = false;
    #expireTime;
    constructor(ttl) {
      if (ttl == 0) {
        this.#expireTime = 0;
      } else {
        this.#expireTime = Date.now() + ttl;
      }
    }
    invalidate() {
      this.#invalidated = true;
    }
    validate() {
      return !this.#invalidated && (this.#expireTime == 0 || Date.now() < this.#expireTime);
    }
  }

  class ClientSideCacheEntryValue extends ClientSideCacheEntryBase {
    #value;
    get value() {
      return this.#value;
    }
    constructor(ttl, value) {
      super(ttl);
      this.#value = value;
    }
  }

  class ClientSideCacheEntryPromise extends ClientSideCacheEntryBase {
    #sendCommandPromise;
    get promise() {
      return this.#sendCommandPromise;
    }
    constructor(ttl, sendCommandPromise) {
      super(ttl);
      this.#sendCommandPromise = sendCommandPromise;
    }
  }

  class ClientSideCacheProvider extends stream_1.EventEmitter {
  }
  exports.ClientSideCacheProvider = ClientSideCacheProvider;

  class BasicClientSideCache extends ClientSideCacheProvider {
    #cacheKeyToEntryMap;
    #keyToCacheKeySetMap;
    ttl;
    maxEntries;
    lru;
    #statsCounter;
    recordEvictions(count) {
      this.#statsCounter.recordEvictions(count);
    }
    recordHits(count) {
      this.#statsCounter.recordHits(count);
    }
    recordMisses(count) {
      this.#statsCounter.recordMisses(count);
    }
    constructor(config) {
      super();
      this.#cacheKeyToEntryMap = new Map;
      this.#keyToCacheKeySetMap = new Map;
      this.ttl = config?.ttl ?? 0;
      this.maxEntries = config?.maxEntries ?? 0;
      this.lru = config?.evictPolicy !== "FIFO";
      const recordStats = config?.recordStats !== false;
      this.#statsCounter = recordStats ? DefaultStatsCounter.create() : disabledStatsCounter();
    }
    async handleCache(client, parser, fn, transformReply, typeMapping) {
      let reply;
      const cacheKey = generateCacheKey(parser.redisArgs);
      let cacheEntry = this.get(cacheKey);
      if (cacheEntry) {
        if (cacheEntry instanceof ClientSideCacheEntryValue) {
          this.#statsCounter.recordHits(1);
          return structuredClone(cacheEntry.value);
        } else if (cacheEntry instanceof ClientSideCacheEntryPromise) {
          this.#statsCounter.recordMisses(1);
          reply = await cacheEntry.promise;
        } else {
          throw new Error("unknown cache entry type");
        }
      } else {
        this.#statsCounter.recordMisses(1);
        const startTime = performance.now();
        const promise = fn();
        cacheEntry = this.createPromiseEntry(client, promise);
        this.set(cacheKey, cacheEntry, parser.keys);
        try {
          reply = await promise;
          const loadTime = performance.now() - startTime;
          this.#statsCounter.recordLoadSuccess(loadTime);
        } catch (err) {
          const loadTime = performance.now() - startTime;
          this.#statsCounter.recordLoadFailure(loadTime);
          if (cacheEntry.validate()) {
            this.delete(cacheKey);
          }
          throw err;
        }
      }
      let val;
      if (transformReply) {
        val = transformReply(reply, parser.preserve, typeMapping);
      } else {
        val = reply;
      }
      if (cacheEntry.validate()) {
        cacheEntry = this.createValueEntry(client, val);
        this.set(cacheKey, cacheEntry, parser.keys);
        this.emit("cached-key", cacheKey);
      } else {}
      return structuredClone(val);
    }
    trackingOn() {
      return ["CLIENT", "TRACKING", "ON"];
    }
    invalidate(key) {
      if (key === null) {
        this.clear(false);
        this.emit("invalidate", key);
        return;
      }
      const keySet = this.#keyToCacheKeySetMap.get(key.toString());
      if (keySet) {
        for (const cacheKey of keySet) {
          const entry = this.#cacheKeyToEntryMap.get(cacheKey);
          if (entry) {
            entry.invalidate();
          }
          this.#cacheKeyToEntryMap.delete(cacheKey);
        }
        this.#keyToCacheKeySetMap.delete(key.toString());
      }
      this.emit("invalidate", key);
    }
    clear(resetStats = true) {
      const oldSize = this.#cacheKeyToEntryMap.size;
      this.#cacheKeyToEntryMap.clear();
      this.#keyToCacheKeySetMap.clear();
      if (resetStats) {
        if (!(this.#statsCounter instanceof DisabledStatsCounter)) {
          this.#statsCounter = DefaultStatsCounter.create();
        }
      } else {
        if (oldSize > 0) {
          this.#statsCounter.recordEvictions(oldSize);
        }
      }
    }
    get(cacheKey) {
      const val = this.#cacheKeyToEntryMap.get(cacheKey);
      if (val && !val.validate()) {
        this.delete(cacheKey);
        this.#statsCounter.recordEvictions(1);
        this.emit("cache-evict", cacheKey);
        return;
      }
      if (val !== undefined && this.lru) {
        this.#cacheKeyToEntryMap.delete(cacheKey);
        this.#cacheKeyToEntryMap.set(cacheKey, val);
      }
      return val;
    }
    delete(cacheKey) {
      const entry = this.#cacheKeyToEntryMap.get(cacheKey);
      if (entry) {
        entry.invalidate();
        this.#cacheKeyToEntryMap.delete(cacheKey);
      }
    }
    has(cacheKey) {
      return this.#cacheKeyToEntryMap.has(cacheKey);
    }
    set(cacheKey, cacheEntry, keys) {
      let count = this.#cacheKeyToEntryMap.size;
      const oldEntry = this.#cacheKeyToEntryMap.get(cacheKey);
      if (oldEntry) {
        count--;
        oldEntry.invalidate();
      }
      if (this.maxEntries > 0 && count >= this.maxEntries) {
        this.deleteOldest();
        this.#statsCounter.recordEvictions(1);
      }
      this.#cacheKeyToEntryMap.set(cacheKey, cacheEntry);
      for (const key of keys) {
        if (!this.#keyToCacheKeySetMap.has(key.toString())) {
          this.#keyToCacheKeySetMap.set(key.toString(), new Set);
        }
        const cacheKeySet = this.#keyToCacheKeySetMap.get(key.toString());
        cacheKeySet.add(cacheKey);
      }
    }
    size() {
      return this.#cacheKeyToEntryMap.size;
    }
    createValueEntry(client, value) {
      return new ClientSideCacheEntryValue(this.ttl, value);
    }
    createPromiseEntry(client, sendCommandPromise) {
      return new ClientSideCacheEntryPromise(this.ttl, sendCommandPromise);
    }
    stats() {
      return this.#statsCounter.snapshot();
    }
    onError() {
      this.clear();
    }
    onClose() {
      this.clear();
    }
    deleteOldest() {
      const it = this.#cacheKeyToEntryMap[Symbol.iterator]();
      const n = it.next();
      if (!n.done) {
        const key = n.value[0];
        const entry = this.#cacheKeyToEntryMap.get(key);
        if (entry) {
          entry.invalidate();
        }
        this.#cacheKeyToEntryMap.delete(key);
      }
    }
    entryEntries() {
      return this.#cacheKeyToEntryMap.entries();
    }
    keySetEntries() {
      return this.#keyToCacheKeySetMap.entries();
    }
  }
  exports.BasicClientSideCache = BasicClientSideCache;

  class PooledClientSideCacheProvider extends BasicClientSideCache {
    #disabled = false;
    disable() {
      this.#disabled = true;
    }
    enable() {
      this.#disabled = false;
    }
    get(cacheKey) {
      if (this.#disabled) {
        return;
      }
      return super.get(cacheKey);
    }
    has(cacheKey) {
      if (this.#disabled) {
        return false;
      }
      return super.has(cacheKey);
    }
    onPoolClose() {
      this.clear();
    }
  }
  exports.PooledClientSideCacheProvider = PooledClientSideCacheProvider;

  class BasicPooledClientSideCache extends PooledClientSideCacheProvider {
    onError() {
      this.clear(false);
    }
    onClose() {
      this.clear(false);
    }
  }
  exports.BasicPooledClientSideCache = BasicPooledClientSideCache;

  class PooledClientSideCacheEntryValue extends ClientSideCacheEntryValue {
    #creator;
    constructor(ttl, creator, value) {
      super(ttl, value);
      this.#creator = creator;
    }
    validate() {
      let ret = super.validate();
      if (this.#creator) {
        ret = ret && this.#creator.client.isReady && this.#creator.client.socketEpoch == this.#creator.epoch;
      }
      return ret;
    }
  }

  class PooledClientSideCacheEntryPromise extends ClientSideCacheEntryPromise {
    #creator;
    constructor(ttl, creator, sendCommandPromise) {
      super(ttl, sendCommandPromise);
      this.#creator = creator;
    }
    validate() {
      let ret = super.validate();
      return ret && this.#creator.client.isReady && this.#creator.client.socketEpoch == this.#creator.epoch;
    }
  }

  class PooledNoRedirectClientSideCache extends BasicPooledClientSideCache {
    createValueEntry(client, value) {
      const creator = {
        epoch: client.socketEpoch,
        client
      };
      return new PooledClientSideCacheEntryValue(this.ttl, creator, value);
    }
    createPromiseEntry(client, sendCommandPromise) {
      const creator = {
        epoch: client.socketEpoch,
        client
      };
      return new PooledClientSideCacheEntryPromise(this.ttl, creator, sendCommandPromise);
    }
    onError() {}
    onClose() {}
  }
  exports.PooledNoRedirectClientSideCache = PooledNoRedirectClientSideCache;
});

// ../../node_modules/@redis/client/dist/lib/single-entry-cache.js
var require_single_entry_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class SingleEntryCache {
    #cached;
    #serializedKey;
    get(keyObj) {
      return JSON.stringify(keyObj, makeCircularReplacer()) === this.#serializedKey ? this.#cached : undefined;
    }
    set(keyObj, obj) {
      this.#cached = obj;
      this.#serializedKey = JSON.stringify(keyObj, makeCircularReplacer());
    }
  }
  exports.default = SingleEntryCache;
  function makeCircularReplacer() {
    const seen = new WeakSet;
    return function serialize(_, value) {
      if (value && typeof value === "object") {
        if (seen.has(value)) {
          return "circular";
        }
        seen.add(value);
        return value;
      }
      return value;
    };
  }
});

// ../../node_modules/@redis/client/dist/lib/client/pool.js
var require_pool = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisClientPool = undefined;
  var commands_1 = __importDefault(require_commands());
  var _1 = __importDefault(require_client());
  var node_events_1 = __require("events");
  var linked_list_1 = require_linked_list();
  var errors_1 = require_errors();
  var commander_1 = require_commander();
  var multi_command_1 = __importDefault(require_multi_command2());
  var cache_1 = require_cache();
  var parser_1 = require_parser();
  var single_entry_cache_1 = __importDefault(require_single_entry_cache());

  class RedisClientPool extends node_events_1.EventEmitter {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this.execute((client) => client._executeCommand(command, parser, this._commandOptions, transformReply));
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self.execute((client) => client._executeCommand(command, parser, this._self._commandOptions, transformReply));
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        return this._self.execute((client) => client._executeCommand(fn, parser, this._self._commandOptions, transformReply));
      };
    }
    static #createScriptCommand(script, resp) {
      const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.pushVariadic(prefix);
        script.parseCommand(parser, ...args);
        return this.execute((client) => client._executeScript(script, parser, this._commandOptions, transformReply));
      };
    }
    static #SingleEntryCache = new single_entry_cache_1.default;
    static create(clientOptions, options) {
      let Pool = RedisClientPool.#SingleEntryCache.get(clientOptions);
      if (!Pool) {
        Pool = (0, commander_1.attachConfig)({
          BaseClass: RedisClientPool,
          commands: commands_1.default,
          createCommand: RedisClientPool.#createCommand,
          createModuleCommand: RedisClientPool.#createModuleCommand,
          createFunctionCommand: RedisClientPool.#createFunctionCommand,
          createScriptCommand: RedisClientPool.#createScriptCommand,
          config: clientOptions
        });
        Pool.prototype.Multi = multi_command_1.default.extend(clientOptions);
        RedisClientPool.#SingleEntryCache.set(clientOptions, Pool);
      }
      return Object.create(new Pool(clientOptions, options));
    }
    static #DEFAULTS = {
      minimum: 1,
      maximum: 100,
      acquireTimeout: 3000,
      cleanupDelay: 3000
    };
    #clientFactory;
    #options;
    #idleClients = new linked_list_1.SinglyLinkedList;
    get idleClients() {
      return this._self.#idleClients.length;
    }
    #clientsInUse = new linked_list_1.DoublyLinkedList;
    get clientsInUse() {
      return this._self.#clientsInUse.length;
    }
    get totalClients() {
      return this._self.#idleClients.length + this._self.#clientsInUse.length;
    }
    #tasksQueue = new linked_list_1.SinglyLinkedList;
    get tasksQueueLength() {
      return this._self.#tasksQueue.length;
    }
    #isOpen = false;
    get isOpen() {
      return this._self.#isOpen;
    }
    #isClosing = false;
    get isClosing() {
      return this._self.#isClosing;
    }
    #clientSideCache;
    get clientSideCache() {
      return this._self.#clientSideCache;
    }
    constructor(clientOptions, options) {
      super();
      this.#options = {
        ...RedisClientPool.#DEFAULTS,
        ...options
      };
      if (options?.clientSideCache) {
        if (clientOptions === undefined) {
          clientOptions = {};
        }
        if (options.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
          this.#clientSideCache = clientOptions.clientSideCache = options.clientSideCache;
        } else {
          const cscConfig = options.clientSideCache;
          this.#clientSideCache = clientOptions.clientSideCache = new cache_1.BasicPooledClientSideCache(cscConfig);
        }
      }
      this.#clientFactory = _1.default.factory(clientOptions).bind(undefined, clientOptions);
    }
    _self = this;
    _commandOptions;
    withCommandOptions(options) {
      const proxy = Object.create(this._self);
      proxy._commandOptions = options;
      return proxy;
    }
    #commandOptionsProxy(key, value) {
      const proxy = Object.create(this._self);
      proxy._commandOptions = Object.create(this._commandOptions ?? null);
      proxy._commandOptions[key] = value;
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._self.#commandOptionsProxy("typeMapping", typeMapping);
    }
    withAbortSignal(abortSignal) {
      return this._self.#commandOptionsProxy("abortSignal", abortSignal);
    }
    asap() {
      return this._self.#commandOptionsProxy("asap", true);
    }
    async connect() {
      if (this._self.#isOpen)
        return;
      this._self.#isOpen = true;
      const promises = [];
      while (promises.length < this._self.#options.minimum) {
        promises.push(this._self.#create());
      }
      try {
        await Promise.all(promises);
      } catch (err) {
        this.destroy();
        throw err;
      }
      return this;
    }
    async#create() {
      const node = this._self.#clientsInUse.push(this._self.#clientFactory().on("error", (err) => this.emit("error", err)));
      try {
        const client = node.value;
        await client.connect();
      } catch (err) {
        this._self.#clientsInUse.remove(node);
        throw err;
      }
      this._self.#returnClient(node);
    }
    execute(fn) {
      return new Promise((resolve, reject) => {
        const client = this._self.#idleClients.shift(), { tail } = this._self.#tasksQueue;
        if (!client) {
          let timeout;
          if (this._self.#options.acquireTimeout > 0) {
            timeout = setTimeout(() => {
              this._self.#tasksQueue.remove(task, tail);
              reject(new errors_1.TimeoutError("Timeout waiting for a client"));
            }, this._self.#options.acquireTimeout);
          }
          const task = this._self.#tasksQueue.push({
            timeout,
            resolve,
            reject,
            fn
          });
          if (this.totalClients < this._self.#options.maximum) {
            this._self.#create();
          }
          return;
        }
        const node = this._self.#clientsInUse.push(client);
        this._self.#executeTask(node, resolve, reject, fn);
      });
    }
    #executeTask(node, resolve, reject, fn) {
      const result = fn(node.value);
      if (result instanceof Promise) {
        result.then(resolve, reject);
        result.finally(() => this.#returnClient(node));
      } else {
        resolve(result);
        this.#returnClient(node);
      }
    }
    #returnClient(node) {
      const task = this.#tasksQueue.shift();
      if (task) {
        clearTimeout(task.timeout);
        this.#executeTask(node, task.resolve, task.reject, task.fn);
        return;
      }
      this.#clientsInUse.remove(node);
      this.#idleClients.push(node.value);
      this.#scheduleCleanup();
    }
    cleanupTimeout;
    #scheduleCleanup() {
      if (this.totalClients <= this.#options.minimum)
        return;
      clearTimeout(this.cleanupTimeout);
      this.cleanupTimeout = setTimeout(() => this.#cleanup(), this.#options.cleanupDelay);
    }
    #cleanup() {
      const toDestroy = Math.min(this.#idleClients.length, this.totalClients - this.#options.minimum);
      for (let i = 0;i < toDestroy; i++) {
        const client = this.#idleClients.shift();
        client.destroy();
      }
    }
    sendCommand(args, options) {
      return this.execute((client) => client.sendCommand(args, options));
    }
    MULTI() {
      return new this.Multi((commands, selectedDB) => this.execute((client) => client._executeMulti(commands, selectedDB)), (commands) => this.execute((client) => client._executePipeline(commands)), this._commandOptions?.typeMapping);
    }
    multi = this.MULTI;
    async close() {
      if (this._self.#isClosing)
        return;
      if (!this._self.#isOpen)
        return;
      this._self.#isClosing = true;
      try {
        const promises = [];
        for (const client of this._self.#idleClients) {
          promises.push(client.close());
        }
        for (const client of this._self.#clientsInUse) {
          promises.push(client.close());
        }
        await Promise.all(promises);
        this.#clientSideCache?.onPoolClose();
        this._self.#idleClients.reset();
        this._self.#clientsInUse.reset();
      } catch (err) {} finally {
        this._self.#isClosing = false;
      }
    }
    destroy() {
      for (const client of this._self.#idleClients) {
        client.destroy();
      }
      this._self.#idleClients.reset();
      for (const client of this._self.#clientsInUse) {
        client.destroy();
      }
      this._self.#clientSideCache?.onPoolClose();
      this._self.#clientsInUse.reset();
      this._self.#isOpen = false;
    }
  }
  exports.RedisClientPool = RedisClientPool;
});

// ../../node_modules/@redis/client/dist/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "@redis/client",
    version: "5.5.6",
    license: "MIT",
    main: "./dist/index.js",
    types: "./dist/index.d.ts",
    files: [
      "dist/",
      "!dist/tsconfig.tsbuildinfo"
    ],
    scripts: {
      test: "nyc -r text-summary -r lcov mocha -r tsx './lib/**/*.spec.ts'",
      release: "release-it"
    },
    dependencies: {
      "cluster-key-slot": "1.1.2"
    },
    devDependencies: {
      "@redis/test-utils": "*",
      "@types/sinon": "^17.0.3",
      sinon: "^17.0.1"
    },
    engines: {
      node: ">= 18"
    },
    repository: {
      type: "git",
      url: "git://github.com/redis/node-redis.git"
    },
    bugs: {
      url: "https://github.com/redis/node-redis/issues"
    },
    homepage: "https://github.com/redis/node-redis/tree/master/packages/client",
    keywords: [
      "redis"
    ]
  };
});

// ../../node_modules/@redis/client/dist/lib/client/index.js
var require_client = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var socket_1 = __importDefault(require_socket());
  var authx_1 = require_authx();
  var commands_queue_1 = __importDefault(require_commands_queue());
  var node_events_1 = __require("events");
  var commander_1 = require_commander();
  var errors_1 = require_errors();
  var node_url_1 = __require("url");
  var pub_sub_1 = require_pub_sub();
  var multi_command_1 = __importDefault(require_multi_command2());
  var HELLO_1 = __importDefault(require_HELLO());
  var legacy_mode_1 = require_legacy_mode();
  var pool_1 = require_pool();
  var generic_transformers_1 = require_generic_transformers();
  var cache_1 = require_cache();
  var parser_1 = require_parser();
  var single_entry_cache_1 = __importDefault(require_single_entry_cache());
  var package_json_1 = require_package();

  class RedisClient extends node_events_1.EventEmitter {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self._executeCommand(command, parser, this._commandOptions, transformReply);
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self._executeCommand(command, parser, this._self._commandOptions, transformReply);
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        return this._self._executeCommand(fn, parser, this._self._commandOptions, transformReply);
      };
    }
    static #createScriptCommand(script, resp) {
      const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        script.parseCommand(parser, ...args);
        return this._executeScript(script, parser, this._commandOptions, transformReply);
      };
    }
    static #SingleEntryCache = new single_entry_cache_1.default;
    static factory(config) {
      let Client = _a.#SingleEntryCache.get(config);
      if (!Client) {
        Client = (0, commander_1.attachConfig)({
          BaseClass: _a,
          commands: commands_1.default,
          createCommand: _a.#createCommand,
          createModuleCommand: _a.#createModuleCommand,
          createFunctionCommand: _a.#createFunctionCommand,
          createScriptCommand: _a.#createScriptCommand,
          config
        });
        Client.prototype.Multi = multi_command_1.default.extend(config);
        _a.#SingleEntryCache.set(config, Client);
      }
      return (options) => {
        return Object.create(new Client(options));
      };
    }
    static create(options) {
      return _a.factory(options)(options);
    }
    static parseURL(url2) {
      const { hostname, port, protocol, username, password, pathname } = new node_url_1.URL(url2), parsed = {
        socket: {
          host: hostname
        }
      };
      if (protocol === "rediss:") {
        parsed.socket.tls = true;
      } else if (protocol !== "redis:") {
        throw new TypeError("Invalid protocol");
      }
      if (port) {
        parsed.socket.port = Number(port);
      }
      if (username) {
        parsed.username = decodeURIComponent(username);
      }
      if (password) {
        parsed.password = decodeURIComponent(password);
      }
      if (username || password) {
        parsed.credentialsProvider = {
          type: "async-credentials-provider",
          credentials: async () => ({
            username: username ? decodeURIComponent(username) : undefined,
            password: password ? decodeURIComponent(password) : undefined
          })
        };
      }
      if (pathname.length > 1) {
        const database = Number(pathname.substring(1));
        if (isNaN(database)) {
          throw new TypeError("Invalid pathname");
        }
        parsed.database = database;
      }
      return parsed;
    }
    #options;
    #socket;
    #queue;
    #selectedDB = 0;
    #monitorCallback;
    _self = this;
    _commandOptions;
    #dirtyWatch;
    #watchEpoch;
    #clientSideCache;
    #credentialsSubscription = null;
    get clientSideCache() {
      return this._self.#clientSideCache;
    }
    get options() {
      return this._self.#options;
    }
    get isOpen() {
      return this._self.#socket.isOpen;
    }
    get isReady() {
      return this._self.#socket.isReady;
    }
    get isPubSubActive() {
      return this._self.#queue.isPubSubActive;
    }
    get socketEpoch() {
      return this._self.#socket.socketEpoch;
    }
    get isWatching() {
      return this._self.#watchEpoch !== undefined;
    }
    get isDirtyWatch() {
      return this._self.#dirtyWatch !== undefined;
    }
    setDirtyWatch(msg) {
      this._self.#dirtyWatch = msg;
    }
    constructor(options) {
      super();
      this.#validateOptions(options);
      this.#options = this.#initiateOptions(options);
      this.#queue = this.#initiateQueue();
      this.#socket = this.#initiateSocket();
      if (options?.clientSideCache) {
        if (options.clientSideCache instanceof cache_1.ClientSideCacheProvider) {
          this.#clientSideCache = options.clientSideCache;
        } else {
          const cscConfig = options.clientSideCache;
          this.#clientSideCache = new cache_1.BasicClientSideCache(cscConfig);
        }
        this.#queue.setInvalidateCallback(this.#clientSideCache.invalidate.bind(this.#clientSideCache));
      }
    }
    #validateOptions(options) {
      if (options?.clientSideCache && options?.RESP !== 3) {
        throw new Error("Client Side Caching is only supported with RESP3");
      }
    }
    #initiateOptions(options) {
      if (!options?.credentialsProvider && (options?.username || options?.password)) {
        options.credentialsProvider = {
          type: "async-credentials-provider",
          credentials: async () => ({
            username: options.username,
            password: options.password
          })
        };
      }
      if (options?.url) {
        const parsed = _a.parseURL(options.url);
        if (options.socket) {
          parsed.socket = Object.assign(options.socket, parsed.socket);
        }
        Object.assign(options, parsed);
      }
      if (options?.database) {
        this._self.#selectedDB = options.database;
      }
      if (options?.commandOptions) {
        this._commandOptions = options.commandOptions;
      }
      return options;
    }
    #initiateQueue() {
      return new commands_queue_1.default(this.#options?.RESP ?? 2, this.#options?.commandsQueueMaxLength, (channel, listeners) => this.emit("sharded-channel-moved", channel, listeners));
    }
    reAuthenticate = async (credentials) => {
      if (!(this.isPubSubActive && !this.#options?.RESP)) {
        await this.sendCommand((0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
          username: credentials.username,
          password: credentials.password ?? ""
        }));
      }
    };
    #subscribeForStreamingCredentials(cp) {
      return cp.subscribe({
        onNext: (credentials) => {
          this.reAuthenticate(credentials).catch((error) => {
            const errorMessage = error instanceof Error ? error.message : String(error);
            cp.onReAuthenticationError(new authx_1.CredentialsError(errorMessage));
          });
        },
        onError: (e) => {
          const errorMessage = `Error from streaming credentials provider: ${e.message}`;
          cp.onReAuthenticationError(new authx_1.UnableToObtainNewCredentialsError(errorMessage));
        }
      });
    }
    async#handshake(chainId, asap2) {
      const promises = [];
      const commandsWithErrorHandlers = await this.#getHandshakeCommands();
      if (asap2)
        commandsWithErrorHandlers.reverse();
      for (const { cmd, errorHandler } of commandsWithErrorHandlers) {
        promises.push(this.#queue.addCommand(cmd, {
          chainId,
          asap: asap2
        }).catch(errorHandler));
      }
      return promises;
    }
    async#getHandshakeCommands() {
      const commands = [];
      const cp = this.#options?.credentialsProvider;
      if (this.#options?.RESP) {
        const hello = {};
        if (cp && cp.type === "async-credentials-provider") {
          const credentials = await cp.credentials();
          if (credentials.password) {
            hello.AUTH = {
              username: credentials.username ?? "default",
              password: credentials.password
            };
          }
        }
        if (cp && cp.type === "streaming-credentials-provider") {
          const [credentials, disposable] = await this.#subscribeForStreamingCredentials(cp);
          this.#credentialsSubscription = disposable;
          if (credentials.password) {
            hello.AUTH = {
              username: credentials.username ?? "default",
              password: credentials.password
            };
          }
        }
        if (this.#options.name) {
          hello.SETNAME = this.#options.name;
        }
        commands.push({ cmd: (0, generic_transformers_1.parseArgs)(HELLO_1.default, this.#options.RESP, hello) });
      } else {
        if (cp && cp.type === "async-credentials-provider") {
          const credentials = await cp.credentials();
          if (credentials.username || credentials.password) {
            commands.push({
              cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
                username: credentials.username,
                password: credentials.password ?? ""
              })
            });
          }
        }
        if (cp && cp.type === "streaming-credentials-provider") {
          const [credentials, disposable] = await this.#subscribeForStreamingCredentials(cp);
          this.#credentialsSubscription = disposable;
          if (credentials.username || credentials.password) {
            commands.push({
              cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
                username: credentials.username,
                password: credentials.password ?? ""
              })
            });
          }
        }
        if (this.#options?.name) {
          commands.push({
            cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.CLIENT_SETNAME, this.#options.name)
          });
        }
      }
      if (this.#selectedDB !== 0) {
        commands.push({ cmd: ["SELECT", this.#selectedDB.toString()] });
      }
      if (this.#options?.readonly) {
        commands.push({ cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.READONLY) });
      }
      if (!this.#options?.disableClientInfo) {
        commands.push({
          cmd: ["CLIENT", "SETINFO", "LIB-VER", package_json_1.version],
          errorHandler: () => {}
        });
        commands.push({
          cmd: [
            "CLIENT",
            "SETINFO",
            "LIB-NAME",
            this.#options?.clientInfoTag ? `node-redis(${this.#options.clientInfoTag})` : "node-redis"
          ],
          errorHandler: () => {}
        });
      }
      if (this.#clientSideCache) {
        commands.push({ cmd: this.#clientSideCache.trackingOn() });
      }
      return commands;
    }
    #initiateSocket() {
      const socketInitiator = async () => {
        const promises = [], chainId = Symbol("Socket Initiator");
        const resubscribePromise = this.#queue.resubscribe(chainId);
        if (resubscribePromise) {
          promises.push(resubscribePromise);
        }
        if (this.#monitorCallback) {
          promises.push(this.#queue.monitor(this.#monitorCallback, {
            typeMapping: this._commandOptions?.typeMapping,
            chainId,
            asap: true
          }));
        }
        promises.push(...await this.#handshake(chainId, true));
        if (promises.length) {
          this.#write();
          return Promise.all(promises);
        }
      };
      return new socket_1.default(socketInitiator, this.#options?.socket).on("data", (chunk) => {
        try {
          this.#queue.decoder.write(chunk);
        } catch (err) {
          this.#queue.resetDecoder();
          this.emit("error", err);
        }
      }).on("error", (err) => {
        this.emit("error", err);
        this.#clientSideCache?.onError();
        if (this.#socket.isOpen && !this.#options?.disableOfflineQueue) {
          this.#queue.flushWaitingForReply(err);
        } else {
          this.#queue.flushAll(err);
        }
      }).on("connect", () => this.emit("connect")).on("ready", () => {
        this.emit("ready");
        this.#setPingTimer();
        this.#maybeScheduleWrite();
      }).on("reconnecting", () => this.emit("reconnecting")).on("drain", () => this.#maybeScheduleWrite()).on("end", () => this.emit("end"));
    }
    #pingTimer;
    #setPingTimer() {
      if (!this.#options?.pingInterval || !this.#socket.isReady)
        return;
      clearTimeout(this.#pingTimer);
      this.#pingTimer = setTimeout(() => {
        if (!this.#socket.isReady)
          return;
        this.sendCommand(["PING"]).then((reply) => this.emit("ping-interval", reply)).catch((err) => this.emit("error", err)).finally(() => this.#setPingTimer());
      }, this.#options.pingInterval);
    }
    withCommandOptions(options) {
      const proxy = Object.create(this._self);
      proxy._commandOptions = options;
      return proxy;
    }
    _commandOptionsProxy(key, value) {
      const proxy = Object.create(this._self);
      proxy._commandOptions = Object.create(this._commandOptions ?? null);
      proxy._commandOptions[key] = value;
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._commandOptionsProxy("typeMapping", typeMapping);
    }
    withAbortSignal(abortSignal) {
      return this._commandOptionsProxy("abortSignal", abortSignal);
    }
    asap() {
      return this._commandOptionsProxy("asap", true);
    }
    legacy() {
      return new legacy_mode_1.RedisLegacyClient(this);
    }
    createPool(options) {
      return pool_1.RedisClientPool.create(this._self.#options, options);
    }
    duplicate(overrides) {
      return new (Object.getPrototypeOf(this)).constructor({
        ...this._self.#options,
        commandOptions: this._commandOptions,
        ...overrides
      });
    }
    async connect() {
      await this._self.#socket.connect();
      return this;
    }
    async _executeCommand(command, parser, commandOptions, transformReply) {
      const csc = this._self.#clientSideCache;
      const defaultTypeMapping = this._self.#options?.commandOptions === commandOptions;
      const fn = () => {
        return this.sendCommand(parser.redisArgs, commandOptions);
      };
      if (csc && command.CACHEABLE && defaultTypeMapping) {
        return await csc.handleCache(this._self, parser, fn, transformReply, commandOptions?.typeMapping);
      } else {
        const reply = await fn();
        if (transformReply) {
          return transformReply(reply, parser.preserve, commandOptions?.typeMapping);
        }
        return reply;
      }
    }
    async _executeScript(script, parser, options, transformReply) {
      const args = parser.redisArgs;
      let reply;
      try {
        reply = await this.sendCommand(args, options);
      } catch (err) {
        if (!err?.message?.startsWith?.("NOSCRIPT"))
          throw err;
        args[0] = "EVAL";
        args[1] = script.SCRIPT;
        reply = await this.sendCommand(args, options);
      }
      return transformReply ? transformReply(reply, parser.preserve, options?.typeMapping) : reply;
    }
    sendCommand(args, options) {
      if (!this._self.#socket.isOpen) {
        return Promise.reject(new errors_1.ClientClosedError);
      } else if (!this._self.#socket.isReady && this._self.#options?.disableOfflineQueue) {
        return Promise.reject(new errors_1.ClientOfflineError);
      }
      const opts = {
        ...this._self._commandOptions,
        ...options
      };
      const promise = this._self.#queue.addCommand(args, opts);
      this._self.#scheduleWrite();
      return promise;
    }
    async SELECT(db) {
      await this.sendCommand(["SELECT", db.toString()]);
      this._self.#selectedDB = db;
    }
    select = this.SELECT;
    #pubSubCommand(promise) {
      if (promise === undefined)
        return Promise.resolve();
      this.#scheduleWrite();
      return promise;
    }
    SUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.CHANNELS, channels, listener, bufferMode));
    }
    subscribe = this.SUBSCRIBE;
    UNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.CHANNELS, channels, listener, bufferMode));
    }
    unsubscribe = this.UNSUBSCRIBE;
    PSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.PATTERNS, patterns, listener, bufferMode));
    }
    pSubscribe = this.PSUBSCRIBE;
    PUNSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.PATTERNS, patterns, listener, bufferMode));
    }
    pUnsubscribe = this.PUNSUBSCRIBE;
    SSUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.SHARDED, channels, listener, bufferMode));
    }
    sSubscribe = this.SSUBSCRIBE;
    SUNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.SHARDED, channels, listener, bufferMode));
    }
    sUnsubscribe = this.SUNSUBSCRIBE;
    async WATCH(key) {
      const reply = await this._self.sendCommand((0, generic_transformers_1.pushVariadicArguments)(["WATCH"], key));
      this._self.#watchEpoch ??= this._self.socketEpoch;
      return reply;
    }
    watch = this.WATCH;
    async UNWATCH() {
      const reply = await this._self.sendCommand(["UNWATCH"]);
      this._self.#watchEpoch = undefined;
      return reply;
    }
    unwatch = this.UNWATCH;
    getPubSubListeners(type) {
      return this._self.#queue.getPubSubListeners(type);
    }
    extendPubSubChannelListeners(type, channel, listeners) {
      return this._self.#pubSubCommand(this._self.#queue.extendPubSubChannelListeners(type, channel, listeners));
    }
    extendPubSubListeners(type, listeners) {
      return this._self.#pubSubCommand(this._self.#queue.extendPubSubListeners(type, listeners));
    }
    #write() {
      this.#socket.write(this.#queue.commandsToWrite());
    }
    #scheduledWrite;
    #scheduleWrite() {
      if (!this.#socket.isReady || this.#scheduledWrite)
        return;
      this.#scheduledWrite = setImmediate(() => {
        this.#write();
        this.#scheduledWrite = undefined;
      });
    }
    #maybeScheduleWrite() {
      if (!this.#queue.isWaitingToWrite())
        return;
      this.#scheduleWrite();
    }
    async _executePipeline(commands, selectedDB) {
      if (!this._self.#socket.isOpen) {
        return Promise.reject(new errors_1.ClientClosedError);
      }
      const chainId = Symbol("Pipeline Chain"), promise = Promise.all(commands.map(({ args }) => this._self.#queue.addCommand(args, {
        chainId,
        typeMapping: this._commandOptions?.typeMapping
      })));
      this._self.#scheduleWrite();
      const result = await promise;
      if (selectedDB !== undefined) {
        this._self.#selectedDB = selectedDB;
      }
      return result;
    }
    async _executeMulti(commands, selectedDB) {
      const dirtyWatch = this._self.#dirtyWatch;
      this._self.#dirtyWatch = undefined;
      const watchEpoch = this._self.#watchEpoch;
      this._self.#watchEpoch = undefined;
      if (!this._self.#socket.isOpen) {
        throw new errors_1.ClientClosedError;
      }
      if (dirtyWatch) {
        throw new errors_1.WatchError(dirtyWatch);
      }
      if (watchEpoch && watchEpoch !== this._self.socketEpoch) {
        throw new errors_1.WatchError("Client reconnected after WATCH");
      }
      const typeMapping = this._commandOptions?.typeMapping;
      const chainId = Symbol("MULTI Chain");
      const promises = [
        this._self.#queue.addCommand(["MULTI"], { chainId })
      ];
      for (const { args } of commands) {
        promises.push(this._self.#queue.addCommand(args, {
          chainId,
          typeMapping
        }));
      }
      promises.push(this._self.#queue.addCommand(["EXEC"], { chainId }));
      this._self.#scheduleWrite();
      const results = await Promise.all(promises), execResult = results[results.length - 1];
      if (execResult === null) {
        throw new errors_1.WatchError;
      }
      if (selectedDB !== undefined) {
        this._self.#selectedDB = selectedDB;
      }
      return execResult;
    }
    MULTI() {
      return new this.Multi(this._executeMulti.bind(this), this._executePipeline.bind(this), this._commandOptions?.typeMapping);
    }
    multi = this.MULTI;
    async* scanIterator(options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.scan(cursor, options);
        cursor = reply.cursor;
        yield reply.keys;
      } while (cursor !== "0");
    }
    async* hScanIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.hScan(key, cursor, options);
        cursor = reply.cursor;
        yield reply.entries;
      } while (cursor !== "0");
    }
    async* hScanValuesIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.hScanNoValues(key, cursor, options);
        cursor = reply.cursor;
        yield reply.fields;
      } while (cursor !== "0");
    }
    async* hScanNoValuesIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.hScanNoValues(key, cursor, options);
        cursor = reply.cursor;
        yield reply.fields;
      } while (cursor !== "0");
    }
    async* sScanIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.sScan(key, cursor, options);
        cursor = reply.cursor;
        yield reply.members;
      } while (cursor !== "0");
    }
    async* zScanIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.zScan(key, cursor, options);
        cursor = reply.cursor;
        yield reply.members;
      } while (cursor !== "0");
    }
    async MONITOR(callback) {
      const promise = this._self.#queue.monitor(callback, {
        typeMapping: this._commandOptions?.typeMapping
      });
      this._self.#scheduleWrite();
      await promise;
      this._self.#monitorCallback = callback;
    }
    monitor = this.MONITOR;
    async reset() {
      const chainId = Symbol("Reset Chain"), promises = [this._self.#queue.reset(chainId)], selectedDB = this._self.#options?.database ?? 0;
      this._self.#credentialsSubscription?.dispose();
      this._self.#credentialsSubscription = null;
      promises.push(...await this._self.#handshake(chainId, false));
      this._self.#scheduleWrite();
      await Promise.all(promises);
      this._self.#selectedDB = selectedDB;
      this._self.#monitorCallback = undefined;
      this._self.#dirtyWatch = undefined;
      this._self.#watchEpoch = undefined;
    }
    resetIfDirty() {
      let shouldReset = false;
      if (this._self.#selectedDB !== (this._self.#options?.database ?? 0)) {
        console.warn("Returning a client with a different selected DB");
        shouldReset = true;
      }
      if (this._self.#monitorCallback) {
        console.warn("Returning a client with active MONITOR");
        shouldReset = true;
      }
      if (this._self.#queue.isPubSubActive) {
        console.warn("Returning a client with active PubSub");
        shouldReset = true;
      }
      if (this._self.#dirtyWatch || this._self.#watchEpoch) {
        console.warn("Returning a client with active WATCH");
        shouldReset = true;
      }
      if (shouldReset) {
        return this.reset();
      }
    }
    QUIT() {
      this._self.#credentialsSubscription?.dispose();
      this._self.#credentialsSubscription = null;
      return this._self.#socket.quit(async () => {
        clearTimeout(this._self.#pingTimer);
        const quitPromise = this._self.#queue.addCommand(["QUIT"]);
        this._self.#scheduleWrite();
        return quitPromise;
      });
    }
    quit = this.QUIT;
    disconnect() {
      return Promise.resolve(this.destroy());
    }
    close() {
      return new Promise((resolve) => {
        clearTimeout(this._self.#pingTimer);
        this._self.#socket.close();
        this._self.#clientSideCache?.onClose();
        if (this._self.#queue.isEmpty()) {
          this._self.#socket.destroySocket();
          return resolve();
        }
        const maybeClose = () => {
          if (!this._self.#queue.isEmpty())
            return;
          this._self.#socket.off("data", maybeClose);
          this._self.#socket.destroySocket();
          resolve();
        };
        this._self.#socket.on("data", maybeClose);
        this._self.#credentialsSubscription?.dispose();
        this._self.#credentialsSubscription = null;
      });
    }
    destroy() {
      clearTimeout(this._self.#pingTimer);
      this._self.#queue.flushAll(new errors_1.DisconnectsClientError);
      this._self.#socket.destroy();
      this._self.#clientSideCache?.onClose();
      this._self.#credentialsSubscription?.dispose();
      this._self.#credentialsSubscription = null;
    }
    ref() {
      this._self.#socket.ref();
    }
    unref() {
      this._self.#socket.unref();
    }
  }
  _a = RedisClient;
  exports.default = RedisClient;
});

// ../../node_modules/cluster-key-slot/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var lookup = [
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
  ];
  var toUTF8Array = function toUTF8Array(str) {
    var char;
    var i = 0;
    var p = 0;
    var utf8 = [];
    var len = str.length;
    for (;i < len; i++) {
      char = str.charCodeAt(i);
      if (char < 128) {
        utf8[p++] = char;
      } else if (char < 2048) {
        utf8[p++] = char >> 6 | 192;
        utf8[p++] = char & 63 | 128;
      } else if ((char & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
        char = 65536 + ((char & 1023) << 10) + (str.charCodeAt(++i) & 1023);
        utf8[p++] = char >> 18 | 240;
        utf8[p++] = char >> 12 & 63 | 128;
        utf8[p++] = char >> 6 & 63 | 128;
        utf8[p++] = char & 63 | 128;
      } else {
        utf8[p++] = char >> 12 | 224;
        utf8[p++] = char >> 6 & 63 | 128;
        utf8[p++] = char & 63 | 128;
      }
    }
    return utf8;
  };
  var generate = module.exports = function generate(str) {
    var char;
    var i = 0;
    var start = -1;
    var result = 0;
    var resultHash = 0;
    var utf8 = typeof str === "string" ? toUTF8Array(str) : str;
    var len = utf8.length;
    while (i < len) {
      char = utf8[i++];
      if (start === -1) {
        if (char === 123) {
          start = i;
        }
      } else if (char !== 125) {
        resultHash = lookup[(char ^ resultHash >> 8) & 255] ^ resultHash << 8;
      } else if (i - 1 !== start) {
        return resultHash & 16383;
      }
      result = lookup[(char ^ result >> 8) & 255] ^ result << 8;
    }
    return result & 16383;
  };
  module.exports.generateMulti = function generateMulti(keys) {
    var i = 1;
    var len = keys.length;
    var base = generate(keys[0]);
    while (i < len) {
      if (generate(keys[i++]) !== base)
        return -1;
    }
    return base;
  };
});

// ../../node_modules/@redis/client/dist/lib/cluster/cluster-slots.js
var require_cluster_slots = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_1 = require_errors();
  var client_1 = __importDefault(require_client());
  var pub_sub_1 = require_pub_sub();
  var cluster_key_slot_1 = __importDefault(require_lib());
  var cache_1 = require_cache();

  class RedisClusterSlots {
    static #SLOTS = 16384;
    #options;
    #clientFactory;
    #emit;
    slots = new Array(_a.#SLOTS);
    masters = new Array;
    replicas = new Array;
    nodeByAddress = new Map;
    pubSubNode;
    clientSideCache;
    #isOpen = false;
    get isOpen() {
      return this.#isOpen;
    }
    #validateOptions(options) {
      if (options?.clientSideCache && options?.RESP !== 3) {
        throw new Error("Client Side Caching is only supported with RESP3");
      }
    }
    constructor(options, emit) {
      this.#validateOptions(options);
      this.#options = options;
      if (options?.clientSideCache) {
        if (options.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
          this.clientSideCache = options.clientSideCache;
        } else {
          this.clientSideCache = new cache_1.BasicPooledClientSideCache(options.clientSideCache);
        }
      }
      this.#clientFactory = client_1.default.factory(this.#options);
      this.#emit = emit;
    }
    async connect() {
      if (this.#isOpen) {
        throw new Error("Cluster already open");
      }
      this.#isOpen = true;
      try {
        await this.#discoverWithRootNodes();
      } catch (err) {
        this.#isOpen = false;
        throw err;
      }
    }
    async#discoverWithRootNodes() {
      let start = Math.floor(Math.random() * this.#options.rootNodes.length);
      for (let i = start;i < this.#options.rootNodes.length; i++) {
        if (!this.#isOpen)
          throw new Error("Cluster closed");
        if (await this.#discover(this.#options.rootNodes[i]))
          return;
      }
      for (let i = 0;i < start; i++) {
        if (!this.#isOpen)
          throw new Error("Cluster closed");
        if (await this.#discover(this.#options.rootNodes[i]))
          return;
      }
      throw new errors_1.RootNodesUnavailableError;
    }
    #resetSlots() {
      this.slots = new Array(_a.#SLOTS);
      this.masters = [];
      this.replicas = [];
      this._randomNodeIterator = undefined;
    }
    async#discover(rootNode) {
      this.clientSideCache?.clear();
      this.clientSideCache?.disable();
      try {
        const addressesInUse = new Set, promises = [], eagerConnect = this.#options.minimizeConnections !== true;
        const shards = await this.#getShards(rootNode);
        this.#resetSlots();
        for (const { from, to, master, replicas } of shards) {
          const shard = {
            master: this.#initiateSlotNode(master, false, eagerConnect, addressesInUse, promises)
          };
          if (this.#options.useReplicas) {
            shard.replicas = replicas.map((replica) => this.#initiateSlotNode(replica, true, eagerConnect, addressesInUse, promises));
          }
          for (let i = from;i <= to; i++) {
            this.slots[i] = shard;
          }
        }
        if (this.pubSubNode && !addressesInUse.has(this.pubSubNode.address)) {
          const channelsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS), patternsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS);
          this.pubSubNode.client.destroy();
          if (channelsListeners.size || patternsListeners.size) {
            promises.push(this.#initiatePubSubClient({
              [pub_sub_1.PUBSUB_TYPE.CHANNELS]: channelsListeners,
              [pub_sub_1.PUBSUB_TYPE.PATTERNS]: patternsListeners
            }));
          }
        }
        for (const [address, node] of this.nodeByAddress.entries()) {
          if (addressesInUse.has(address))
            continue;
          if (node.client) {
            node.client.destroy();
          }
          const { pubSub } = node;
          if (pubSub) {
            pubSub.client.destroy();
          }
          this.nodeByAddress.delete(address);
        }
        await Promise.all(promises);
        this.clientSideCache?.enable();
        return true;
      } catch (err) {
        this.#emit("error", err);
        return false;
      }
    }
    async#getShards(rootNode) {
      const options = this.#clientOptionsDefaults(rootNode);
      options.socket ??= {};
      options.socket.reconnectStrategy = false;
      options.RESP = this.#options.RESP;
      options.commandOptions = undefined;
      const client = await this.#clientFactory(options).on("error", (err) => this.#emit("error", err)).connect();
      try {
        return await client.clusterSlots();
      } finally {
        client.destroy();
      }
    }
    #getNodeAddress(address) {
      switch (typeof this.#options.nodeAddressMap) {
        case "object":
          return this.#options.nodeAddressMap[address];
        case "function":
          return this.#options.nodeAddressMap(address);
      }
    }
    #clientOptionsDefaults(options) {
      if (!this.#options.defaults)
        return options;
      let socket;
      if (this.#options.defaults.socket) {
        socket = {
          ...this.#options.defaults.socket,
          ...options?.socket
        };
      } else {
        socket = options?.socket;
      }
      return {
        ...this.#options.defaults,
        ...options,
        socket
      };
    }
    #initiateSlotNode(shard, readonly, eagerConnent, addressesInUse, promises) {
      const address = `${shard.host}:${shard.port}`;
      let node = this.nodeByAddress.get(address);
      if (!node) {
        node = {
          ...shard,
          address,
          readonly,
          client: undefined,
          connectPromise: undefined
        };
        if (eagerConnent) {
          promises.push(this.#createNodeClient(node));
        }
        this.nodeByAddress.set(address, node);
      }
      if (!addressesInUse.has(address)) {
        addressesInUse.add(address);
        (readonly ? this.replicas : this.masters).push(node);
      }
      return node;
    }
    #createClient(node, readonly = node.readonly) {
      return this.#clientFactory(this.#clientOptionsDefaults({
        clientSideCache: this.clientSideCache,
        RESP: this.#options.RESP,
        socket: this.#getNodeAddress(node.address) ?? {
          host: node.host,
          port: node.port
        },
        readonly
      })).on("error", (err) => console.error(err));
    }
    #createNodeClient(node, readonly) {
      const client = node.client = this.#createClient(node, readonly);
      return node.connectPromise = client.connect().finally(() => node.connectPromise = undefined);
    }
    nodeClient(node) {
      return node.connectPromise ?? node.client ?? this.#createNodeClient(node);
    }
    #runningRediscoverPromise;
    async rediscover(startWith) {
      this.#runningRediscoverPromise ??= this.#rediscover(startWith).finally(() => this.#runningRediscoverPromise = undefined);
      return this.#runningRediscoverPromise;
    }
    async#rediscover(startWith) {
      if (await this.#discover(startWith.options))
        return;
      return this.#discoverWithRootNodes();
    }
    quit() {
      return this.#destroy((client) => client.quit());
    }
    disconnect() {
      return this.#destroy((client) => client.disconnect());
    }
    close() {
      return this.#destroy((client) => client.close());
    }
    destroy() {
      this.#isOpen = false;
      for (const client of this.#clients()) {
        client.destroy();
      }
      if (this.pubSubNode) {
        this.pubSubNode.client.destroy();
        this.pubSubNode = undefined;
      }
      this.#resetSlots();
      this.nodeByAddress.clear();
    }
    *#clients() {
      for (const master of this.masters) {
        if (master.client) {
          yield master.client;
        }
        if (master.pubSub) {
          yield master.pubSub.client;
        }
      }
      for (const replica of this.replicas) {
        if (replica.client) {
          yield replica.client;
        }
      }
    }
    async#destroy(fn) {
      this.#isOpen = false;
      const promises = [];
      for (const client of this.#clients()) {
        promises.push(fn(client));
      }
      if (this.pubSubNode) {
        promises.push(fn(this.pubSubNode.client));
        this.pubSubNode = undefined;
      }
      this.#resetSlots();
      this.nodeByAddress.clear();
      await Promise.allSettled(promises);
    }
    getClient(firstKey, isReadonly) {
      if (!firstKey) {
        return this.nodeClient(this.getRandomNode());
      }
      const slotNumber = (0, cluster_key_slot_1.default)(firstKey);
      if (!isReadonly) {
        return this.nodeClient(this.slots[slotNumber].master);
      }
      return this.nodeClient(this.getSlotRandomNode(slotNumber));
    }
    *#iterateAllNodes() {
      let i = Math.floor(Math.random() * (this.masters.length + this.replicas.length));
      if (i < this.masters.length) {
        do {
          yield this.masters[i];
        } while (++i < this.masters.length);
        for (const replica of this.replicas) {
          yield replica;
        }
      } else {
        i -= this.masters.length;
        do {
          yield this.replicas[i];
        } while (++i < this.replicas.length);
      }
      while (true) {
        for (const master of this.masters) {
          yield master;
        }
        for (const replica of this.replicas) {
          yield replica;
        }
      }
    }
    _randomNodeIterator;
    getRandomNode() {
      this._randomNodeIterator ??= this.#iterateAllNodes();
      return this._randomNodeIterator.next().value;
    }
    *#slotNodesIterator(slot) {
      let i = Math.floor(Math.random() * (1 + slot.replicas.length));
      if (i < slot.replicas.length) {
        do {
          yield slot.replicas[i];
        } while (++i < slot.replicas.length);
      }
      while (true) {
        yield slot.master;
        for (const replica of slot.replicas) {
          yield replica;
        }
      }
    }
    getSlotRandomNode(slotNumber) {
      const slot = this.slots[slotNumber];
      if (!slot.replicas?.length) {
        return slot.master;
      }
      slot.nodesIterator ??= this.#slotNodesIterator(slot);
      return slot.nodesIterator.next().value;
    }
    getMasterByAddress(address) {
      const master = this.nodeByAddress.get(address);
      if (!master)
        return;
      return this.nodeClient(master);
    }
    getPubSubClient() {
      if (!this.pubSubNode)
        return this.#initiatePubSubClient();
      return this.pubSubNode.connectPromise ?? this.pubSubNode.client;
    }
    async#initiatePubSubClient(toResubscribe) {
      const index = Math.floor(Math.random() * (this.masters.length + this.replicas.length)), node = index < this.masters.length ? this.masters[index] : this.replicas[index - this.masters.length], client = this.#createClient(node, false);
      this.pubSubNode = {
        address: node.address,
        client,
        connectPromise: client.connect().then(async (client2) => {
          if (toResubscribe) {
            await Promise.all([
              client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS, toResubscribe[pub_sub_1.PUBSUB_TYPE.CHANNELS]),
              client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS, toResubscribe[pub_sub_1.PUBSUB_TYPE.PATTERNS])
            ]);
          }
          this.pubSubNode.connectPromise = undefined;
          return client2;
        }).catch((err) => {
          this.pubSubNode = undefined;
          throw err;
        })
      };
      return this.pubSubNode.connectPromise;
    }
    async executeUnsubscribeCommand(unsubscribe) {
      const client = await this.getPubSubClient();
      await unsubscribe(client);
      if (!client.isPubSubActive) {
        client.destroy();
        this.pubSubNode = undefined;
      }
    }
    getShardedPubSubClient(channel) {
      const { master } = this.slots[(0, cluster_key_slot_1.default)(channel)];
      if (!master.pubSub)
        return this.#initiateShardedPubSubClient(master);
      return master.pubSub.connectPromise ?? master.pubSub.client;
    }
    async#initiateShardedPubSubClient(master) {
      const client = this.#createClient(master, false).on("server-sunsubscribe", async (channel, listeners) => {
        try {
          await this.rediscover(client);
          const redirectTo = await this.getShardedPubSubClient(channel);
          await redirectTo.extendPubSubChannelListeners(pub_sub_1.PUBSUB_TYPE.SHARDED, channel, listeners);
        } catch (err) {
          this.#emit("sharded-shannel-moved-error", err, channel, listeners);
        }
      });
      master.pubSub = {
        client,
        connectPromise: client.connect().then((client2) => {
          master.pubSub.connectPromise = undefined;
          return client2;
        }).catch((err) => {
          master.pubSub = undefined;
          throw err;
        })
      };
      return master.pubSub.connectPromise;
    }
    async executeShardedUnsubscribeCommand(channel, unsubscribe) {
      const { master } = this.slots[(0, cluster_key_slot_1.default)(channel)];
      if (!master.pubSub)
        return;
      const client = master.pubSub.connectPromise ? await master.pubSub.connectPromise : master.pubSub.client;
      await unsubscribe(client);
      if (!client.isPubSubActive) {
        client.destroy();
        master.pubSub = undefined;
      }
    }
  }
  _a = RedisClusterSlots;
  exports.default = RedisClusterSlots;
});

// ../../node_modules/@redis/client/dist/lib/cluster/multi-command.js
var require_multi_command3 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var multi_command_1 = __importDefault(require_multi_command());
  var commander_1 = require_commander();
  var parser_1 = require_parser();

  class RedisClusterMultiCommand {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        const firstKey = parser.firstKey;
        return this.addCommand(firstKey, command.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        const firstKey = parser.firstKey;
        return this._self.addCommand(firstKey, command.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        const firstKey = parser.firstKey;
        return this._self.addCommand(firstKey, fn.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static #createScriptCommand(script, resp) {
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        script.parseCommand(parser, ...args);
        const scriptArgs = parser.redisArgs;
        scriptArgs.preserve = parser.preserve;
        const firstKey = parser.firstKey;
        return this.#addScript(firstKey, script.IS_READ_ONLY, script, scriptArgs, transformReply);
      };
    }
    static extend(config) {
      return (0, commander_1.attachConfig)({
        BaseClass: RedisClusterMultiCommand,
        commands: commands_1.default,
        createCommand: RedisClusterMultiCommand.#createCommand,
        createModuleCommand: RedisClusterMultiCommand.#createModuleCommand,
        createFunctionCommand: RedisClusterMultiCommand.#createFunctionCommand,
        createScriptCommand: RedisClusterMultiCommand.#createScriptCommand,
        config
      });
    }
    #multi;
    #executeMulti;
    #executePipeline;
    #firstKey;
    #isReadonly = true;
    constructor(executeMulti, executePipeline, routing, typeMapping) {
      this.#multi = new multi_command_1.default(typeMapping);
      this.#executeMulti = executeMulti;
      this.#executePipeline = executePipeline;
      this.#firstKey = routing;
    }
    #setState(firstKey, isReadonly) {
      this.#firstKey ??= firstKey;
      this.#isReadonly &&= isReadonly;
    }
    addCommand(firstKey, isReadonly, args, transformReply) {
      this.#setState(firstKey, isReadonly);
      this.#multi.addCommand(args, transformReply);
      return this;
    }
    #addScript(firstKey, isReadonly, script, args, transformReply) {
      this.#setState(firstKey, isReadonly);
      this.#multi.addScript(script, args, transformReply);
      return this;
    }
    async exec(execAsPipeline = false) {
      if (execAsPipeline)
        return this.execAsPipeline();
      return this.#multi.transformReplies(await this.#executeMulti(this.#firstKey, this.#isReadonly, this.#multi.queue));
    }
    EXEC = this.exec;
    execTyped(execAsPipeline = false) {
      return this.exec(execAsPipeline);
    }
    async execAsPipeline() {
      if (this.#multi.queue.length === 0)
        return [];
      return this.#multi.transformReplies(await this.#executePipeline(this.#firstKey, this.#isReadonly, this.#multi.queue));
    }
    execAsPipelineTyped() {
      return this.execAsPipeline();
    }
  }
  exports.default = RedisClusterMultiCommand;
});

// ../../node_modules/@redis/client/dist/lib/cluster/index.js
var require_cluster = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var node_events_1 = __require("events");
  var commander_1 = require_commander();
  var cluster_slots_1 = __importDefault(require_cluster_slots());
  var multi_command_1 = __importDefault(require_multi_command3());
  var errors_1 = require_errors();
  var parser_1 = require_parser();
  var ASKING_1 = require_ASKING();
  var single_entry_cache_1 = __importDefault(require_single_entry_cache());

  class RedisCluster extends node_events_1.EventEmitter {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self._execute(parser.firstKey, command.IS_READ_ONLY, this._commandOptions, (client, opts) => client._executeCommand(command, parser, opts, transformReply));
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self._execute(parser.firstKey, command.IS_READ_ONLY, this._self._commandOptions, (client, opts) => client._executeCommand(command, parser, opts, transformReply));
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        return this._self._execute(parser.firstKey, fn.IS_READ_ONLY, this._self._commandOptions, (client, opts) => client._executeCommand(fn, parser, opts, transformReply));
      };
    }
    static #createScriptCommand(script, resp) {
      const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        script.parseCommand(parser, ...args);
        return this._self._execute(parser.firstKey, script.IS_READ_ONLY, this._commandOptions, (client, opts) => client._executeScript(script, parser, opts, transformReply));
      };
    }
    static #SingleEntryCache = new single_entry_cache_1.default;
    static factory(config) {
      let Cluster = RedisCluster.#SingleEntryCache.get(config);
      if (!Cluster) {
        Cluster = (0, commander_1.attachConfig)({
          BaseClass: RedisCluster,
          commands: commands_1.default,
          createCommand: RedisCluster.#createCommand,
          createModuleCommand: RedisCluster.#createModuleCommand,
          createFunctionCommand: RedisCluster.#createFunctionCommand,
          createScriptCommand: RedisCluster.#createScriptCommand,
          config
        });
        Cluster.prototype.Multi = multi_command_1.default.extend(config);
        RedisCluster.#SingleEntryCache.set(config, Cluster);
      }
      return (options) => {
        return Object.create(new Cluster(options));
      };
    }
    static create(options) {
      return RedisCluster.factory(options)(options);
    }
    _options;
    _slots;
    _self = this;
    _commandOptions;
    get slots() {
      return this._self._slots.slots;
    }
    get clientSideCache() {
      return this._self._slots.clientSideCache;
    }
    get masters() {
      return this._self._slots.masters;
    }
    get replicas() {
      return this._self._slots.replicas;
    }
    get nodeByAddress() {
      return this._self._slots.nodeByAddress;
    }
    get pubSubNode() {
      return this._self._slots.pubSubNode;
    }
    get isOpen() {
      return this._self._slots.isOpen;
    }
    constructor(options) {
      super();
      this._options = options;
      this._slots = new cluster_slots_1.default(options, this.emit.bind(this));
      if (options?.commandOptions) {
        this._commandOptions = options.commandOptions;
      }
    }
    duplicate(overrides) {
      return new (Object.getPrototypeOf(this)).constructor({
        ...this._self._options,
        commandOptions: this._commandOptions,
        ...overrides
      });
    }
    async connect() {
      await this._self._slots.connect();
      return this;
    }
    withCommandOptions(options) {
      const proxy = Object.create(this);
      proxy._commandOptions = options;
      return proxy;
    }
    _commandOptionsProxy(key, value) {
      const proxy = Object.create(this);
      proxy._commandOptions = Object.create(this._commandOptions ?? null);
      proxy._commandOptions[key] = value;
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._commandOptionsProxy("typeMapping", typeMapping);
    }
    _handleAsk(fn) {
      return async (client, options) => {
        const chainId = Symbol("asking chain");
        const opts = options ? { ...options } : {};
        opts.chainId = chainId;
        const ret = await Promise.all([
          client.sendCommand([ASKING_1.ASKING_CMD], { chainId }),
          fn(client, opts)
        ]);
        return ret[1];
      };
    }
    async _execute(firstKey, isReadonly, options, fn) {
      const maxCommandRedirections = this._options.maxCommandRedirections ?? 16;
      let client = await this._slots.getClient(firstKey, isReadonly);
      let i = 0;
      let myFn = fn;
      while (true) {
        try {
          return await myFn(client, options);
        } catch (err) {
          myFn = fn;
          if (++i > maxCommandRedirections || !(err instanceof Error)) {
            throw err;
          }
          if (err.message.startsWith("ASK")) {
            const address = err.message.substring(err.message.lastIndexOf(" ") + 1);
            let redirectTo = await this._slots.getMasterByAddress(address);
            if (!redirectTo) {
              await this._slots.rediscover(client);
              redirectTo = await this._slots.getMasterByAddress(address);
            }
            if (!redirectTo) {
              throw new Error(`Cannot find node ${address}`);
            }
            client = redirectTo;
            myFn = this._handleAsk(fn);
            continue;
          }
          if (err.message.startsWith("MOVED")) {
            await this._slots.rediscover(client);
            client = await this._slots.getClient(firstKey, isReadonly);
            continue;
          }
          throw err;
        }
      }
    }
    async sendCommand(firstKey, isReadonly, args, options) {
      const opts = {
        ...this._self._commandOptions,
        ...options
      };
      return this._self._execute(firstKey, isReadonly, opts, (client, opts2) => client.sendCommand(args, opts2));
    }
    MULTI(routing) {
      return new this.Multi(async (firstKey, isReadonly, commands) => {
        const client = await this._self._slots.getClient(firstKey, isReadonly);
        return client._executeMulti(commands);
      }, async (firstKey, isReadonly, commands) => {
        const client = await this._self._slots.getClient(firstKey, isReadonly);
        return client._executePipeline(commands);
      }, routing, this._commandOptions?.typeMapping);
    }
    multi = this.MULTI;
    async SUBSCRIBE(channels, listener, bufferMode) {
      return (await this._self._slots.getPubSubClient()).SUBSCRIBE(channels, listener, bufferMode);
    }
    subscribe = this.SUBSCRIBE;
    async UNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self._slots.executeUnsubscribeCommand((client) => client.UNSUBSCRIBE(channels, listener, bufferMode));
    }
    unsubscribe = this.UNSUBSCRIBE;
    async PSUBSCRIBE(patterns, listener, bufferMode) {
      return (await this._self._slots.getPubSubClient()).PSUBSCRIBE(patterns, listener, bufferMode);
    }
    pSubscribe = this.PSUBSCRIBE;
    async PUNSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self._slots.executeUnsubscribeCommand((client) => client.PUNSUBSCRIBE(patterns, listener, bufferMode));
    }
    pUnsubscribe = this.PUNSUBSCRIBE;
    async SSUBSCRIBE(channels, listener, bufferMode) {
      const maxCommandRedirections = this._self._options.maxCommandRedirections ?? 16, firstChannel = Array.isArray(channels) ? channels[0] : channels;
      let client = await this._self._slots.getShardedPubSubClient(firstChannel);
      for (let i = 0;; i++) {
        try {
          return await client.SSUBSCRIBE(channels, listener, bufferMode);
        } catch (err) {
          if (++i > maxCommandRedirections || !(err instanceof errors_1.ErrorReply)) {
            throw err;
          }
          if (err.message.startsWith("MOVED")) {
            await this._self._slots.rediscover(client);
            client = await this._self._slots.getShardedPubSubClient(firstChannel);
            continue;
          }
          throw err;
        }
      }
    }
    sSubscribe = this.SSUBSCRIBE;
    SUNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self._slots.executeShardedUnsubscribeCommand(Array.isArray(channels) ? channels[0] : channels, (client) => client.SUNSUBSCRIBE(channels, listener, bufferMode));
    }
    sUnsubscribe = this.SUNSUBSCRIBE;
    quit() {
      return this._self._slots.quit();
    }
    disconnect() {
      return this._self._slots.disconnect();
    }
    close() {
      this._self._slots.clientSideCache?.onPoolClose();
      return this._self._slots.close();
    }
    destroy() {
      this._self._slots.clientSideCache?.onPoolClose();
      return this._self._slots.destroy();
    }
    nodeClient(node) {
      return this._self._slots.nodeClient(node);
    }
    getRandomNode() {
      return this._self._slots.getRandomNode();
    }
    getSlotRandomNode(slot) {
      return this._self._slots.getSlotRandomNode(slot);
    }
    getMasters() {
      return this.masters;
    }
    getSlotMaster(slot) {
      return this.slots[slot].master;
    }
  }
  exports.default = RedisCluster;
});

// ../../node_modules/@redis/client/dist/lib/sentinel/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createScriptCommand = exports.createModuleCommand = exports.createFunctionCommand = exports.createCommand = exports.clientSocketToNode = exports.createNodeList = exports.parseNode = undefined;
  var parser_1 = require_parser();
  var commander_1 = require_commander();
  function parseNode(node) {
    if (node.flags.includes("s_down") || node.flags.includes("disconnected") || node.flags.includes("failover_in_progress")) {
      return;
    }
    return { host: node.ip, port: Number(node.port) };
  }
  exports.parseNode = parseNode;
  function createNodeList(nodes) {
    var nodeList = [];
    for (const nodeData of nodes) {
      const node = parseNode(nodeData);
      if (node === undefined) {
        continue;
      }
      nodeList.push(node);
    }
    return nodeList;
  }
  exports.createNodeList = createNodeList;
  function clientSocketToNode(socket) {
    const s = socket;
    return {
      host: s.host,
      port: s.port
    };
  }
  exports.clientSocketToNode = clientSocketToNode;
  function createCommand(command, resp) {
    const transformReply = (0, commander_1.getTransformReply)(command, resp);
    return async function(...args) {
      const parser = new parser_1.BasicCommandParser;
      command.parseCommand(parser, ...args);
      return this._self._execute(command.IS_READ_ONLY, (client) => client._executeCommand(command, parser, this.commandOptions, transformReply));
    };
  }
  exports.createCommand = createCommand;
  function createFunctionCommand(name, fn, resp) {
    const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
    const transformReply = (0, commander_1.getTransformReply)(fn, resp);
    return async function(...args) {
      const parser = new parser_1.BasicCommandParser;
      parser.push(...prefix);
      fn.parseCommand(parser, ...args);
      return this._self._execute(fn.IS_READ_ONLY, (client) => client._executeCommand(fn, parser, this._self.commandOptions, transformReply));
    };
  }
  exports.createFunctionCommand = createFunctionCommand;
  function createModuleCommand(command, resp) {
    const transformReply = (0, commander_1.getTransformReply)(command, resp);
    return async function(...args) {
      const parser = new parser_1.BasicCommandParser;
      command.parseCommand(parser, ...args);
      return this._self._execute(command.IS_READ_ONLY, (client) => client._executeCommand(command, parser, this._self.commandOptions, transformReply));
    };
  }
  exports.createModuleCommand = createModuleCommand;
  function createScriptCommand(script, resp) {
    const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
    const transformReply = (0, commander_1.getTransformReply)(script, resp);
    return async function(...args) {
      const parser = new parser_1.BasicCommandParser;
      parser.push(...prefix);
      script.parseCommand(parser, ...args);
      return this._self._execute(script.IS_READ_ONLY, (client) => client._executeScript(script, parser, this.commandOptions, transformReply));
    };
  }
  exports.createScriptCommand = createScriptCommand;
});

// ../../node_modules/@redis/client/dist/lib/sentinel/multi-commands.js
var require_multi_commands = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var multi_command_1 = __importDefault(require_multi_command());
  var commander_1 = require_commander();
  var parser_1 = require_parser();

  class RedisSentinelMultiCommand {
    static _createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this.addCommand(command.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static _createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this._self.addCommand(command.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static _createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this._self.addCommand(fn.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static _createScriptCommand(script, resp) {
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        script.parseCommand(parser, ...args);
        const scriptArgs = parser.redisArgs;
        scriptArgs.preserve = parser.preserve;
        return this.#addScript(script.IS_READ_ONLY, script, scriptArgs, transformReply);
      };
    }
    static extend(config) {
      return (0, commander_1.attachConfig)({
        BaseClass: RedisSentinelMultiCommand,
        commands: commands_1.default,
        createCommand: RedisSentinelMultiCommand._createCommand,
        createModuleCommand: RedisSentinelMultiCommand._createModuleCommand,
        createFunctionCommand: RedisSentinelMultiCommand._createFunctionCommand,
        createScriptCommand: RedisSentinelMultiCommand._createScriptCommand,
        config
      });
    }
    #multi = new multi_command_1.default;
    #sentinel;
    #isReadonly = true;
    constructor(sentinel, typeMapping) {
      this.#multi = new multi_command_1.default(typeMapping);
      this.#sentinel = sentinel;
    }
    #setState(isReadonly) {
      this.#isReadonly &&= isReadonly;
    }
    addCommand(isReadonly, args, transformReply) {
      this.#setState(isReadonly);
      this.#multi.addCommand(args, transformReply);
      return this;
    }
    #addScript(isReadonly, script, args, transformReply) {
      this.#setState(isReadonly);
      this.#multi.addScript(script, args, transformReply);
      return this;
    }
    async exec(execAsPipeline = false) {
      if (execAsPipeline)
        return this.execAsPipeline();
      return this.#multi.transformReplies(await this.#sentinel._executeMulti(this.#isReadonly, this.#multi.queue));
    }
    EXEC = this.exec;
    execTyped(execAsPipeline = false) {
      return this.exec(execAsPipeline);
    }
    async execAsPipeline() {
      if (this.#multi.queue.length === 0)
        return [];
      return this.#multi.transformReplies(await this.#sentinel._executePipeline(this.#isReadonly, this.#multi.queue));
    }
    execAsPipelineTyped() {
      return this.execAsPipeline();
    }
  }
  exports.default = RedisSentinelMultiCommand;
});

// ../../node_modules/@redis/client/dist/lib/sentinel/pub-sub-proxy.js
var require_pub_sub_proxy = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PubSubProxy = undefined;
  var node_events_1 = __importDefault(__require("events"));
  var pub_sub_1 = require_pub_sub();
  var client_1 = __importDefault(require_client());

  class PubSubProxy extends node_events_1.default {
    #clientOptions;
    #onError;
    #node;
    #state;
    #subscriptions;
    constructor(clientOptions, onError) {
      super();
      this.#clientOptions = clientOptions;
      this.#onError = onError;
    }
    #createClient() {
      if (this.#node === undefined) {
        throw new Error("pubSubProxy: didn't define node to do pubsub against");
      }
      return new client_1.default({
        ...this.#clientOptions,
        socket: {
          ...this.#clientOptions.socket,
          host: this.#node.host,
          port: this.#node.port
        }
      });
    }
    async#initiatePubSubClient(withSubscriptions = false) {
      const client = this.#createClient().on("error", this.#onError);
      const connectPromise = client.connect().then(async (client2) => {
        if (this.#state?.client !== client2) {
          client2.destroy();
          return this.#state?.connectPromise;
        }
        if (withSubscriptions && this.#subscriptions) {
          await Promise.all([
            client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS, this.#subscriptions[pub_sub_1.PUBSUB_TYPE.CHANNELS]),
            client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS, this.#subscriptions[pub_sub_1.PUBSUB_TYPE.PATTERNS])
          ]);
        }
        if (this.#state.client !== client2) {
          client2.destroy();
          return this.#state?.connectPromise;
        }
        this.#state.connectPromise = undefined;
        return client2;
      }).catch((err) => {
        this.#state = undefined;
        throw err;
      });
      this.#state = {
        client,
        connectPromise
      };
      return connectPromise;
    }
    #getPubSubClient() {
      if (!this.#state)
        return this.#initiatePubSubClient();
      return this.#state.connectPromise ?? this.#state.client;
    }
    async changeNode(node) {
      this.#node = node;
      if (!this.#state)
        return;
      if (this.#state.connectPromise === undefined) {
        this.#subscriptions = {
          [pub_sub_1.PUBSUB_TYPE.CHANNELS]: this.#state.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS),
          [pub_sub_1.PUBSUB_TYPE.PATTERNS]: this.#state.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS)
        };
        this.#state.client.destroy();
      }
      await this.#initiatePubSubClient(true);
    }
    #executeCommand(fn) {
      const client = this.#getPubSubClient();
      if (client instanceof client_1.default) {
        return fn(client);
      }
      return client.then((client2) => {
        if (client2 === undefined)
          return;
        return fn(client2);
      }).catch((err) => {
        if (this.#state?.client.isPubSubActive) {
          this.#state.client.destroy();
          this.#state = undefined;
        }
        throw err;
      });
    }
    subscribe(channels, listener, bufferMode) {
      return this.#executeCommand((client) => client.SUBSCRIBE(channels, listener, bufferMode));
    }
    #unsubscribe(fn) {
      return this.#executeCommand(async (client) => {
        const reply = await fn(client);
        if (!client.isPubSubActive) {
          client.destroy();
          this.#state = undefined;
        }
        return reply;
      });
    }
    async unsubscribe(channels, listener, bufferMode) {
      return this.#unsubscribe((client) => client.UNSUBSCRIBE(channels, listener, bufferMode));
    }
    async pSubscribe(patterns, listener, bufferMode) {
      return this.#executeCommand((client) => client.PSUBSCRIBE(patterns, listener, bufferMode));
    }
    async pUnsubscribe(patterns, listener, bufferMode) {
      return this.#unsubscribe((client) => client.PUNSUBSCRIBE(patterns, listener, bufferMode));
    }
    destroy() {
      this.#subscriptions = undefined;
      if (this.#state === undefined)
        return;
      if (!this.#state.connectPromise) {
        this.#state.client.destroy();
      }
      this.#state = undefined;
    }
  }
  exports.PubSubProxy = PubSubProxy;
});

// ../../node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_MASTER.js
var require_SENTINEL_MASTER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, dbname) {
      parser.push("SENTINEL", "MASTER", dbname);
    },
    transformReply: {
      2: generic_transformers_1.transformTuplesReply,
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_MONITOR.js
var require_SENTINEL_MONITOR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, dbname, host, port, quorum) {
      parser.push("SENTINEL", "MONITOR", dbname, host, port, quorum);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_REPLICAS.js
var require_SENTINEL_REPLICAS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, dbname) {
      parser.push("SENTINEL", "REPLICAS", dbname);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        const inferred = reply;
        const initial = [];
        return inferred.reduce((sentinels, x) => {
          sentinels.push((0, generic_transformers_1.transformTuplesReply)(x, undefined, typeMapping));
          return sentinels;
        }, initial);
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_SENTINELS.js
var require_SENTINEL_SENTINELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, dbname) {
      parser.push("SENTINEL", "SENTINELS", dbname);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        const inferred = reply;
        const initial = [];
        return inferred.reduce((sentinels, x) => {
          sentinels.push((0, generic_transformers_1.transformTuplesReply)(x, undefined, typeMapping));
          return sentinels;
        }, initial);
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_SET.js
var require_SENTINEL_SET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, dbname, options) {
      parser.push("SENTINEL", "SET", dbname);
      for (const option of options) {
        parser.push(option.option, option.value);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/client/dist/lib/sentinel/commands/index.js
var require_commands2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SENTINEL_MASTER_1 = __importDefault(require_SENTINEL_MASTER());
  var SENTINEL_MONITOR_1 = __importDefault(require_SENTINEL_MONITOR());
  var SENTINEL_REPLICAS_1 = __importDefault(require_SENTINEL_REPLICAS());
  var SENTINEL_SENTINELS_1 = __importDefault(require_SENTINEL_SENTINELS());
  var SENTINEL_SET_1 = __importDefault(require_SENTINEL_SET());
  exports.default = {
    SENTINEL_SENTINELS: SENTINEL_SENTINELS_1.default,
    sentinelSentinels: SENTINEL_SENTINELS_1.default,
    SENTINEL_MASTER: SENTINEL_MASTER_1.default,
    sentinelMaster: SENTINEL_MASTER_1.default,
    SENTINEL_REPLICAS: SENTINEL_REPLICAS_1.default,
    sentinelReplicas: SENTINEL_REPLICAS_1.default,
    SENTINEL_MONITOR: SENTINEL_MONITOR_1.default,
    sentinelMonitor: SENTINEL_MONITOR_1.default,
    SENTINEL_SET: SENTINEL_SET_1.default,
    sentinelSet: SENTINEL_SET_1.default
  };
});

// ../../node_modules/@redis/client/dist/lib/sentinel/module.js
var require_module = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands2());
  exports.default = {
    sentinel: commands_1.default
  };
});

// ../../node_modules/@redis/client/dist/lib/sentinel/wait-queue.js
var require_wait_queue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WaitQueue = undefined;
  var linked_list_1 = require_linked_list();

  class WaitQueue {
    #list = new linked_list_1.SinglyLinkedList;
    #queue = new linked_list_1.SinglyLinkedList;
    push(value) {
      const resolve = this.#queue.shift();
      if (resolve !== undefined) {
        resolve(value);
        return;
      }
      this.#list.push(value);
    }
    shift() {
      return this.#list.shift();
    }
    wait() {
      return new Promise((resolve) => this.#queue.push(resolve));
    }
  }
  exports.WaitQueue = WaitQueue;
});

// ../../node_modules/@redis/client/dist/lib/sentinel/index.js
var require_sentinel = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisSentinelFactory = exports.RedisSentinelClient = undefined;
  var node_events_1 = __require("events");
  var client_1 = __importDefault(require_client());
  var commander_1 = require_commander();
  var commands_1 = __importDefault(require_commands());
  var utils_1 = require_utils();
  var multi_commands_1 = __importDefault(require_multi_commands());
  var pub_sub_proxy_1 = require_pub_sub_proxy();
  var promises_1 = __require("timers/promises");
  var module_1 = __importDefault(require_module());
  var wait_queue_1 = require_wait_queue();
  var cache_1 = require_cache();

  class RedisSentinelClient {
    #clientInfo;
    #internal;
    _self;
    get isOpen() {
      return this._self.#internal.isOpen;
    }
    get isReady() {
      return this._self.#internal.isReady;
    }
    get commandOptions() {
      return this._self.#commandOptions;
    }
    #commandOptions;
    constructor(internal, clientInfo, commandOptions) {
      this._self = this;
      this.#internal = internal;
      this.#clientInfo = clientInfo;
      this.#commandOptions = commandOptions;
    }
    static factory(config) {
      const SentinelClient = (0, commander_1.attachConfig)({
        BaseClass: RedisSentinelClient,
        commands: commands_1.default,
        createCommand: utils_1.createCommand,
        createModuleCommand: utils_1.createModuleCommand,
        createFunctionCommand: utils_1.createFunctionCommand,
        createScriptCommand: utils_1.createScriptCommand,
        config
      });
      SentinelClient.prototype.Multi = multi_commands_1.default.extend(config);
      return (internal, clientInfo, commandOptions) => {
        return Object.create(new SentinelClient(internal, clientInfo, commandOptions));
      };
    }
    static create(options, internal, clientInfo, commandOptions) {
      return RedisSentinelClient.factory(options)(internal, clientInfo, commandOptions);
    }
    withCommandOptions(options) {
      const proxy = Object.create(this);
      proxy._commandOptions = options;
      return proxy;
    }
    _commandOptionsProxy(key, value) {
      const proxy = Object.create(this);
      proxy._commandOptions = Object.create(this._self.#commandOptions ?? null);
      proxy._commandOptions[key] = value;
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._commandOptionsProxy("typeMapping", typeMapping);
    }
    async _execute(isReadonly, fn) {
      if (this._self.#clientInfo === undefined) {
        throw new Error("Attempted execution on released RedisSentinelClient lease");
      }
      return await this._self.#internal.execute(fn, this._self.#clientInfo);
    }
    async sendCommand(isReadonly, args, options) {
      return this._execute(isReadonly, (client) => client.sendCommand(args, options));
    }
    async _executePipeline(isReadonly, commands) {
      return this._execute(isReadonly, (client) => client._executePipeline(commands));
    }
    async _executeMulti(isReadonly, commands) {
      return this._execute(isReadonly, (client) => client._executeMulti(commands));
    }
    MULTI() {
      return new this.Multi(this);
    }
    multi = this.MULTI;
    WATCH(key) {
      if (this._self.#clientInfo === undefined) {
        throw new Error("Attempted execution on released RedisSentinelClient lease");
      }
      return this._execute(false, (client) => client.watch(key));
    }
    watch = this.WATCH;
    UNWATCH() {
      if (this._self.#clientInfo === undefined) {
        throw new Error("Attempted execution on released RedisSentinelClient lease");
      }
      return this._execute(false, (client) => client.unwatch());
    }
    unwatch = this.UNWATCH;
    release() {
      if (this._self.#clientInfo === undefined) {
        throw new Error("RedisSentinelClient lease already released");
      }
      const result = this._self.#internal.releaseClientLease(this._self.#clientInfo);
      this._self.#clientInfo = undefined;
      return result;
    }
  }
  exports.RedisSentinelClient = RedisSentinelClient;

  class RedisSentinel extends node_events_1.EventEmitter {
    _self;
    #internal;
    #options;
    get isOpen() {
      return this._self.#internal.isOpen;
    }
    get isReady() {
      return this._self.#internal.isReady;
    }
    get commandOptions() {
      return this._self.#commandOptions;
    }
    #commandOptions;
    #trace = () => {};
    #reservedClientInfo;
    #masterClientCount = 0;
    #masterClientInfo;
    get clientSideCache() {
      return this._self.#internal.clientSideCache;
    }
    constructor(options) {
      super();
      this._self = this;
      this.#options = options;
      if (options.commandOptions) {
        this.#commandOptions = options.commandOptions;
      }
      this.#internal = new RedisSentinelInternal(options);
      this.#internal.on("error", (err) => this.emit("error", err));
      this.#internal.on("topology-change", (event) => {
        if (!this.emit("topology-change", event)) {
          this._self.#trace(`RedisSentinel: re-emit for topology-change for ${event.type} event returned false`);
        }
      });
    }
    static factory(config) {
      const Sentinel = (0, commander_1.attachConfig)({
        BaseClass: RedisSentinel,
        commands: commands_1.default,
        createCommand: utils_1.createCommand,
        createModuleCommand: utils_1.createModuleCommand,
        createFunctionCommand: utils_1.createFunctionCommand,
        createScriptCommand: utils_1.createScriptCommand,
        config
      });
      Sentinel.prototype.Multi = multi_commands_1.default.extend(config);
      return (options) => {
        return Object.create(new Sentinel(options));
      };
    }
    static create(options) {
      return RedisSentinel.factory(options)(options);
    }
    withCommandOptions(options) {
      const proxy = Object.create(this);
      proxy._commandOptions = options;
      return proxy;
    }
    _commandOptionsProxy(key, value) {
      const proxy = Object.create(this);
      proxy._self.#commandOptions = {
        ...this._self.#commandOptions || {},
        [key]: value
      };
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._commandOptionsProxy("typeMapping", typeMapping);
    }
    async connect() {
      await this._self.#internal.connect();
      if (this._self.#options.reserveClient) {
        this._self.#reservedClientInfo = await this._self.#internal.getClientLease();
      }
      return this;
    }
    async _execute(isReadonly, fn) {
      let clientInfo;
      if (!isReadonly || !this._self.#internal.useReplicas) {
        if (this._self.#reservedClientInfo) {
          clientInfo = this._self.#reservedClientInfo;
        } else {
          this._self.#masterClientInfo ??= await this._self.#internal.getClientLease();
          clientInfo = this._self.#masterClientInfo;
          this._self.#masterClientCount++;
        }
      }
      try {
        return await this._self.#internal.execute(fn, clientInfo);
      } finally {
        if (clientInfo !== undefined && clientInfo === this._self.#masterClientInfo && --this._self.#masterClientCount === 0) {
          const promise = this._self.#internal.releaseClientLease(clientInfo);
          this._self.#masterClientInfo = undefined;
          if (promise)
            await promise;
        }
      }
    }
    async use(fn) {
      const clientInfo = await this._self.#internal.getClientLease();
      try {
        return await fn(RedisSentinelClient.create(this._self.#options, this._self.#internal, clientInfo, this._self.#commandOptions));
      } finally {
        const promise = this._self.#internal.releaseClientLease(clientInfo);
        if (promise)
          await promise;
      }
    }
    async sendCommand(isReadonly, args, options) {
      return this._execute(isReadonly, (client) => client.sendCommand(args, options));
    }
    async _executePipeline(isReadonly, commands) {
      return this._execute(isReadonly, (client) => client._executePipeline(commands));
    }
    async _executeMulti(isReadonly, commands) {
      return this._execute(isReadonly, (client) => client._executeMulti(commands));
    }
    MULTI() {
      return new this.Multi(this);
    }
    multi = this.MULTI;
    async close() {
      return this._self.#internal.close();
    }
    destroy() {
      return this._self.#internal.destroy();
    }
    async SUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#internal.subscribe(channels, listener, bufferMode);
    }
    subscribe = this.SUBSCRIBE;
    async UNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#internal.unsubscribe(channels, listener, bufferMode);
    }
    unsubscribe = this.UNSUBSCRIBE;
    async PSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self.#internal.pSubscribe(patterns, listener, bufferMode);
    }
    pSubscribe = this.PSUBSCRIBE;
    async PUNSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self.#internal.pUnsubscribe(patterns, listener, bufferMode);
    }
    pUnsubscribe = this.PUNSUBSCRIBE;
    async acquire() {
      const clientInfo = await this._self.#internal.getClientLease();
      return RedisSentinelClient.create(this._self.#options, this._self.#internal, clientInfo, this._self.#commandOptions);
    }
    getSentinelNode() {
      return this._self.#internal.getSentinelNode();
    }
    getMasterNode() {
      return this._self.#internal.getMasterNode();
    }
    getReplicaNodes() {
      return this._self.#internal.getReplicaNodes();
    }
    setTracer(tracer) {
      if (tracer) {
        this._self.#trace = (msg) => {
          tracer.push(msg);
        };
      } else {
        this._self.#trace = () => {};
      }
      this._self.#internal.setTracer(tracer);
    }
  }
  exports.default = RedisSentinel;

  class RedisSentinelInternal extends node_events_1.EventEmitter {
    #isOpen = false;
    get isOpen() {
      return this.#isOpen;
    }
    #isReady = false;
    get isReady() {
      return this.#isReady;
    }
    #name;
    #nodeClientOptions;
    #sentinelClientOptions;
    #scanInterval;
    #passthroughClientErrorEvents;
    #RESP;
    #anotherReset = false;
    #configEpoch = 0;
    #sentinelRootNodes;
    #sentinelClient;
    #masterClients = [];
    #masterClientQueue;
    #masterPoolSize;
    #replicaClients = [];
    #replicaClientsIdx = 0;
    #replicaPoolSize;
    get useReplicas() {
      return this.#replicaPoolSize > 0;
    }
    #connectPromise;
    #maxCommandRediscovers;
    #pubSubProxy;
    #scanTimer;
    #destroy = false;
    #trace = () => {};
    #clientSideCache;
    get clientSideCache() {
      return this.#clientSideCache;
    }
    #validateOptions(options) {
      if (options?.clientSideCache && options?.RESP !== 3) {
        throw new Error("Client Side Caching is only supported with RESP3");
      }
    }
    constructor(options) {
      super();
      this.#validateOptions(options);
      this.#name = options.name;
      this.#RESP = options.RESP;
      this.#sentinelRootNodes = Array.from(options.sentinelRootNodes);
      this.#maxCommandRediscovers = options.maxCommandRediscovers ?? 16;
      this.#masterPoolSize = options.masterPoolSize ?? 1;
      this.#replicaPoolSize = options.replicaPoolSize ?? 0;
      this.#scanInterval = options.scanInterval ?? 0;
      this.#passthroughClientErrorEvents = options.passthroughClientErrorEvents ?? false;
      this.#nodeClientOptions = options.nodeClientOptions ? { ...options.nodeClientOptions } : {};
      if (this.#nodeClientOptions.url !== undefined) {
        throw new Error("invalid nodeClientOptions for Sentinel");
      }
      if (options.clientSideCache) {
        if (options.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
          this.#clientSideCache = this.#nodeClientOptions.clientSideCache = options.clientSideCache;
        } else {
          const cscConfig = options.clientSideCache;
          this.#clientSideCache = this.#nodeClientOptions.clientSideCache = new cache_1.BasicPooledClientSideCache(cscConfig);
        }
      }
      this.#sentinelClientOptions = options.sentinelClientOptions ? Object.assign({}, options.sentinelClientOptions) : {};
      this.#sentinelClientOptions.modules = module_1.default;
      if (this.#sentinelClientOptions.url !== undefined) {
        throw new Error("invalid sentinelClientOptions for Sentinel");
      }
      this.#masterClientQueue = new wait_queue_1.WaitQueue;
      for (let i = 0;i < this.#masterPoolSize; i++) {
        this.#masterClientQueue.push(i);
      }
      this.#pubSubProxy = new pub_sub_proxy_1.PubSubProxy(this.#nodeClientOptions, (err) => this.emit("error", err));
    }
    #createClient(node, clientOptions, reconnectStrategy) {
      return client_1.default.create({
        RESP: this.#RESP,
        ...clientOptions,
        socket: {
          ...clientOptions.socket,
          host: node.host,
          port: node.port,
          reconnectStrategy
        }
      });
    }
    getClientLease() {
      const id = this.#masterClientQueue.shift();
      if (id !== undefined) {
        return { id };
      }
      return this.#masterClientQueue.wait().then((id2) => ({ id: id2 }));
    }
    releaseClientLease(clientInfo) {
      const client = this.#masterClients[clientInfo.id];
      if (client !== undefined) {
        const dirtyPromise = client.resetIfDirty();
        if (dirtyPromise) {
          return dirtyPromise.then(() => this.#masterClientQueue.push(clientInfo.id));
        }
      }
      this.#masterClientQueue.push(clientInfo.id);
    }
    async connect() {
      if (this.#isOpen) {
        throw new Error("already attempting to open");
      }
      try {
        this.#isOpen = true;
        this.#connectPromise = this.#connect();
        await this.#connectPromise;
        this.#isReady = true;
      } finally {
        this.#connectPromise = undefined;
        if (this.#scanInterval > 0) {
          this.#scanTimer = setInterval(this.#reset.bind(this), this.#scanInterval);
        }
      }
    }
    async#connect() {
      let count = 0;
      while (true) {
        this.#trace("starting connect loop");
        count += 1;
        if (this.#destroy) {
          this.#trace("in #connect and want to destroy");
          return;
        }
        try {
          this.#anotherReset = false;
          await this.transform(this.analyze(await this.observe()));
          if (this.#anotherReset) {
            this.#trace("#connect: anotherReset is true, so continuing");
            continue;
          }
          this.#trace("#connect: returning");
          return;
        } catch (e) {
          this.#trace(`#connect: exception ${e.message}`);
          if (!this.#isReady && count > this.#maxCommandRediscovers) {
            throw e;
          }
          if (e.message !== "no valid master node") {
            console.log(e);
          }
          await (0, promises_1.setTimeout)(1000);
        } finally {
          this.#trace("finished connect");
        }
      }
    }
    async execute(fn, clientInfo) {
      let iter = 0;
      while (true) {
        if (this.#connectPromise !== undefined) {
          await this.#connectPromise;
        }
        const client = this.#getClient(clientInfo);
        if (!client.isReady) {
          await this.#reset();
          continue;
        }
        const sockOpts = client.options?.socket;
        this.#trace("attemping to send command to " + sockOpts?.host + ":" + sockOpts?.port);
        try {
          return await fn(client);
        } catch (err) {
          if (++iter > this.#maxCommandRediscovers || !(err instanceof Error)) {
            throw err;
          }
          if (clientInfo !== undefined && (err.message.startsWith("READONLY") || !client.isReady)) {
            await this.#reset();
            continue;
          }
          throw err;
        }
      }
    }
    async#createPubSub(client) {
      await client.pSubscribe(["switch-master", "[-+]sdown", "+slave", "+sentinel", "[-+]odown", "+slave-reconf-done"], (message, channel) => {
        this.#handlePubSubControlChannel(channel, message);
      }, true);
      return client;
    }
    async#handlePubSubControlChannel(channel, message) {
      this.#trace("pubsub control channel message on " + channel);
      this.#reset();
    }
    #getClient(clientInfo) {
      if (clientInfo !== undefined) {
        return this.#masterClients[clientInfo.id];
      }
      if (this.#replicaClientsIdx >= this.#replicaClients.length) {
        this.#replicaClientsIdx = 0;
      }
      if (this.#replicaClients.length == 0) {
        throw new Error("no replicas available for read");
      }
      return this.#replicaClients[this.#replicaClientsIdx++];
    }
    async#reset() {
      if (this.#isReady == false || this.#destroy == true) {
        return;
      }
      if (this.#connectPromise !== undefined) {
        this.#anotherReset = true;
        return await this.#connectPromise;
      }
      try {
        this.#connectPromise = this.#connect();
        return await this.#connectPromise;
      } finally {
        this.#trace("finished reconfgure");
        this.#connectPromise = undefined;
      }
    }
    async close() {
      this.#destroy = true;
      if (this.#connectPromise != null) {
        await this.#connectPromise;
      }
      this.#isReady = false;
      this.#clientSideCache?.onPoolClose();
      if (this.#scanTimer) {
        clearInterval(this.#scanTimer);
        this.#scanTimer = undefined;
      }
      const promises = [];
      if (this.#sentinelClient !== undefined) {
        if (this.#sentinelClient.isOpen) {
          promises.push(this.#sentinelClient.close());
        }
        this.#sentinelClient = undefined;
      }
      for (const client of this.#masterClients) {
        if (client.isOpen) {
          promises.push(client.close());
        }
      }
      this.#masterClients = [];
      for (const client of this.#replicaClients) {
        if (client.isOpen) {
          promises.push(client.close());
        }
      }
      this.#replicaClients = [];
      await Promise.all(promises);
      this.#pubSubProxy.destroy();
      this.#isOpen = false;
    }
    async destroy() {
      this.#destroy = true;
      if (this.#connectPromise != null) {
        await this.#connectPromise;
      }
      this.#isReady = false;
      this.#clientSideCache?.onPoolClose();
      if (this.#scanTimer) {
        clearInterval(this.#scanTimer);
        this.#scanTimer = undefined;
      }
      if (this.#sentinelClient !== undefined) {
        if (this.#sentinelClient.isOpen) {
          this.#sentinelClient.destroy();
        }
        this.#sentinelClient = undefined;
      }
      for (const client of this.#masterClients) {
        if (client.isOpen) {
          client.destroy();
        }
      }
      this.#masterClients = [];
      for (const client of this.#replicaClients) {
        if (client.isOpen) {
          client.destroy();
        }
      }
      this.#replicaClients = [];
      this.#pubSubProxy.destroy();
      this.#isOpen = false;
      this.#destroy = false;
    }
    async subscribe(channels, listener, bufferMode) {
      return this.#pubSubProxy.subscribe(channels, listener, bufferMode);
    }
    async unsubscribe(channels, listener, bufferMode) {
      return this.#pubSubProxy.unsubscribe(channels, listener, bufferMode);
    }
    async pSubscribe(patterns, listener, bufferMode) {
      return this.#pubSubProxy.pSubscribe(patterns, listener, bufferMode);
    }
    async pUnsubscribe(patterns, listener, bufferMode) {
      return this.#pubSubProxy.pUnsubscribe(patterns, listener, bufferMode);
    }
    async observe() {
      for (const node of this.#sentinelRootNodes) {
        let client;
        try {
          this.#trace(`observe: trying to connect to sentinel: ${node.host}:${node.port}`);
          client = this.#createClient(node, this.#sentinelClientOptions, false);
          client.on("error", (err) => this.emit("error", `obseve client error: ${err}`));
          await client.connect();
          this.#trace(`observe: connected to sentinel`);
          const [sentinelData, masterData, replicaData] = await Promise.all([
            client.sentinel.sentinelSentinels(this.#name),
            client.sentinel.sentinelMaster(this.#name),
            client.sentinel.sentinelReplicas(this.#name)
          ]);
          this.#trace("observe: got all sentinel data");
          const ret = {
            sentinelConnected: node,
            sentinelData,
            masterData,
            replicaData,
            currentMaster: this.getMasterNode(),
            currentReplicas: this.getReplicaNodes(),
            currentSentinel: this.getSentinelNode(),
            replicaPoolSize: this.#replicaPoolSize,
            useReplicas: this.useReplicas
          };
          return ret;
        } catch (err) {
          this.#trace(`observe: error ${err}`);
          this.emit("error", err);
        } finally {
          if (client !== undefined && client.isOpen) {
            this.#trace(`observe: destroying sentinel client`);
            client.destroy();
          }
        }
      }
      this.#trace(`observe: none of the sentinels are available`);
      throw new Error("None of the sentinels are available");
    }
    analyze(observed) {
      let master = (0, utils_1.parseNode)(observed.masterData);
      if (master === undefined) {
        this.#trace(`analyze: no valid master node because ${observed.masterData.flags}`);
        throw new Error("no valid master node");
      }
      if (master.host === observed.currentMaster?.host && master.port === observed.currentMaster?.port) {
        this.#trace(`analyze: master node hasn't changed from ${observed.currentMaster?.host}:${observed.currentMaster?.port}`);
        master = undefined;
      } else {
        this.#trace(`analyze: master node has changed to ${master.host}:${master.port} from ${observed.currentMaster?.host}:${observed.currentMaster?.port}`);
      }
      let sentinel = observed.sentinelConnected;
      if (sentinel.host === observed.currentSentinel?.host && sentinel.port === observed.currentSentinel.port) {
        this.#trace(`analyze: sentinel node hasn't changed`);
        sentinel = undefined;
      } else {
        this.#trace(`analyze: sentinel node has changed to ${sentinel.host}:${sentinel.port}`);
      }
      const replicasToClose = [];
      const replicasToOpen = new Map;
      const desiredSet = new Set;
      const seen = new Set;
      if (observed.useReplicas) {
        const replicaList = (0, utils_1.createNodeList)(observed.replicaData);
        for (const node of replicaList) {
          desiredSet.add(JSON.stringify(node));
        }
        for (const [node, value] of observed.currentReplicas) {
          if (!desiredSet.has(JSON.stringify(node))) {
            replicasToClose.push(node);
            this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToClose`);
          } else {
            seen.add(JSON.stringify(node));
            if (value != observed.replicaPoolSize) {
              replicasToOpen.set(node, observed.replicaPoolSize - value);
              this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToOpen`);
            }
          }
        }
        for (const node of replicaList) {
          if (!seen.has(JSON.stringify(node))) {
            replicasToOpen.set(node, observed.replicaPoolSize);
            this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToOpen`);
          }
        }
      }
      const ret = {
        sentinelList: [observed.sentinelConnected].concat((0, utils_1.createNodeList)(observed.sentinelData)),
        epoch: Number(observed.masterData["config-epoch"]),
        sentinelToOpen: sentinel,
        masterToOpen: master,
        replicasToClose,
        replicasToOpen
      };
      return ret;
    }
    async transform(analyzed) {
      this.#trace("transform: enter");
      let promises = [];
      if (analyzed.sentinelToOpen) {
        this.#trace(`transform: opening a new sentinel`);
        if (this.#sentinelClient !== undefined && this.#sentinelClient.isOpen) {
          this.#trace(`transform: destroying old sentinel as open`);
          this.#sentinelClient.destroy();
          this.#sentinelClient = undefined;
        } else {
          this.#trace(`transform: not destroying old sentinel as not open`);
        }
        this.#trace(`transform: creating new sentinel to ${analyzed.sentinelToOpen.host}:${analyzed.sentinelToOpen.port}`);
        const node = analyzed.sentinelToOpen;
        const client = this.#createClient(analyzed.sentinelToOpen, this.#sentinelClientOptions, false);
        client.on("error", (err) => {
          if (this.#passthroughClientErrorEvents) {
            this.emit("error", new Error(`Sentinel Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
          }
          const event2 = {
            type: "SENTINEL",
            node: (0, utils_1.clientSocketToNode)(client.options.socket),
            error: err
          };
          this.emit("client-error", event2);
          this.#reset();
        });
        this.#sentinelClient = client;
        this.#trace(`transform: adding sentinel client connect() to promise list`);
        const promise = this.#sentinelClient.connect().then((client2) => {
          return this.#createPubSub(client2);
        });
        promises.push(promise);
        this.#trace(`created sentinel client to ${analyzed.sentinelToOpen.host}:${analyzed.sentinelToOpen.port}`);
        const event = {
          type: "SENTINEL_CHANGE",
          node: analyzed.sentinelToOpen
        };
        this.#trace(`transform: emiting topology-change event for sentinel_change`);
        if (!this.emit("topology-change", event)) {
          this.#trace(`transform: emit for topology-change for sentinel_change returned false`);
        }
      }
      if (analyzed.masterToOpen) {
        this.#trace(`transform: opening a new master`);
        const masterPromises = [];
        const masterWatches = [];
        this.#trace(`transform: destroying old masters if open`);
        for (const client of this.#masterClients) {
          masterWatches.push(client.isWatching || client.isDirtyWatch);
          if (client.isOpen) {
            client.destroy();
          }
        }
        this.#masterClients = [];
        this.#trace(`transform: creating all master clients and adding connect promises`);
        for (let i = 0;i < this.#masterPoolSize; i++) {
          const node = analyzed.masterToOpen;
          const client = this.#createClient(analyzed.masterToOpen, this.#nodeClientOptions);
          client.on("error", (err) => {
            if (this.#passthroughClientErrorEvents) {
              this.emit("error", new Error(`Master Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
            }
            const event2 = {
              type: "MASTER",
              node: (0, utils_1.clientSocketToNode)(client.options.socket),
              error: err
            };
            this.emit("client-error", event2);
          });
          if (masterWatches[i]) {
            client.setDirtyWatch("sentinel config changed in middle of a WATCH Transaction");
          }
          this.#masterClients.push(client);
          masterPromises.push(client.connect());
          this.#trace(`created master client to ${analyzed.masterToOpen.host}:${analyzed.masterToOpen.port}`);
        }
        this.#trace(`transform: adding promise to change #pubSubProxy node`);
        masterPromises.push(this.#pubSubProxy.changeNode(analyzed.masterToOpen));
        promises.push(...masterPromises);
        const event = {
          type: "MASTER_CHANGE",
          node: analyzed.masterToOpen
        };
        this.#trace(`transform: emiting topology-change event for master_change`);
        if (!this.emit("topology-change", event)) {
          this.#trace(`transform: emit for topology-change for master_change returned false`);
        }
        this.#configEpoch++;
      }
      const replicaCloseSet = new Set;
      for (const node of analyzed.replicasToClose) {
        const str = JSON.stringify(node);
        replicaCloseSet.add(str);
      }
      const newClientList = [];
      const removedSet = new Set;
      for (const replica of this.#replicaClients) {
        const node = (0, utils_1.clientSocketToNode)(replica.options.socket);
        const str = JSON.stringify(node);
        if (replicaCloseSet.has(str) || !replica.isOpen) {
          if (replica.isOpen) {
            const sockOpts = replica.options?.socket;
            this.#trace(`destroying replica client to ${sockOpts?.host}:${sockOpts?.port}`);
            replica.destroy();
          }
          if (!removedSet.has(str)) {
            const event = {
              type: "REPLICA_REMOVE",
              node
            };
            this.emit("topology-change", event);
            removedSet.add(str);
          }
        } else {
          newClientList.push(replica);
        }
      }
      this.#replicaClients = newClientList;
      if (analyzed.replicasToOpen.size != 0) {
        for (const [node, size] of analyzed.replicasToOpen) {
          for (let i = 0;i < size; i++) {
            const client = this.#createClient(node, this.#nodeClientOptions);
            client.on("error", (err) => {
              if (this.#passthroughClientErrorEvents) {
                this.emit("error", new Error(`Replica Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
              }
              const event2 = {
                type: "REPLICA",
                node: (0, utils_1.clientSocketToNode)(client.options.socket),
                error: err
              };
              this.emit("client-error", event2);
            });
            this.#replicaClients.push(client);
            promises.push(client.connect());
            this.#trace(`created replica client to ${node.host}:${node.port}`);
          }
          const event = {
            type: "REPLICA_ADD",
            node
          };
          this.emit("topology-change", event);
        }
      }
      if (analyzed.sentinelList.length != this.#sentinelRootNodes.length) {
        this.#sentinelRootNodes = analyzed.sentinelList;
        const event = {
          type: "SENTINE_LIST_CHANGE",
          size: analyzed.sentinelList.length
        };
        this.emit("topology-change", event);
      }
      await Promise.all(promises);
      this.#trace("transform: exit");
    }
    getMasterNode() {
      if (this.#masterClients.length == 0) {
        return;
      }
      for (const master of this.#masterClients) {
        if (master.isReady) {
          return (0, utils_1.clientSocketToNode)(master.options.socket);
        }
      }
      return;
    }
    getSentinelNode() {
      if (this.#sentinelClient === undefined) {
        return;
      }
      return (0, utils_1.clientSocketToNode)(this.#sentinelClient.options.socket);
    }
    getReplicaNodes() {
      const ret = new Map;
      const initialMap = new Map;
      for (const replica of this.#replicaClients) {
        const node = (0, utils_1.clientSocketToNode)(replica.options.socket);
        const hash = JSON.stringify(node);
        if (replica.isReady) {
          initialMap.set(hash, (initialMap.get(hash) ?? 0) + 1);
        } else {
          if (!initialMap.has(hash)) {
            initialMap.set(hash, 0);
          }
        }
      }
      for (const [key, value] of initialMap) {
        ret.set(JSON.parse(key), value);
      }
      return ret;
    }
    setTracer(tracer) {
      if (tracer) {
        this.#trace = (msg) => {
          tracer.push(msg);
        };
      } else {
        this.#trace = () => {};
      }
    }
  }

  class RedisSentinelFactory extends node_events_1.EventEmitter {
    options;
    #sentinelRootNodes;
    #replicaIdx = -1;
    constructor(options) {
      super();
      this.options = options;
      this.#sentinelRootNodes = options.sentinelRootNodes;
    }
    async updateSentinelRootNodes() {
      for (const node of this.#sentinelRootNodes) {
        const client = client_1.default.create({
          ...this.options.sentinelClientOptions,
          socket: {
            ...this.options.sentinelClientOptions?.socket,
            host: node.host,
            port: node.port,
            reconnectStrategy: false
          },
          modules: module_1.default
        }).on("error", (err) => this.emit(`updateSentinelRootNodes: ${err}`));
        try {
          await client.connect();
        } catch {
          if (client.isOpen) {
            client.destroy();
          }
          continue;
        }
        try {
          const sentinelData = await client.sentinel.sentinelSentinels(this.options.name);
          this.#sentinelRootNodes = [node].concat((0, utils_1.createNodeList)(sentinelData));
          return;
        } finally {
          client.destroy();
        }
      }
      throw new Error("Couldn't connect to any sentinel node");
    }
    async getMasterNode() {
      let connected = false;
      for (const node of this.#sentinelRootNodes) {
        const client = client_1.default.create({
          ...this.options.sentinelClientOptions,
          socket: {
            ...this.options.sentinelClientOptions?.socket,
            host: node.host,
            port: node.port,
            reconnectStrategy: false
          },
          modules: module_1.default
        }).on("error", (err) => this.emit(`getMasterNode: ${err}`));
        try {
          await client.connect();
        } catch {
          if (client.isOpen) {
            client.destroy();
          }
          continue;
        }
        connected = true;
        try {
          const masterData = await client.sentinel.sentinelMaster(this.options.name);
          let master = (0, utils_1.parseNode)(masterData);
          if (master === undefined) {
            continue;
          }
          return master;
        } finally {
          client.destroy();
        }
      }
      if (connected) {
        throw new Error("Master Node Not Enumerated");
      }
      throw new Error("couldn't connect to any sentinels");
    }
    async getMasterClient() {
      const master = await this.getMasterNode();
      return client_1.default.create({
        ...this.options.nodeClientOptions,
        socket: {
          ...this.options.nodeClientOptions?.socket,
          host: master.host,
          port: master.port
        }
      });
    }
    async getReplicaNodes() {
      let connected = false;
      for (const node of this.#sentinelRootNodes) {
        const client = client_1.default.create({
          ...this.options.sentinelClientOptions,
          socket: {
            ...this.options.sentinelClientOptions?.socket,
            host: node.host,
            port: node.port,
            reconnectStrategy: false
          },
          modules: module_1.default
        }).on("error", (err) => this.emit(`getReplicaNodes: ${err}`));
        try {
          await client.connect();
        } catch {
          if (client.isOpen) {
            client.destroy();
          }
          continue;
        }
        connected = true;
        try {
          const replicaData = await client.sentinel.sentinelReplicas(this.options.name);
          const replicas = (0, utils_1.createNodeList)(replicaData);
          if (replicas.length == 0) {
            continue;
          }
          return replicas;
        } finally {
          client.destroy();
        }
      }
      if (connected) {
        throw new Error("No Replicas Nodes Enumerated");
      }
      throw new Error("couldn't connect to any sentinels");
    }
    async getReplicaClient() {
      const replicas = await this.getReplicaNodes();
      if (replicas.length == 0) {
        throw new Error("no available replicas");
      }
      this.#replicaIdx++;
      if (this.#replicaIdx >= replicas.length) {
        this.#replicaIdx = 0;
      }
      return client_1.default.create({
        ...this.options.nodeClientOptions,
        socket: {
          ...this.options.nodeClientOptions?.socket,
          host: replicas[this.#replicaIdx].host,
          port: replicas[this.#replicaIdx].port
        }
      });
    }
  }
  exports.RedisSentinelFactory = RedisSentinelFactory;
});

// ../../node_modules/@redis/client/dist/index.js
var require_dist = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BasicPooledClientSideCache = exports.BasicClientSideCache = exports.REDIS_FLUSH_MODES = exports.GEO_REPLY_WITH = exports.createSentinel = exports.createCluster = exports.createClientPool = exports.createClient = exports.defineScript = exports.VerbatimString = exports.RESP_TYPES = undefined;
  var decoder_1 = require_decoder();
  Object.defineProperty(exports, "RESP_TYPES", { enumerable: true, get: function() {
    return decoder_1.RESP_TYPES;
  } });
  var verbatim_string_1 = require_verbatim_string();
  Object.defineProperty(exports, "VerbatimString", { enumerable: true, get: function() {
    return verbatim_string_1.VerbatimString;
  } });
  var lua_script_1 = require_lua_script();
  Object.defineProperty(exports, "defineScript", { enumerable: true, get: function() {
    return lua_script_1.defineScript;
  } });
  __exportStar(require_errors(), exports);
  var client_1 = __importDefault(require_client());
  exports.createClient = client_1.default.create;
  var pool_1 = require_pool();
  exports.createClientPool = pool_1.RedisClientPool.create;
  var cluster_1 = __importDefault(require_cluster());
  exports.createCluster = cluster_1.default.create;
  var sentinel_1 = __importDefault(require_sentinel());
  exports.createSentinel = sentinel_1.default.create;
  var GEOSEARCH_WITH_1 = require_GEOSEARCH_WITH();
  Object.defineProperty(exports, "GEO_REPLY_WITH", { enumerable: true, get: function() {
    return GEOSEARCH_WITH_1.GEO_REPLY_WITH;
  } });
  var FLUSHALL_1 = require_FLUSHALL();
  Object.defineProperty(exports, "REDIS_FLUSH_MODES", { enumerable: true, get: function() {
    return FLUSHALL_1.REDIS_FLUSH_MODES;
  } });
  var cache_1 = require_cache();
  Object.defineProperty(exports, "BasicClientSideCache", { enumerable: true, get: function() {
    return cache_1.BasicClientSideCache;
  } });
  Object.defineProperty(exports, "BasicPooledClientSideCache", { enumerable: true, get: function() {
    return cache_1.BasicPooledClientSideCache;
  } });
});

// ../../node_modules/@redis/bloom/dist/lib/commands/bloom/ADD.js
var require_ADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("BF.ADD");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/bloom/CARD.js
var require_CARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("BF.CARD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/bloom/EXISTS.js
var require_EXISTS2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, item) {
      parser.push("BF.EXISTS");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/bloom/helpers.js
var require_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformInfoV2Reply = undefined;
  var client_1 = require_dist();
  function transformInfoV2Reply(reply, typeMapping) {
    const mapType = typeMapping ? typeMapping[client_1.RESP_TYPES.MAP] : undefined;
    switch (mapType) {
      case Array: {
        return reply;
      }
      case Map: {
        const ret = new Map;
        for (let i = 0;i < reply.length; i += 2) {
          ret.set(reply[i].toString(), reply[i + 1]);
        }
        return ret;
      }
      default: {
        const ret = Object.create(null);
        for (let i = 0;i < reply.length; i += 2) {
          ret[reply[i].toString()] = reply[i + 1];
        }
        return ret;
      }
    }
  }
  exports.transformInfoV2Reply = transformInfoV2Reply;
});

// ../../node_modules/@redis/bloom/dist/lib/commands/bloom/INFO.js
var require_INFO2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("BF.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        return (0, helpers_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/bloom/INSERT.js
var require_INSERT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items, options) {
      parser.push("BF.INSERT");
      parser.pushKey(key);
      if (options?.CAPACITY !== undefined) {
        parser.push("CAPACITY", options.CAPACITY.toString());
      }
      if (options?.ERROR !== undefined) {
        parser.push("ERROR", options.ERROR.toString());
      }
      if (options?.EXPANSION !== undefined) {
        parser.push("EXPANSION", options.EXPANSION.toString());
      }
      if (options?.NOCREATE) {
        parser.push("NOCREATE");
      }
      if (options?.NONSCALING) {
        parser.push("NONSCALING");
      }
      parser.push("ITEMS");
      parser.pushVariadic(items);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/bloom/LOADCHUNK.js
var require_LOADCHUNK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, iterator2, chunk) {
      parser.push("BF.LOADCHUNK");
      parser.pushKey(key);
      parser.push(iterator2.toString(), chunk);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/bloom/MADD.js
var require_MADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("BF.MADD");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/bloom/MEXISTS.js
var require_MEXISTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, items) {
      parser.push("BF.MEXISTS");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/bloom/RESERVE.js
var require_RESERVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, errorRate, capacity, options) {
      parser.push("BF.RESERVE");
      parser.pushKey(key);
      parser.push(errorRate.toString(), capacity.toString());
      if (options?.EXPANSION) {
        parser.push("EXPANSION", options.EXPANSION.toString());
      }
      if (options?.NONSCALING) {
        parser.push("NONSCALING");
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/bloom/SCANDUMP.js
var require_SCANDUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, iterator2) {
      parser.push("BF.SCANDUMP");
      parser.pushKey(key);
      parser.push(iterator2.toString());
    },
    transformReply(reply) {
      return {
        iterator: reply[0],
        chunk: reply[1]
      };
    }
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/bloom/index.js
var require_bloom = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD());
  var CARD_1 = __importDefault(require_CARD());
  var EXISTS_1 = __importDefault(require_EXISTS2());
  var INFO_1 = __importDefault(require_INFO2());
  var INSERT_1 = __importDefault(require_INSERT());
  var LOADCHUNK_1 = __importDefault(require_LOADCHUNK());
  var MADD_1 = __importDefault(require_MADD());
  var MEXISTS_1 = __importDefault(require_MEXISTS());
  var RESERVE_1 = __importDefault(require_RESERVE());
  var SCANDUMP_1 = __importDefault(require_SCANDUMP());
  __exportStar(require_helpers(), exports);
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    CARD: CARD_1.default,
    card: CARD_1.default,
    EXISTS: EXISTS_1.default,
    exists: EXISTS_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    INSERT: INSERT_1.default,
    insert: INSERT_1.default,
    LOADCHUNK: LOADCHUNK_1.default,
    loadChunk: LOADCHUNK_1.default,
    MADD: MADD_1.default,
    mAdd: MADD_1.default,
    MEXISTS: MEXISTS_1.default,
    mExists: MEXISTS_1.default,
    RESERVE: RESERVE_1.default,
    reserve: RESERVE_1.default,
    SCANDUMP: SCANDUMP_1.default,
    scanDump: SCANDUMP_1.default
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INCRBY.js
var require_INCRBY2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("CMS.INCRBY");
      parser.pushKey(key);
      if (Array.isArray(items)) {
        for (const item of items) {
          pushIncrByItem(parser, item);
        }
      } else {
        pushIncrByItem(parser, items);
      }
    },
    transformReply: undefined
  };
  function pushIncrByItem(parser, { item, incrementBy }) {
    parser.push(item, incrementBy.toString());
  }
});

// ../../node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INFO.js
var require_INFO3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = require_bloom();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("CMS.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INITBYDIM.js
var require_INITBYDIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, width, depth) {
      parser.push("CMS.INITBYDIM");
      parser.pushKey(key);
      parser.push(width.toString(), depth.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INITBYPROB.js
var require_INITBYPROB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, error, probability) {
      parser.push("CMS.INITBYPROB");
      parser.pushKey(key);
      parser.push(error.toString(), probability.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/MERGE.js
var require_MERGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, source) {
      parser.push("CMS.MERGE");
      parser.pushKey(destination);
      parser.push(source.length.toString());
      if (isPlainSketches(source)) {
        parser.pushVariadic(source);
      } else {
        for (let i = 0;i < source.length; i++) {
          parser.push(source[i].name);
        }
        parser.push("WEIGHTS");
        for (let i = 0;i < source.length; i++) {
          parser.push(source[i].weight.toString());
        }
      }
    },
    transformReply: undefined
  };
  function isPlainSketches(src) {
    return typeof src[0] === "string" || src[0] instanceof Buffer;
  }
});

// ../../node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/QUERY.js
var require_QUERY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, items) {
      parser.push("CMS.QUERY");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/index.js
var require_count_min_sketch = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var INCRBY_1 = __importDefault(require_INCRBY2());
  var INFO_1 = __importDefault(require_INFO3());
  var INITBYDIM_1 = __importDefault(require_INITBYDIM());
  var INITBYPROB_1 = __importDefault(require_INITBYPROB());
  var MERGE_1 = __importDefault(require_MERGE());
  var QUERY_1 = __importDefault(require_QUERY());
  exports.default = {
    INCRBY: INCRBY_1.default,
    incrBy: INCRBY_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    INITBYDIM: INITBYDIM_1.default,
    initByDim: INITBYDIM_1.default,
    INITBYPROB: INITBYPROB_1.default,
    initByProb: INITBYPROB_1.default,
    MERGE: MERGE_1.default,
    merge: MERGE_1.default,
    QUERY: QUERY_1.default,
    query: QUERY_1.default
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/cuckoo/ADD.js
var require_ADD2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("CF.ADD");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/cuckoo/ADDNX.js
var require_ADDNX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("CF.ADDNX");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/cuckoo/COUNT.js
var require_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, item) {
      parser.push("CF.COUNT");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/cuckoo/DEL.js
var require_DEL2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("CF.DEL");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/cuckoo/EXISTS.js
var require_EXISTS3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("CF.EXISTS");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/cuckoo/INFO.js
var require_INFO4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = require_bloom();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("CF.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/cuckoo/INSERT.js
var require_INSERT2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseCfInsertArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function parseCfInsertArguments(parser, key, items, options) {
    parser.pushKey(key);
    if (options?.CAPACITY !== undefined) {
      parser.push("CAPACITY", options.CAPACITY.toString());
    }
    if (options?.NOCREATE) {
      parser.push("NOCREATE");
    }
    parser.push("ITEMS");
    parser.pushVariadic(items);
  }
  exports.parseCfInsertArguments = parseCfInsertArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("CF.INSERT");
      parseCfInsertArguments(...args);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/cuckoo/INSERTNX.js
var require_INSERTNX = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var INSERT_1 = __importStar(require_INSERT2());
  exports.default = {
    IS_READ_ONLY: INSERT_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      args[0].push("CF.INSERTNX");
      (0, INSERT_1.parseCfInsertArguments)(...args);
    },
    transformReply: INSERT_1.default.transformReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/cuckoo/LOADCHUNK.js
var require_LOADCHUNK2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, iterator2, chunk) {
      parser.push("CF.LOADCHUNK");
      parser.pushKey(key);
      parser.push(iterator2.toString(), chunk);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/cuckoo/RESERVE.js
var require_RESERVE2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, capacity, options) {
      parser.push("CF.RESERVE");
      parser.pushKey(key);
      parser.push(capacity.toString());
      if (options?.BUCKETSIZE !== undefined) {
        parser.push("BUCKETSIZE", options.BUCKETSIZE.toString());
      }
      if (options?.MAXITERATIONS !== undefined) {
        parser.push("MAXITERATIONS", options.MAXITERATIONS.toString());
      }
      if (options?.EXPANSION !== undefined) {
        parser.push("EXPANSION", options.EXPANSION.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/cuckoo/SCANDUMP.js
var require_SCANDUMP2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, iterator2) {
      parser.push("CF.SCANDUMP");
      parser.pushKey(key);
      parser.push(iterator2.toString());
    },
    transformReply(reply) {
      return {
        iterator: reply[0],
        chunk: reply[1]
      };
    }
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/cuckoo/index.js
var require_cuckoo = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD2());
  var ADDNX_1 = __importDefault(require_ADDNX());
  var COUNT_1 = __importDefault(require_COUNT());
  var DEL_1 = __importDefault(require_DEL2());
  var EXISTS_1 = __importDefault(require_EXISTS3());
  var INFO_1 = __importDefault(require_INFO4());
  var INSERT_1 = __importDefault(require_INSERT2());
  var INSERTNX_1 = __importDefault(require_INSERTNX());
  var LOADCHUNK_1 = __importDefault(require_LOADCHUNK2());
  var RESERVE_1 = __importDefault(require_RESERVE2());
  var SCANDUMP_1 = __importDefault(require_SCANDUMP2());
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    ADDNX: ADDNX_1.default,
    addNX: ADDNX_1.default,
    COUNT: COUNT_1.default,
    count: COUNT_1.default,
    DEL: DEL_1.default,
    del: DEL_1.default,
    EXISTS: EXISTS_1.default,
    exists: EXISTS_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    INSERT: INSERT_1.default,
    insert: INSERT_1.default,
    INSERTNX: INSERTNX_1.default,
    insertNX: INSERTNX_1.default,
    LOADCHUNK: LOADCHUNK_1.default,
    loadChunk: LOADCHUNK_1.default,
    RESERVE: RESERVE_1.default,
    reserve: RESERVE_1.default,
    SCANDUMP: SCANDUMP_1.default,
    scanDump: SCANDUMP_1.default
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/ADD.js
var require_ADD3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, values) {
      parser.push("TDIGEST.ADD");
      parser.pushKey(key);
      for (const value of values) {
        parser.push(value.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/BYRANK.js
var require_BYRANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformByRankArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function transformByRankArguments(parser, key, ranks) {
    parser.pushKey(key);
    for (const rank of ranks) {
      parser.push(rank.toString());
    }
  }
  exports.transformByRankArguments = transformByRankArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("TDIGEST.BYRANK");
      transformByRankArguments(...args);
    },
    transformReply: generic_transformers_1.transformDoubleArrayReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/BYREVRANK.js
var require_BYREVRANK = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var BYRANK_1 = __importStar(require_BYRANK());
  exports.default = {
    IS_READ_ONLY: BYRANK_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      args[0].push("TDIGEST.BYREVRANK");
      (0, BYRANK_1.transformByRankArguments)(...args);
    },
    transformReply: BYRANK_1.default.transformReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/CDF.js
var require_CDF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, values) {
      parser.push("TDIGEST.CDF");
      parser.pushKey(key);
      for (const item of values) {
        parser.push(item.toString());
      }
    },
    transformReply: generic_transformers_1.transformDoubleArrayReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/CREATE.js
var require_CREATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("TDIGEST.CREATE");
      parser.pushKey(key);
      if (options?.COMPRESSION !== undefined) {
        parser.push("COMPRESSION", options.COMPRESSION.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/INFO.js
var require_INFO5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = require_bloom();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TDIGEST.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/MAX.js
var require_MAX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TDIGEST.MAX");
      parser.pushKey(key);
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/MERGE.js
var require_MERGE2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, source, options) {
      parser.push("TDIGEST.MERGE");
      parser.pushKey(destination);
      parser.pushKeysLength(source);
      if (options?.COMPRESSION !== undefined) {
        parser.push("COMPRESSION", options.COMPRESSION.toString());
      }
      if (options?.OVERRIDE) {
        parser.push("OVERRIDE");
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/MIN.js
var require_MIN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TDIGEST.MIN");
      parser.pushKey(key);
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/QUANTILE.js
var require_QUANTILE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, quantiles) {
      parser.push("TDIGEST.QUANTILE");
      parser.pushKey(key);
      for (const quantile of quantiles) {
        parser.push(quantile.toString());
      }
    },
    transformReply: generic_transformers_1.transformDoubleArrayReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/RANK.js
var require_RANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRankArguments = undefined;
  function transformRankArguments(parser, key, values) {
    parser.pushKey(key);
    for (const value of values) {
      parser.push(value.toString());
    }
  }
  exports.transformRankArguments = transformRankArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("TDIGEST.RANK");
      transformRankArguments(...args);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/RESET.js
var require_RESET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("TDIGEST.RESET");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/REVRANK.js
var require_REVRANK = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var RANK_1 = __importStar(require_RANK());
  exports.default = {
    IS_READ_ONLY: RANK_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      args[0].push("TDIGEST.REVRANK");
      (0, RANK_1.transformRankArguments)(...args);
    },
    transformReply: RANK_1.default.transformReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/TRIMMED_MEAN.js
var require_TRIMMED_MEAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, lowCutPercentile, highCutPercentile) {
      parser.push("TDIGEST.TRIMMED_MEAN");
      parser.pushKey(key);
      parser.push(lowCutPercentile.toString(), highCutPercentile.toString());
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/t-digest/index.js
var require_t_digest = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD3());
  var BYRANK_1 = __importDefault(require_BYRANK());
  var BYREVRANK_1 = __importDefault(require_BYREVRANK());
  var CDF_1 = __importDefault(require_CDF());
  var CREATE_1 = __importDefault(require_CREATE());
  var INFO_1 = __importDefault(require_INFO5());
  var MAX_1 = __importDefault(require_MAX());
  var MERGE_1 = __importDefault(require_MERGE2());
  var MIN_1 = __importDefault(require_MIN());
  var QUANTILE_1 = __importDefault(require_QUANTILE());
  var RANK_1 = __importDefault(require_RANK());
  var RESET_1 = __importDefault(require_RESET());
  var REVRANK_1 = __importDefault(require_REVRANK());
  var TRIMMED_MEAN_1 = __importDefault(require_TRIMMED_MEAN());
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    BYRANK: BYRANK_1.default,
    byRank: BYRANK_1.default,
    BYREVRANK: BYREVRANK_1.default,
    byRevRank: BYREVRANK_1.default,
    CDF: CDF_1.default,
    cdf: CDF_1.default,
    CREATE: CREATE_1.default,
    create: CREATE_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    MAX: MAX_1.default,
    max: MAX_1.default,
    MERGE: MERGE_1.default,
    merge: MERGE_1.default,
    MIN: MIN_1.default,
    min: MIN_1.default,
    QUANTILE: QUANTILE_1.default,
    quantile: QUANTILE_1.default,
    RANK: RANK_1.default,
    rank: RANK_1.default,
    RESET: RESET_1.default,
    reset: RESET_1.default,
    REVRANK: REVRANK_1.default,
    revRank: REVRANK_1.default,
    TRIMMED_MEAN: TRIMMED_MEAN_1.default,
    trimmedMean: TRIMMED_MEAN_1.default
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/top-k/ADD.js
var require_ADD4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("TOPK.ADD");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/top-k/COUNT.js
var require_COUNT2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, items) {
      parser.push("TOPK.COUNT");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/top-k/INCRBY.js
var require_INCRBY3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function pushIncrByItem(parser, { item, incrementBy }) {
    parser.push(item, incrementBy.toString());
  }
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("TOPK.INCRBY");
      parser.pushKey(key);
      if (Array.isArray(items)) {
        for (const item of items) {
          pushIncrByItem(parser, item);
        }
      } else {
        pushIncrByItem(parser, items);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/top-k/INFO.js
var require_INFO6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var bloom_1 = require_bloom();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TOPK.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        reply[7] = generic_transformers_1.transformDoubleReply[2](reply[7], preserve, typeMapping);
        return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/top-k/LIST_WITHCOUNT.js
var require_LIST_WITHCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TOPK.LIST");
      parser.pushKey(key);
      parser.push("WITHCOUNT");
    },
    transformReply(rawReply) {
      const reply = [];
      for (let i = 0;i < rawReply.length; i++) {
        reply.push({
          item: rawReply[i],
          count: rawReply[++i]
        });
      }
      return reply;
    }
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/top-k/LIST.js
var require_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TOPK.LIST");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/top-k/QUERY.js
var require_QUERY2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("TOPK.QUERY");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/top-k/RESERVE.js
var require_RESERVE3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, topK, options) {
      parser.push("TOPK.RESERVE");
      parser.pushKey(key);
      parser.push(topK.toString());
      if (options) {
        parser.push(options.width.toString(), options.depth.toString(), options.decay.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/top-k/index.js
var require_top_k = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD4());
  var COUNT_1 = __importDefault(require_COUNT2());
  var INCRBY_1 = __importDefault(require_INCRBY3());
  var INFO_1 = __importDefault(require_INFO6());
  var LIST_WITHCOUNT_1 = __importDefault(require_LIST_WITHCOUNT());
  var LIST_1 = __importDefault(require_LIST());
  var QUERY_1 = __importDefault(require_QUERY2());
  var RESERVE_1 = __importDefault(require_RESERVE3());
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    COUNT: COUNT_1.default,
    count: COUNT_1.default,
    INCRBY: INCRBY_1.default,
    incrBy: INCRBY_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    LIST_WITHCOUNT: LIST_WITHCOUNT_1.default,
    listWithCount: LIST_WITHCOUNT_1.default,
    LIST: LIST_1.default,
    list: LIST_1.default,
    QUERY: QUERY_1.default,
    query: QUERY_1.default,
    RESERVE: RESERVE_1.default,
    reserve: RESERVE_1.default
  };
});

// ../../node_modules/@redis/bloom/dist/lib/commands/index.js
var require_commands3 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = __importDefault(require_bloom());
  var count_min_sketch_1 = __importDefault(require_count_min_sketch());
  var cuckoo_1 = __importDefault(require_cuckoo());
  var t_digest_1 = __importDefault(require_t_digest());
  var top_k_1 = __importDefault(require_top_k());
  exports.default = {
    bf: bloom_1.default,
    cms: count_min_sketch_1.default,
    cf: cuckoo_1.default,
    tDigest: t_digest_1.default,
    topK: top_k_1.default
  };
});

// ../../node_modules/@redis/bloom/dist/lib/index.js
var require_lib2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = undefined;
  var commands_1 = require_commands3();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return __importDefault(commands_1).default;
  } });
});

// ../../node_modules/@redis/json/dist/lib/commands/ARRAPPEND.js
var require_ARRAPPEND = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, json, ...jsons) {
      parser.push("JSON.ARRAPPEND");
      parser.pushKey(key);
      parser.push(path, (0, generic_transformers_1.transformRedisJsonArgument)(json));
      for (let i = 0;i < jsons.length; i++) {
        parser.push((0, generic_transformers_1.transformRedisJsonArgument)(jsons[i]));
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/ARRINDEX.js
var require_ARRINDEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, path, json, options) {
      parser.push("JSON.ARRINDEX");
      parser.pushKey(key);
      parser.push(path, (0, generic_transformers_1.transformRedisJsonArgument)(json));
      if (options?.range) {
        parser.push(options.range.start.toString());
        if (options.range.stop !== undefined) {
          parser.push(options.range.stop.toString());
        }
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/ARRINSERT.js
var require_ARRINSERT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, index, json, ...jsons) {
      parser.push("JSON.ARRINSERT");
      parser.pushKey(key);
      parser.push(path, index.toString(), (0, generic_transformers_1.transformRedisJsonArgument)(json));
      for (let i = 0;i < jsons.length; i++) {
        parser.push((0, generic_transformers_1.transformRedisJsonArgument)(jsons[i]));
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/ARRLEN.js
var require_ARRLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("JSON.ARRLEN");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/ARRPOP.js
var require_ARRPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.ARRPOP");
      parser.pushKey(key);
      if (options) {
        parser.push(options.path);
        if (options.index !== undefined) {
          parser.push(options.index.toString());
        }
      }
    },
    transformReply(reply) {
      return (0, generic_transformers_1.isArrayReply)(reply) ? reply.map((item) => (0, generic_transformers_1.transformRedisJsonNullReply)(item)) : (0, generic_transformers_1.transformRedisJsonNullReply)(reply);
    }
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/ARRTRIM.js
var require_ARRTRIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, start, stop) {
      parser.push("JSON.ARRTRIM");
      parser.pushKey(key);
      parser.push(path, start.toString(), stop.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/CLEAR.js
var require_CLEAR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.CLEAR");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/DEBUG_MEMORY.js
var require_DEBUG_MEMORY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.DEBUG", "MEMORY");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/DEL.js
var require_DEL3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.DEL");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/FORGET.js
var require_FORGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.FORGET");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/GET.js
var require_GET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.GET");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.pushVariadic(options.path);
      }
    },
    transformReply: generic_transformers_1.transformRedisJsonNullReply
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/MERGE.js
var require_MERGE3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, value) {
      parser.push("JSON.MERGE");
      parser.pushKey(key);
      parser.push(path, (0, generic_transformers_1.transformRedisJsonArgument)(value));
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/MGET.js
var require_MGET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, path) {
      parser.push("JSON.MGET");
      parser.pushKeys(keys);
      parser.push(path);
    },
    transformReply(reply) {
      return reply.map((json) => (0, generic_transformers_1.transformRedisJsonNullReply)(json));
    }
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/MSET.js
var require_MSET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, items) {
      parser.push("JSON.MSET");
      for (let i = 0;i < items.length; i++) {
        parser.pushKey(items[i].key);
        parser.push(items[i].path, (0, generic_transformers_1.transformRedisJsonArgument)(items[i].value));
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/NUMINCRBY.js
var require_NUMINCRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, by) {
      parser.push("JSON.NUMINCRBY");
      parser.pushKey(key);
      parser.push(path, by.toString());
    },
    transformReply: {
      2: (reply) => {
        return JSON.parse(reply.toString());
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/NUMMULTBY.js
var require_NUMMULTBY = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var NUMINCRBY_1 = __importDefault(require_NUMINCRBY());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, by) {
      parser.push("JSON.NUMMULTBY");
      parser.pushKey(key);
      parser.push(path, by.toString());
    },
    transformReply: NUMINCRBY_1.default.transformReply
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/OBJKEYS.js
var require_OBJKEYS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.OBJKEYS");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/OBJLEN.js
var require_OBJLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("JSON.OBJLEN");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/SET.js
var require_SET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, json, options) {
      parser.push("JSON.SET");
      parser.pushKey(key);
      parser.push(path, (0, generic_transformers_1.transformRedisJsonArgument)(json));
      if (options?.condition) {
        parser.push(options?.condition);
      } else if (options?.NX) {
        parser.push("NX");
      } else if (options?.XX) {
        parser.push("XX");
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/STRAPPEND.js
var require_STRAPPEND = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, append2, options) {
      parser.push("JSON.STRAPPEND");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
      parser.push((0, generic_transformers_1.transformRedisJsonArgument)(append2));
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/STRLEN.js
var require_STRLEN2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("JSON.STRLEN");
      parser.pushKey(key);
      if (options?.path) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/TOGGLE.js
var require_TOGGLE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path) {
      parser.push("JSON.TOGGLE");
      parser.pushKey(key);
      parser.push(path);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/TYPE.js
var require_TYPE2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("JSON.TYPE");
      parser.pushKey(key);
      if (options?.path) {
        parser.push(options.path);
      }
    },
    transformReply: {
      2: undefined,
      3: (reply) => {
        return reply[0];
      }
    }
  };
});

// ../../node_modules/@redis/json/dist/lib/commands/index.js
var require_commands4 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRedisJsonNullReply = exports.transformRedisJsonReply = exports.transformRedisJsonArgument = undefined;
  var ARRAPPEND_1 = __importDefault(require_ARRAPPEND());
  var ARRINDEX_1 = __importDefault(require_ARRINDEX());
  var ARRINSERT_1 = __importDefault(require_ARRINSERT());
  var ARRLEN_1 = __importDefault(require_ARRLEN());
  var ARRPOP_1 = __importDefault(require_ARRPOP());
  var ARRTRIM_1 = __importDefault(require_ARRTRIM());
  var CLEAR_1 = __importDefault(require_CLEAR());
  var DEBUG_MEMORY_1 = __importDefault(require_DEBUG_MEMORY());
  var DEL_1 = __importDefault(require_DEL3());
  var FORGET_1 = __importDefault(require_FORGET());
  var GET_1 = __importDefault(require_GET2());
  var MERGE_1 = __importDefault(require_MERGE3());
  var MGET_1 = __importDefault(require_MGET2());
  var MSET_1 = __importDefault(require_MSET2());
  var NUMINCRBY_1 = __importDefault(require_NUMINCRBY());
  var NUMMULTBY_1 = __importDefault(require_NUMMULTBY());
  var OBJKEYS_1 = __importDefault(require_OBJKEYS());
  var OBJLEN_1 = __importDefault(require_OBJLEN());
  var SET_1 = __importDefault(require_SET2());
  var STRAPPEND_1 = __importDefault(require_STRAPPEND());
  var STRLEN_1 = __importDefault(require_STRLEN2());
  var TOGGLE_1 = __importDefault(require_TOGGLE());
  var TYPE_1 = __importDefault(require_TYPE2());
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformRedisJsonArgument", { enumerable: true, get: function() {
    return generic_transformers_1.transformRedisJsonArgument;
  } });
  Object.defineProperty(exports, "transformRedisJsonReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformRedisJsonReply;
  } });
  Object.defineProperty(exports, "transformRedisJsonNullReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformRedisJsonNullReply;
  } });
  exports.default = {
    ARRAPPEND: ARRAPPEND_1.default,
    arrAppend: ARRAPPEND_1.default,
    ARRINDEX: ARRINDEX_1.default,
    arrIndex: ARRINDEX_1.default,
    ARRINSERT: ARRINSERT_1.default,
    arrInsert: ARRINSERT_1.default,
    ARRLEN: ARRLEN_1.default,
    arrLen: ARRLEN_1.default,
    ARRPOP: ARRPOP_1.default,
    arrPop: ARRPOP_1.default,
    ARRTRIM: ARRTRIM_1.default,
    arrTrim: ARRTRIM_1.default,
    CLEAR: CLEAR_1.default,
    clear: CLEAR_1.default,
    DEBUG_MEMORY: DEBUG_MEMORY_1.default,
    debugMemory: DEBUG_MEMORY_1.default,
    DEL: DEL_1.default,
    del: DEL_1.default,
    FORGET: FORGET_1.default,
    forget: FORGET_1.default,
    GET: GET_1.default,
    get: GET_1.default,
    MERGE: MERGE_1.default,
    merge: MERGE_1.default,
    MGET: MGET_1.default,
    mGet: MGET_1.default,
    MSET: MSET_1.default,
    mSet: MSET_1.default,
    NUMINCRBY: NUMINCRBY_1.default,
    numIncrBy: NUMINCRBY_1.default,
    NUMMULTBY: NUMMULTBY_1.default,
    numMultBy: NUMMULTBY_1.default,
    OBJKEYS: OBJKEYS_1.default,
    objKeys: OBJKEYS_1.default,
    OBJLEN: OBJLEN_1.default,
    objLen: OBJLEN_1.default,
    SET: SET_1.default,
    set: SET_1.default,
    STRAPPEND: STRAPPEND_1.default,
    strAppend: STRAPPEND_1.default,
    STRLEN: STRLEN_1.default,
    strLen: STRLEN_1.default,
    TOGGLE: TOGGLE_1.default,
    toggle: TOGGLE_1.default,
    TYPE: TYPE_1.default,
    type: TYPE_1.default
  };
});

// ../../node_modules/@redis/json/dist/lib/index.js
var require_lib3 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = undefined;
  var commands_1 = require_commands4();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return __importDefault(commands_1).default;
  } });
});

// ../../node_modules/@redis/search/dist/lib/commands/_LIST.js
var require__LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("FT._LIST");
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/CREATE.js
var require_CREATE2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.REDISEARCH_LANGUAGE = exports.parseSchema = exports.SCHEMA_GEO_SHAPE_COORD_SYSTEM = exports.SCHEMA_VECTOR_FIELD_ALGORITHM = exports.SCHEMA_TEXT_FIELD_PHONETIC = exports.SCHEMA_FIELD_TYPE = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.SCHEMA_FIELD_TYPE = {
    TEXT: "TEXT",
    NUMERIC: "NUMERIC",
    GEO: "GEO",
    TAG: "TAG",
    VECTOR: "VECTOR",
    GEOSHAPE: "GEOSHAPE"
  };
  exports.SCHEMA_TEXT_FIELD_PHONETIC = {
    DM_EN: "dm:en",
    DM_FR: "dm:fr",
    FM_PT: "dm:pt",
    DM_ES: "dm:es"
  };
  exports.SCHEMA_VECTOR_FIELD_ALGORITHM = {
    FLAT: "FLAT",
    HNSW: "HNSW"
  };
  exports.SCHEMA_GEO_SHAPE_COORD_SYSTEM = {
    SPHERICAL: "SPHERICAL",
    FLAT: "FLAT"
  };
  function parseCommonSchemaFieldOptions(parser, fieldOptions) {
    if (fieldOptions.SORTABLE) {
      parser.push("SORTABLE");
      if (fieldOptions.SORTABLE === "UNF") {
        parser.push("UNF");
      }
    }
    if (fieldOptions.NOINDEX) {
      parser.push("NOINDEX");
    }
  }
  function parseSchema(parser, schema) {
    for (const [field, fieldOptions] of Object.entries(schema)) {
      parser.push(field);
      if (typeof fieldOptions === "string") {
        parser.push(fieldOptions);
        continue;
      }
      if (fieldOptions.AS) {
        parser.push("AS", fieldOptions.AS);
      }
      parser.push(fieldOptions.type);
      if (fieldOptions.INDEXMISSING) {
        parser.push("INDEXMISSING");
      }
      switch (fieldOptions.type) {
        case exports.SCHEMA_FIELD_TYPE.TEXT:
          if (fieldOptions.NOSTEM) {
            parser.push("NOSTEM");
          }
          if (fieldOptions.WEIGHT) {
            parser.push("WEIGHT", fieldOptions.WEIGHT.toString());
          }
          if (fieldOptions.PHONETIC) {
            parser.push("PHONETIC", fieldOptions.PHONETIC);
          }
          if (fieldOptions.WITHSUFFIXTRIE) {
            parser.push("WITHSUFFIXTRIE");
          }
          if (fieldOptions.INDEXEMPTY) {
            parser.push("INDEXEMPTY");
          }
          parseCommonSchemaFieldOptions(parser, fieldOptions);
          break;
        case exports.SCHEMA_FIELD_TYPE.NUMERIC:
        case exports.SCHEMA_FIELD_TYPE.GEO:
          parseCommonSchemaFieldOptions(parser, fieldOptions);
          break;
        case exports.SCHEMA_FIELD_TYPE.TAG:
          if (fieldOptions.SEPARATOR) {
            parser.push("SEPARATOR", fieldOptions.SEPARATOR);
          }
          if (fieldOptions.CASESENSITIVE) {
            parser.push("CASESENSITIVE");
          }
          if (fieldOptions.WITHSUFFIXTRIE) {
            parser.push("WITHSUFFIXTRIE");
          }
          if (fieldOptions.INDEXEMPTY) {
            parser.push("INDEXEMPTY");
          }
          parseCommonSchemaFieldOptions(parser, fieldOptions);
          break;
        case exports.SCHEMA_FIELD_TYPE.VECTOR:
          parser.push(fieldOptions.ALGORITHM);
          const args = [];
          args.push("TYPE", fieldOptions.TYPE, "DIM", fieldOptions.DIM.toString(), "DISTANCE_METRIC", fieldOptions.DISTANCE_METRIC);
          if (fieldOptions.INITIAL_CAP) {
            args.push("INITIAL_CAP", fieldOptions.INITIAL_CAP.toString());
          }
          switch (fieldOptions.ALGORITHM) {
            case exports.SCHEMA_VECTOR_FIELD_ALGORITHM.FLAT:
              if (fieldOptions.BLOCK_SIZE) {
                args.push("BLOCK_SIZE", fieldOptions.BLOCK_SIZE.toString());
              }
              break;
            case exports.SCHEMA_VECTOR_FIELD_ALGORITHM.HNSW:
              if (fieldOptions.M) {
                args.push("M", fieldOptions.M.toString());
              }
              if (fieldOptions.EF_CONSTRUCTION) {
                args.push("EF_CONSTRUCTION", fieldOptions.EF_CONSTRUCTION.toString());
              }
              if (fieldOptions.EF_RUNTIME) {
                args.push("EF_RUNTIME", fieldOptions.EF_RUNTIME.toString());
              }
              break;
          }
          parser.pushVariadicWithLength(args);
          break;
        case exports.SCHEMA_FIELD_TYPE.GEOSHAPE:
          if (fieldOptions.COORD_SYSTEM !== undefined) {
            parser.push("COORD_SYSTEM", fieldOptions.COORD_SYSTEM);
          }
          break;
      }
    }
  }
  exports.parseSchema = parseSchema;
  exports.REDISEARCH_LANGUAGE = {
    ARABIC: "Arabic",
    BASQUE: "Basque",
    CATALANA: "Catalan",
    DANISH: "Danish",
    DUTCH: "Dutch",
    ENGLISH: "English",
    FINNISH: "Finnish",
    FRENCH: "French",
    GERMAN: "German",
    GREEK: "Greek",
    HUNGARIAN: "Hungarian",
    INDONESAIN: "Indonesian",
    IRISH: "Irish",
    ITALIAN: "Italian",
    LITHUANIAN: "Lithuanian",
    NEPALI: "Nepali",
    NORWEIGAN: "Norwegian",
    PORTUGUESE: "Portuguese",
    ROMANIAN: "Romanian",
    RUSSIAN: "Russian",
    SPANISH: "Spanish",
    SWEDISH: "Swedish",
    TAMIL: "Tamil",
    TURKISH: "Turkish",
    CHINESE: "Chinese"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, schema, options) {
      parser.push("FT.CREATE", index);
      if (options?.ON) {
        parser.push("ON", options.ON);
      }
      (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "PREFIX", options?.PREFIX);
      if (options?.FILTER) {
        parser.push("FILTER", options.FILTER);
      }
      if (options?.LANGUAGE) {
        parser.push("LANGUAGE", options.LANGUAGE);
      }
      if (options?.LANGUAGE_FIELD) {
        parser.push("LANGUAGE_FIELD", options.LANGUAGE_FIELD);
      }
      if (options?.SCORE) {
        parser.push("SCORE", options.SCORE.toString());
      }
      if (options?.SCORE_FIELD) {
        parser.push("SCORE_FIELD", options.SCORE_FIELD);
      }
      if (options?.MAXTEXTFIELDS) {
        parser.push("MAXTEXTFIELDS");
      }
      if (options?.TEMPORARY) {
        parser.push("TEMPORARY", options.TEMPORARY.toString());
      }
      if (options?.NOOFFSETS) {
        parser.push("NOOFFSETS");
      }
      if (options?.NOHL) {
        parser.push("NOHL");
      }
      if (options?.NOFIELDS) {
        parser.push("NOFIELDS");
      }
      if (options?.NOFREQS) {
        parser.push("NOFREQS");
      }
      if (options?.SKIPINITIALSCAN) {
        parser.push("SKIPINITIALSCAN");
      }
      (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "STOPWORDS", options?.STOPWORDS);
      parser.push("SCHEMA");
      parseSchema(parser, schema);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/ALTER.js
var require_ALTER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CREATE_1 = require_CREATE2();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, schema) {
      parser.push("FT.ALTER", index, "SCHEMA", "ADD");
      (0, CREATE_1.parseSchema)(parser, schema);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/dialect/default.js
var require_default = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_DIALECT = undefined;
  exports.DEFAULT_DIALECT = "2";
});

// ../../node_modules/@redis/search/dist/lib/commands/SEARCH.js
var require_SEARCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseSearchOptions = exports.parseParamsArgument = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var default_1 = require_default();
  function parseParamsArgument(parser, params) {
    if (params) {
      parser.push("PARAMS");
      const args = [];
      for (const key in params) {
        if (!Object.hasOwn(params, key))
          continue;
        const value = params[key];
        args.push(key, typeof value === "number" ? value.toString() : value);
      }
      parser.pushVariadicWithLength(args);
    }
  }
  exports.parseParamsArgument = parseParamsArgument;
  function parseSearchOptions(parser, options) {
    if (options?.VERBATIM) {
      parser.push("VERBATIM");
    }
    if (options?.NOSTOPWORDS) {
      parser.push("NOSTOPWORDS");
    }
    (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "INKEYS", options?.INKEYS);
    (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "INFIELDS", options?.INFIELDS);
    (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "RETURN", options?.RETURN);
    if (options?.SUMMARIZE) {
      parser.push("SUMMARIZE");
      if (typeof options.SUMMARIZE === "object") {
        (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "FIELDS", options.SUMMARIZE.FIELDS);
        if (options.SUMMARIZE.FRAGS !== undefined) {
          parser.push("FRAGS", options.SUMMARIZE.FRAGS.toString());
        }
        if (options.SUMMARIZE.LEN !== undefined) {
          parser.push("LEN", options.SUMMARIZE.LEN.toString());
        }
        if (options.SUMMARIZE.SEPARATOR !== undefined) {
          parser.push("SEPARATOR", options.SUMMARIZE.SEPARATOR);
        }
      }
    }
    if (options?.HIGHLIGHT) {
      parser.push("HIGHLIGHT");
      if (typeof options.HIGHLIGHT === "object") {
        (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "FIELDS", options.HIGHLIGHT.FIELDS);
        if (options.HIGHLIGHT.TAGS) {
          parser.push("TAGS", options.HIGHLIGHT.TAGS.open, options.HIGHLIGHT.TAGS.close);
        }
      }
    }
    if (options?.SLOP !== undefined) {
      parser.push("SLOP", options.SLOP.toString());
    }
    if (options?.TIMEOUT !== undefined) {
      parser.push("TIMEOUT", options.TIMEOUT.toString());
    }
    if (options?.INORDER) {
      parser.push("INORDER");
    }
    if (options?.LANGUAGE) {
      parser.push("LANGUAGE", options.LANGUAGE);
    }
    if (options?.EXPANDER) {
      parser.push("EXPANDER", options.EXPANDER);
    }
    if (options?.SCORER) {
      parser.push("SCORER", options.SCORER);
    }
    if (options?.SORTBY) {
      parser.push("SORTBY");
      if (typeof options.SORTBY === "string" || options.SORTBY instanceof Buffer) {
        parser.push(options.SORTBY);
      } else {
        parser.push(options.SORTBY.BY);
        if (options.SORTBY.DIRECTION) {
          parser.push(options.SORTBY.DIRECTION);
        }
      }
    }
    if (options?.LIMIT) {
      parser.push("LIMIT", options.LIMIT.from.toString(), options.LIMIT.size.toString());
    }
    parseParamsArgument(parser, options?.PARAMS);
    if (options?.DIALECT) {
      parser.push("DIALECT", options.DIALECT.toString());
    } else {
      parser.push("DIALECT", default_1.DEFAULT_DIALECT);
    }
  }
  exports.parseSearchOptions = parseSearchOptions;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.SEARCH", index, query);
      parseSearchOptions(parser, options);
    },
    transformReply: {
      2: (reply) => {
        const withoutDocuments = reply[0] + 1 == reply.length;
        const documents = [];
        let i = 1;
        while (i < reply.length) {
          documents.push({
            id: reply[i++],
            value: withoutDocuments ? Object.create(null) : documentValue(reply[i++])
          });
        }
        return {
          total: reply[0],
          documents
        };
      },
      3: undefined
    },
    unstableResp3: true
  };
  function documentValue(tuples) {
    const message = Object.create(null);
    if (!tuples) {
      return message;
    }
    let i = 0;
    while (i < tuples.length) {
      const key = tuples[i++], value = tuples[i++];
      if (key === "$") {
        try {
          Object.assign(message, JSON.parse(value));
          continue;
        } catch {}
      }
      message[key] = value;
    }
    return message;
  }
});

// ../../node_modules/@redis/search/dist/lib/commands/AGGREGATE.js
var require_AGGREGATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseAggregateOptions = exports.FT_AGGREGATE_GROUP_BY_REDUCERS = exports.FT_AGGREGATE_STEPS = undefined;
  var SEARCH_1 = require_SEARCH();
  var generic_transformers_1 = require_generic_transformers();
  var default_1 = require_default();
  exports.FT_AGGREGATE_STEPS = {
    GROUPBY: "GROUPBY",
    SORTBY: "SORTBY",
    APPLY: "APPLY",
    LIMIT: "LIMIT",
    FILTER: "FILTER"
  };
  exports.FT_AGGREGATE_GROUP_BY_REDUCERS = {
    COUNT: "COUNT",
    COUNT_DISTINCT: "COUNT_DISTINCT",
    COUNT_DISTINCTISH: "COUNT_DISTINCTISH",
    SUM: "SUM",
    MIN: "MIN",
    MAX: "MAX",
    AVG: "AVG",
    STDDEV: "STDDEV",
    QUANTILE: "QUANTILE",
    TOLIST: "TOLIST",
    FIRST_VALUE: "FIRST_VALUE",
    RANDOM_SAMPLE: "RANDOM_SAMPLE"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, index, query, options) {
      parser.push("FT.AGGREGATE", index, query);
      return parseAggregateOptions(parser, options);
    },
    transformReply: {
      2: (rawReply, preserve, typeMapping) => {
        const results = [];
        for (let i = 1;i < rawReply.length; i++) {
          results.push((0, generic_transformers_1.transformTuplesReply)(rawReply[i], preserve, typeMapping));
        }
        return {
          total: Number(rawReply[0]),
          results
        };
      },
      3: undefined
    },
    unstableResp3: true
  };
  function parseAggregateOptions(parser, options) {
    if (options?.VERBATIM) {
      parser.push("VERBATIM");
    }
    if (options?.ADDSCORES) {
      parser.push("ADDSCORES");
    }
    if (options?.LOAD) {
      const args = [];
      if (Array.isArray(options.LOAD)) {
        for (const load of options.LOAD) {
          pushLoadField(args, load);
        }
      } else {
        pushLoadField(args, options.LOAD);
      }
      parser.push("LOAD");
      parser.pushVariadicWithLength(args);
    }
    if (options?.TIMEOUT !== undefined) {
      parser.push("TIMEOUT", options.TIMEOUT.toString());
    }
    if (options?.STEPS) {
      for (const step of options.STEPS) {
        parser.push(step.type);
        switch (step.type) {
          case exports.FT_AGGREGATE_STEPS.GROUPBY:
            if (!step.properties) {
              parser.push("0");
            } else {
              parser.pushVariadicWithLength(step.properties);
            }
            if (Array.isArray(step.REDUCE)) {
              for (const reducer of step.REDUCE) {
                parseGroupByReducer(parser, reducer);
              }
            } else {
              parseGroupByReducer(parser, step.REDUCE);
            }
            break;
          case exports.FT_AGGREGATE_STEPS.SORTBY:
            const args = [];
            if (Array.isArray(step.BY)) {
              for (const by of step.BY) {
                pushSortByProperty(args, by);
              }
            } else {
              pushSortByProperty(args, step.BY);
            }
            if (step.MAX) {
              args.push("MAX", step.MAX.toString());
            }
            parser.pushVariadicWithLength(args);
            break;
          case exports.FT_AGGREGATE_STEPS.APPLY:
            parser.push(step.expression, "AS", step.AS);
            break;
          case exports.FT_AGGREGATE_STEPS.LIMIT:
            parser.push(step.from.toString(), step.size.toString());
            break;
          case exports.FT_AGGREGATE_STEPS.FILTER:
            parser.push(step.expression);
            break;
        }
      }
    }
    (0, SEARCH_1.parseParamsArgument)(parser, options?.PARAMS);
    if (options?.DIALECT) {
      parser.push("DIALECT", options.DIALECT.toString());
    } else {
      parser.push("DIALECT", default_1.DEFAULT_DIALECT);
    }
  }
  exports.parseAggregateOptions = parseAggregateOptions;
  function pushLoadField(args, toLoad) {
    if (typeof toLoad === "string" || toLoad instanceof Buffer) {
      args.push(toLoad);
    } else {
      args.push(toLoad.identifier);
      if (toLoad.AS) {
        args.push("AS", toLoad.AS);
      }
    }
  }
  function parseGroupByReducer(parser, reducer) {
    parser.push("REDUCE", reducer.type);
    switch (reducer.type) {
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT:
        parser.push("0");
        break;
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT_DISTINCT:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT_DISTINCTISH:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.SUM:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.MIN:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.MAX:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.AVG:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.STDDEV:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.TOLIST:
        parser.push("1", reducer.property);
        break;
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.QUANTILE:
        parser.push("2", reducer.property, reducer.quantile.toString());
        break;
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.FIRST_VALUE: {
        const args = [reducer.property];
        if (reducer.BY) {
          args.push("BY");
          if (typeof reducer.BY === "string" || reducer.BY instanceof Buffer) {
            args.push(reducer.BY);
          } else {
            args.push(reducer.BY.property);
            if (reducer.BY.direction) {
              args.push(reducer.BY.direction);
            }
          }
        }
        parser.pushVariadicWithLength(args);
        break;
      }
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.RANDOM_SAMPLE:
        parser.push("2", reducer.property, reducer.sampleSize.toString());
        break;
    }
    if (reducer.AS) {
      parser.push("AS", reducer.AS);
    }
  }
  function pushSortByProperty(args, sortBy) {
    if (typeof sortBy === "string" || sortBy instanceof Buffer) {
      args.push(sortBy);
    } else {
      args.push(sortBy.BY);
      if (sortBy.DIRECTION) {
        args.push(sortBy.DIRECTION);
      }
    }
  }
});

// ../../node_modules/@redis/search/dist/lib/commands/AGGREGATE_WITHCURSOR.js
var require_AGGREGATE_WITHCURSOR = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var AGGREGATE_1 = __importDefault(require_AGGREGATE());
  exports.default = {
    IS_READ_ONLY: AGGREGATE_1.default.IS_READ_ONLY,
    parseCommand(parser, index, query, options) {
      AGGREGATE_1.default.parseCommand(parser, index, query, options);
      parser.push("WITHCURSOR");
      if (options?.COUNT !== undefined) {
        parser.push("COUNT", options.COUNT.toString());
      }
      if (options?.MAXIDLE !== undefined) {
        parser.push("MAXIDLE", options.MAXIDLE.toString());
      }
    },
    transformReply: {
      2: (reply) => {
        return {
          ...AGGREGATE_1.default.transformReply[2](reply[0]),
          cursor: reply[1]
        };
      },
      3: undefined
    },
    unstableResp3: true
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/ALIASADD.js
var require_ALIASADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, alias, index) {
      parser.push("FT.ALIASADD", alias, index);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/ALIASDEL.js
var require_ALIASDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, alias) {
      parser.push("FT.ALIASDEL", alias);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/ALIASUPDATE.js
var require_ALIASUPDATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, alias, index) {
      parser.push("FT.ALIASUPDATE", alias, index);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/CONFIG_GET.js
var require_CONFIG_GET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, option) {
      parser.push("FT.CONFIG", "GET", option);
    },
    transformReply(reply) {
      const transformedReply = Object.create(null);
      for (const item of reply) {
        const [key, value] = item;
        transformedReply[key.toString()] = value;
      }
      return transformedReply;
    }
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/CONFIG_SET.js
var require_CONFIG_SET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, property, value) {
      parser.push("FT.CONFIG", "SET", property, value);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/CURSOR_DEL.js
var require_CURSOR_DEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, cursorId) {
      parser.push("FT.CURSOR", "DEL", index, cursorId.toString());
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/CURSOR_READ.js
var require_CURSOR_READ = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var AGGREGATE_WITHCURSOR_1 = __importDefault(require_AGGREGATE_WITHCURSOR());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, cursor, options) {
      parser.push("FT.CURSOR", "READ", index, cursor.toString());
      if (options?.COUNT !== undefined) {
        parser.push("COUNT", options.COUNT.toString());
      }
    },
    transformReply: AGGREGATE_WITHCURSOR_1.default.transformReply,
    unstableResp3: true
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/DICTADD.js
var require_DICTADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, dictionary, term) {
      parser.push("FT.DICTADD", dictionary);
      parser.pushVariadic(term);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/DICTDEL.js
var require_DICTDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, dictionary, term) {
      parser.push("FT.DICTDEL", dictionary);
      parser.pushVariadic(term);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/DICTDUMP.js
var require_DICTDUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, dictionary) {
      parser.push("FT.DICTDUMP", dictionary);
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/DROPINDEX.js
var require_DROPINDEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, options) {
      parser.push("FT.DROPINDEX", index);
      if (options?.DD) {
        parser.push("DD");
      }
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/EXPLAIN.js
var require_EXPLAIN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SEARCH_1 = require_SEARCH();
  var default_1 = require_default();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.EXPLAIN", index, query);
      (0, SEARCH_1.parseParamsArgument)(parser, options?.PARAMS);
      if (options?.DIALECT) {
        parser.push("DIALECT", options.DIALECT.toString());
      } else {
        parser.push("DIALECT", default_1.DEFAULT_DIALECT);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/EXPLAINCLI.js
var require_EXPLAINCLI = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var default_1 = require_default();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.EXPLAINCLI", index, query);
      if (options?.DIALECT) {
        parser.push("DIALECT", options.DIALECT.toString());
      } else {
        parser.push("DIALECT", default_1.DEFAULT_DIALECT);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/INFO.js
var require_INFO7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index) {
      parser.push("FT.INFO", index);
    },
    transformReply: {
      2: transformV2Reply,
      3: undefined
    },
    unstableResp3: true
  };
  function transformV2Reply(reply, preserve, typeMapping) {
    const myTransformFunc = (0, generic_transformers_1.createTransformTuplesReplyFunc)(preserve, typeMapping);
    const ret = {};
    for (let i = 0;i < reply.length; i += 2) {
      const key = reply[i].toString();
      switch (key) {
        case "index_name":
        case "index_options":
        case "num_docs":
        case "max_doc_id":
        case "num_terms":
        case "num_records":
        case "total_inverted_index_blocks":
        case "hash_indexing_failures":
        case "indexing":
        case "number_of_uses":
        case "cleaning":
        case "stopwords_list":
          ret[key] = reply[i + 1];
          break;
        case "inverted_sz_mb":
        case "vector_index_sz_mb":
        case "offset_vectors_sz_mb":
        case "doc_table_size_mb":
        case "sortable_values_size_mb":
        case "key_table_size_mb":
        case "text_overhead_sz_mb":
        case "tag_overhead_sz_mb":
        case "total_index_memory_sz_mb":
        case "geoshapes_sz_mb":
        case "records_per_doc_avg":
        case "bytes_per_record_avg":
        case "offsets_per_term_avg":
        case "offset_bits_per_record_avg":
        case "total_indexing_time":
        case "percent_indexed":
          ret[key] = generic_transformers_1.transformDoubleReply[2](reply[i + 1], undefined, typeMapping);
          break;
        case "index_definition":
          ret[key] = myTransformFunc(reply[i + 1]);
          break;
        case "attributes":
          ret[key] = reply[i + 1].map((attribute) => myTransformFunc(attribute));
          break;
        case "gc_stats": {
          const innerRet = {};
          const array = reply[i + 1];
          for (let i2 = 0;i2 < array.length; i2 += 2) {
            const innerKey = array[i2].toString();
            switch (innerKey) {
              case "bytes_collected":
              case "total_ms_run":
              case "total_cycles":
              case "average_cycle_time_ms":
              case "last_run_time_ms":
              case "gc_numeric_trees_missed":
              case "gc_blocks_denied":
                innerRet[innerKey] = generic_transformers_1.transformDoubleReply[2](array[i2 + 1], undefined, typeMapping);
                break;
            }
          }
          ret[key] = innerRet;
          break;
        }
        case "cursor_stats": {
          const innerRet = {};
          const array = reply[i + 1];
          for (let i2 = 0;i2 < array.length; i2 += 2) {
            const innerKey = array[i2].toString();
            switch (innerKey) {
              case "global_idle":
              case "global_total":
              case "index_capacity":
              case "index_total":
                innerRet[innerKey] = array[i2 + 1];
                break;
            }
          }
          ret[key] = innerRet;
          break;
        }
      }
    }
    return ret;
  }
});

// ../../node_modules/@redis/search/dist/lib/commands/PROFILE_SEARCH.js
var require_PROFILE_SEARCH = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SEARCH_1 = __importStar(require_SEARCH());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.PROFILE", index, "SEARCH");
      if (options?.LIMITED) {
        parser.push("LIMITED");
      }
      parser.push("QUERY", query);
      (0, SEARCH_1.parseSearchOptions)(parser, options);
    },
    transformReply: {
      2: (reply) => {
        return {
          results: SEARCH_1.default.transformReply[2](reply[0]),
          profile: reply[1]
        };
      },
      3: (reply) => reply
    },
    unstableResp3: true
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/PROFILE_AGGREGATE.js
var require_PROFILE_AGGREGATE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var AGGREGATE_1 = __importStar(require_AGGREGATE());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.PROFILE", index, "AGGREGATE");
      if (options?.LIMITED) {
        parser.push("LIMITED");
      }
      parser.push("QUERY", query);
      (0, AGGREGATE_1.parseAggregateOptions)(parser, options);
    },
    transformReply: {
      2: (reply) => {
        return {
          results: AGGREGATE_1.default.transformReply[2](reply[0]),
          profile: reply[1]
        };
      },
      3: (reply) => reply
    },
    unstableResp3: true
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/SEARCH_NOCONTENT.js
var require_SEARCH_NOCONTENT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SEARCH_1 = __importDefault(require_SEARCH());
  exports.default = {
    NOT_KEYED_COMMAND: SEARCH_1.default.NOT_KEYED_COMMAND,
    IS_READ_ONLY: SEARCH_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      SEARCH_1.default.parseCommand(...args);
      args[0].push("NOCONTENT");
    },
    transformReply: {
      2: (reply) => {
        return {
          total: reply[0],
          documents: reply.slice(1)
        };
      },
      3: undefined
    },
    unstableResp3: true
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/SPELLCHECK.js
var require_SPELLCHECK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var default_1 = require_default();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.SPELLCHECK", index, query);
      if (options?.DISTANCE) {
        parser.push("DISTANCE", options.DISTANCE.toString());
      }
      if (options?.TERMS) {
        if (Array.isArray(options.TERMS)) {
          for (const term of options.TERMS) {
            parseTerms(parser, term);
          }
        } else {
          parseTerms(parser, options.TERMS);
        }
      }
      if (options?.DIALECT) {
        parser.push("DIALECT", options.DIALECT.toString());
      } else {
        parser.push("DIALECT", default_1.DEFAULT_DIALECT);
      }
    },
    transformReply: {
      2: (rawReply) => {
        return rawReply.map(([, term, suggestions]) => ({
          term,
          suggestions: suggestions.map(([score, suggestion]) => ({
            score: Number(score),
            suggestion
          }))
        }));
      },
      3: undefined
    },
    unstableResp3: true
  };
  function parseTerms(parser, { mode, dictionary }) {
    parser.push("TERMS", mode, dictionary);
  }
});

// ../../node_modules/@redis/search/dist/lib/commands/SUGADD.js
var require_SUGADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, string, score, options) {
      parser.push("FT.SUGADD");
      parser.pushKey(key);
      parser.push(string, score.toString());
      if (options?.INCR) {
        parser.push("INCR");
      }
      if (options?.PAYLOAD) {
        parser.push("PAYLOAD", options.PAYLOAD);
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/SUGDEL.js
var require_SUGDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, string) {
      parser.push("FT.SUGDEL");
      parser.pushKey(key);
      parser.push(string);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/SUGGET.js
var require_SUGGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, prefix, options) {
      parser.push("FT.SUGGET");
      parser.pushKey(key);
      parser.push(prefix);
      if (options?.FUZZY) {
        parser.push("FUZZY");
      }
      if (options?.MAX !== undefined) {
        parser.push("MAX", options.MAX.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/SUGGET_WITHPAYLOADS.js
var require_SUGGET_WITHPAYLOADS = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var SUGGET_1 = __importDefault(require_SUGGET());
  exports.default = {
    IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      SUGGET_1.default.parseCommand(...args);
      args[0].push("WITHPAYLOADS");
    },
    transformReply(reply) {
      if ((0, generic_transformers_1.isNullReply)(reply))
        return null;
      const transformedReply = new Array(reply.length / 2);
      let replyIndex = 0, arrIndex = 0;
      while (replyIndex < reply.length) {
        transformedReply[arrIndex++] = {
          suggestion: reply[replyIndex++],
          payload: reply[replyIndex++]
        };
      }
      return transformedReply;
    }
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/SUGGET_WITHSCORES_WITHPAYLOADS.js
var require_SUGGET_WITHSCORES_WITHPAYLOADS = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var SUGGET_1 = __importDefault(require_SUGGET());
  exports.default = {
    IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      SUGGET_1.default.parseCommand(...args);
      args[0].push("WITHSCORES", "WITHPAYLOADS");
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        if ((0, generic_transformers_1.isNullReply)(reply))
          return null;
        const transformedReply = new Array(reply.length / 3);
        let replyIndex = 0, arrIndex = 0;
        while (replyIndex < reply.length) {
          transformedReply[arrIndex++] = {
            suggestion: reply[replyIndex++],
            score: generic_transformers_1.transformDoubleReply[2](reply[replyIndex++], preserve, typeMapping),
            payload: reply[replyIndex++]
          };
        }
        return transformedReply;
      },
      3: (reply) => {
        if ((0, generic_transformers_1.isNullReply)(reply))
          return null;
        const transformedReply = new Array(reply.length / 3);
        let replyIndex = 0, arrIndex = 0;
        while (replyIndex < reply.length) {
          transformedReply[arrIndex++] = {
            suggestion: reply[replyIndex++],
            score: reply[replyIndex++],
            payload: reply[replyIndex++]
          };
        }
        return transformedReply;
      }
    }
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/SUGGET_WITHSCORES.js
var require_SUGGET_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var SUGGET_1 = __importDefault(require_SUGGET());
  exports.default = {
    IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      SUGGET_1.default.parseCommand(...args);
      args[0].push("WITHSCORES");
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        if ((0, generic_transformers_1.isNullReply)(reply))
          return null;
        const transformedReply = new Array(reply.length / 2);
        let replyIndex = 0, arrIndex = 0;
        while (replyIndex < reply.length) {
          transformedReply[arrIndex++] = {
            suggestion: reply[replyIndex++],
            score: generic_transformers_1.transformDoubleReply[2](reply[replyIndex++], preserve, typeMapping)
          };
        }
        return transformedReply;
      },
      3: (reply) => {
        if ((0, generic_transformers_1.isNullReply)(reply))
          return null;
        const transformedReply = new Array(reply.length / 2);
        let replyIndex = 0, arrIndex = 0;
        while (replyIndex < reply.length) {
          transformedReply[arrIndex++] = {
            suggestion: reply[replyIndex++],
            score: reply[replyIndex++]
          };
        }
        return transformedReply;
      }
    }
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/SUGLEN.js
var require_SUGLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("FT.SUGLEN", key);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/SYNDUMP.js
var require_SYNDUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index) {
      parser.push("FT.SYNDUMP", index);
    },
    transformReply: {
      2: (reply) => {
        const result = {};
        let i = 0;
        while (i < reply.length) {
          const key = reply[i++].toString(), value = reply[i++];
          result[key] = value;
        }
        return result;
      },
      3: undefined
    }
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/SYNUPDATE.js
var require_SYNUPDATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, groupId, terms, options) {
      parser.push("FT.SYNUPDATE", index, groupId);
      if (options?.SKIPINITIALSCAN) {
        parser.push("SKIPINITIALSCAN");
      }
      parser.pushVariadic(terms);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/TAGVALS.js
var require_TAGVALS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, fieldName) {
      parser.push("FT.TAGVALS", index, fieldName);
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// ../../node_modules/@redis/search/dist/lib/commands/index.js
var require_commands5 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var _LIST_1 = __importDefault(require__LIST());
  var ALTER_1 = __importDefault(require_ALTER());
  var AGGREGATE_WITHCURSOR_1 = __importDefault(require_AGGREGATE_WITHCURSOR());
  var AGGREGATE_1 = __importDefault(require_AGGREGATE());
  var ALIASADD_1 = __importDefault(require_ALIASADD());
  var ALIASDEL_1 = __importDefault(require_ALIASDEL());
  var ALIASUPDATE_1 = __importDefault(require_ALIASUPDATE());
  var CONFIG_GET_1 = __importDefault(require_CONFIG_GET2());
  var CONFIG_SET_1 = __importDefault(require_CONFIG_SET2());
  var CREATE_1 = __importDefault(require_CREATE2());
  var CURSOR_DEL_1 = __importDefault(require_CURSOR_DEL());
  var CURSOR_READ_1 = __importDefault(require_CURSOR_READ());
  var DICTADD_1 = __importDefault(require_DICTADD());
  var DICTDEL_1 = __importDefault(require_DICTDEL());
  var DICTDUMP_1 = __importDefault(require_DICTDUMP());
  var DROPINDEX_1 = __importDefault(require_DROPINDEX());
  var EXPLAIN_1 = __importDefault(require_EXPLAIN());
  var EXPLAINCLI_1 = __importDefault(require_EXPLAINCLI());
  var INFO_1 = __importDefault(require_INFO7());
  var PROFILE_SEARCH_1 = __importDefault(require_PROFILE_SEARCH());
  var PROFILE_AGGREGATE_1 = __importDefault(require_PROFILE_AGGREGATE());
  var SEARCH_NOCONTENT_1 = __importDefault(require_SEARCH_NOCONTENT());
  var SEARCH_1 = __importDefault(require_SEARCH());
  var SPELLCHECK_1 = __importDefault(require_SPELLCHECK());
  var SUGADD_1 = __importDefault(require_SUGADD());
  var SUGDEL_1 = __importDefault(require_SUGDEL());
  var SUGGET_WITHPAYLOADS_1 = __importDefault(require_SUGGET_WITHPAYLOADS());
  var SUGGET_WITHSCORES_WITHPAYLOADS_1 = __importDefault(require_SUGGET_WITHSCORES_WITHPAYLOADS());
  var SUGGET_WITHSCORES_1 = __importDefault(require_SUGGET_WITHSCORES());
  var SUGGET_1 = __importDefault(require_SUGGET());
  var SUGLEN_1 = __importDefault(require_SUGLEN());
  var SYNDUMP_1 = __importDefault(require_SYNDUMP());
  var SYNUPDATE_1 = __importDefault(require_SYNUPDATE());
  var TAGVALS_1 = __importDefault(require_TAGVALS());
  exports.default = {
    _LIST: _LIST_1.default,
    _list: _LIST_1.default,
    ALTER: ALTER_1.default,
    alter: ALTER_1.default,
    AGGREGATE_WITHCURSOR: AGGREGATE_WITHCURSOR_1.default,
    aggregateWithCursor: AGGREGATE_WITHCURSOR_1.default,
    AGGREGATE: AGGREGATE_1.default,
    aggregate: AGGREGATE_1.default,
    ALIASADD: ALIASADD_1.default,
    aliasAdd: ALIASADD_1.default,
    ALIASDEL: ALIASDEL_1.default,
    aliasDel: ALIASDEL_1.default,
    ALIASUPDATE: ALIASUPDATE_1.default,
    aliasUpdate: ALIASUPDATE_1.default,
    CONFIG_GET: CONFIG_GET_1.default,
    configGet: CONFIG_GET_1.default,
    CONFIG_SET: CONFIG_SET_1.default,
    configSet: CONFIG_SET_1.default,
    CREATE: CREATE_1.default,
    create: CREATE_1.default,
    CURSOR_DEL: CURSOR_DEL_1.default,
    cursorDel: CURSOR_DEL_1.default,
    CURSOR_READ: CURSOR_READ_1.default,
    cursorRead: CURSOR_READ_1.default,
    DICTADD: DICTADD_1.default,
    dictAdd: DICTADD_1.default,
    DICTDEL: DICTDEL_1.default,
    dictDel: DICTDEL_1.default,
    DICTDUMP: DICTDUMP_1.default,
    dictDump: DICTDUMP_1.default,
    DROPINDEX: DROPINDEX_1.default,
    dropIndex: DROPINDEX_1.default,
    EXPLAIN: EXPLAIN_1.default,
    explain: EXPLAIN_1.default,
    EXPLAINCLI: EXPLAINCLI_1.default,
    explainCli: EXPLAINCLI_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    PROFILESEARCH: PROFILE_SEARCH_1.default,
    profileSearch: PROFILE_SEARCH_1.default,
    PROFILEAGGREGATE: PROFILE_AGGREGATE_1.default,
    profileAggregate: PROFILE_AGGREGATE_1.default,
    SEARCH_NOCONTENT: SEARCH_NOCONTENT_1.default,
    searchNoContent: SEARCH_NOCONTENT_1.default,
    SEARCH: SEARCH_1.default,
    search: SEARCH_1.default,
    SPELLCHECK: SPELLCHECK_1.default,
    spellCheck: SPELLCHECK_1.default,
    SUGADD: SUGADD_1.default,
    sugAdd: SUGADD_1.default,
    SUGDEL: SUGDEL_1.default,
    sugDel: SUGDEL_1.default,
    SUGGET_WITHPAYLOADS: SUGGET_WITHPAYLOADS_1.default,
    sugGetWithPayloads: SUGGET_WITHPAYLOADS_1.default,
    SUGGET_WITHSCORES_WITHPAYLOADS: SUGGET_WITHSCORES_WITHPAYLOADS_1.default,
    sugGetWithScoresWithPayloads: SUGGET_WITHSCORES_WITHPAYLOADS_1.default,
    SUGGET_WITHSCORES: SUGGET_WITHSCORES_1.default,
    sugGetWithScores: SUGGET_WITHSCORES_1.default,
    SUGGET: SUGGET_1.default,
    sugGet: SUGGET_1.default,
    SUGLEN: SUGLEN_1.default,
    sugLen: SUGLEN_1.default,
    SYNDUMP: SYNDUMP_1.default,
    synDump: SYNDUMP_1.default,
    SYNUPDATE: SYNUPDATE_1.default,
    synUpdate: SYNUPDATE_1.default,
    TAGVALS: TAGVALS_1.default,
    tagVals: TAGVALS_1.default
  };
});

// ../../node_modules/@redis/search/dist/lib/index.js
var require_lib4 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FT_AGGREGATE_STEPS = exports.FT_AGGREGATE_GROUP_BY_REDUCERS = exports.SCHEMA_VECTOR_FIELD_ALGORITHM = exports.SCHEMA_TEXT_FIELD_PHONETIC = exports.SCHEMA_FIELD_TYPE = exports.REDISEARCH_LANGUAGE = exports.default = undefined;
  var commands_1 = require_commands5();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return __importDefault(commands_1).default;
  } });
  var CREATE_1 = require_CREATE2();
  Object.defineProperty(exports, "REDISEARCH_LANGUAGE", { enumerable: true, get: function() {
    return CREATE_1.REDISEARCH_LANGUAGE;
  } });
  Object.defineProperty(exports, "SCHEMA_FIELD_TYPE", { enumerable: true, get: function() {
    return CREATE_1.SCHEMA_FIELD_TYPE;
  } });
  Object.defineProperty(exports, "SCHEMA_TEXT_FIELD_PHONETIC", { enumerable: true, get: function() {
    return CREATE_1.SCHEMA_TEXT_FIELD_PHONETIC;
  } });
  Object.defineProperty(exports, "SCHEMA_VECTOR_FIELD_ALGORITHM", { enumerable: true, get: function() {
    return CREATE_1.SCHEMA_VECTOR_FIELD_ALGORITHM;
  } });
  var AGGREGATE_1 = require_AGGREGATE();
  Object.defineProperty(exports, "FT_AGGREGATE_GROUP_BY_REDUCERS", { enumerable: true, get: function() {
    return AGGREGATE_1.FT_AGGREGATE_GROUP_BY_REDUCERS;
  } });
  Object.defineProperty(exports, "FT_AGGREGATE_STEPS", { enumerable: true, get: function() {
    return AGGREGATE_1.FT_AGGREGATE_STEPS;
  } });
});

// ../../node_modules/@redis/time-series/dist/lib/commands/helpers.js
var require_helpers2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRESP2LabelsWithSources = exports.transformRESP2Labels = exports.parseSelectedLabelsArguments = exports.resp3MapToValue = exports.resp2MapToValue = exports.transformSamplesReply = exports.transformSampleReply = exports.parseLabelsArgument = exports.transformTimestampArgument = exports.parseDuplicatePolicy = exports.TIME_SERIES_DUPLICATE_POLICIES = exports.parseChunkSizeArgument = exports.parseEncodingArgument = exports.TIME_SERIES_ENCODING = exports.parseRetentionArgument = exports.parseIgnoreArgument = undefined;
  var client_1 = require_dist();
  function parseIgnoreArgument(parser, ignore) {
    if (ignore !== undefined) {
      parser.push("IGNORE", ignore.maxTimeDiff.toString(), ignore.maxValDiff.toString());
    }
  }
  exports.parseIgnoreArgument = parseIgnoreArgument;
  function parseRetentionArgument(parser, retention) {
    if (retention !== undefined) {
      parser.push("RETENTION", retention.toString());
    }
  }
  exports.parseRetentionArgument = parseRetentionArgument;
  exports.TIME_SERIES_ENCODING = {
    COMPRESSED: "COMPRESSED",
    UNCOMPRESSED: "UNCOMPRESSED"
  };
  function parseEncodingArgument(parser, encoding) {
    if (encoding !== undefined) {
      parser.push("ENCODING", encoding);
    }
  }
  exports.parseEncodingArgument = parseEncodingArgument;
  function parseChunkSizeArgument(parser, chunkSize) {
    if (chunkSize !== undefined) {
      parser.push("CHUNK_SIZE", chunkSize.toString());
    }
  }
  exports.parseChunkSizeArgument = parseChunkSizeArgument;
  exports.TIME_SERIES_DUPLICATE_POLICIES = {
    BLOCK: "BLOCK",
    FIRST: "FIRST",
    LAST: "LAST",
    MIN: "MIN",
    MAX: "MAX",
    SUM: "SUM"
  };
  function parseDuplicatePolicy(parser, duplicatePolicy) {
    if (duplicatePolicy !== undefined) {
      parser.push("DUPLICATE_POLICY", duplicatePolicy);
    }
  }
  exports.parseDuplicatePolicy = parseDuplicatePolicy;
  function transformTimestampArgument(timestamp) {
    if (typeof timestamp === "string")
      return timestamp;
    return (typeof timestamp === "number" ? timestamp : timestamp.getTime()).toString();
  }
  exports.transformTimestampArgument = transformTimestampArgument;
  function parseLabelsArgument(parser, labels) {
    if (labels) {
      parser.push("LABELS");
      for (const [label, value] of Object.entries(labels)) {
        parser.push(label, value);
      }
    }
  }
  exports.parseLabelsArgument = parseLabelsArgument;
  exports.transformSampleReply = {
    2(reply) {
      const [timestamp, value] = reply;
      return {
        timestamp,
        value: Number(value)
      };
    },
    3(reply) {
      const [timestamp, value] = reply;
      return {
        timestamp,
        value
      };
    }
  };
  exports.transformSamplesReply = {
    2(reply) {
      return reply.map((sample) => exports.transformSampleReply[2](sample));
    },
    3(reply) {
      return reply.map((sample) => exports.transformSampleReply[3](sample));
    }
  };
  function resp2MapToValue(wrappedReply, parseFunc, typeMapping) {
    const reply = wrappedReply;
    switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
      case Map: {
        const ret = new Map;
        for (const wrappedTuple of reply) {
          const tuple = wrappedTuple;
          const key = tuple[0];
          ret.set(key.toString(), parseFunc(tuple));
        }
        return ret;
      }
      case Array: {
        for (const wrappedTuple of reply) {
          const tuple = wrappedTuple;
          tuple[1] = parseFunc(tuple);
        }
        return reply;
      }
      default: {
        const ret = Object.create(null);
        for (const wrappedTuple of reply) {
          const tuple = wrappedTuple;
          const key = tuple[0];
          ret[key.toString()] = parseFunc(tuple);
        }
        return ret;
      }
    }
  }
  exports.resp2MapToValue = resp2MapToValue;
  function resp3MapToValue(wrappedReply, parseFunc) {
    const reply = wrappedReply;
    if (reply instanceof Array) {
      for (let i = 1;i < reply.length; i += 2) {
        reply[i] = parseFunc(reply[i]);
      }
    } else if (reply instanceof Map) {
      for (const [key, value] of reply.entries()) {
        reply.set(key, parseFunc(value));
      }
    } else {
      for (const [key, value] of Object.entries(reply)) {
        reply[key] = parseFunc(value);
      }
    }
    return reply;
  }
  exports.resp3MapToValue = resp3MapToValue;
  function parseSelectedLabelsArguments(parser, selectedLabels) {
    parser.push("SELECTED_LABELS");
    parser.pushVariadic(selectedLabels);
  }
  exports.parseSelectedLabelsArguments = parseSelectedLabelsArguments;
  function transformRESP2Labels(labels, typeMapping) {
    const unwrappedLabels = labels;
    switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
      case Map:
        const map = new Map;
        for (const tuple of unwrappedLabels) {
          const [key, value] = tuple;
          const unwrappedKey = key;
          map.set(unwrappedKey.toString(), value);
        }
        return map;
      case Array:
        return unwrappedLabels.flat();
      case Object:
      default:
        const labelsObject = Object.create(null);
        for (const tuple of unwrappedLabels) {
          const [key, value] = tuple;
          const unwrappedKey = key;
          labelsObject[unwrappedKey.toString()] = value;
        }
        return labelsObject;
    }
  }
  exports.transformRESP2Labels = transformRESP2Labels;
  function transformRESP2LabelsWithSources(labels, typeMapping) {
    const unwrappedLabels = labels;
    const to = unwrappedLabels.length - 2;
    let transformedLabels;
    switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
      case Map:
        const map = new Map;
        for (let i = 0;i < to; i++) {
          const [key, value] = unwrappedLabels[i];
          const unwrappedKey = key;
          map.set(unwrappedKey.toString(), value);
        }
        transformedLabels = map;
        break;
      case Array:
        transformedLabels = unwrappedLabels.slice(0, to).flat();
        break;
      case Object:
      default:
        const labelsObject = Object.create(null);
        for (let i = 0;i < to; i++) {
          const [key, value] = unwrappedLabels[i];
          const unwrappedKey = key;
          labelsObject[unwrappedKey.toString()] = value;
        }
        transformedLabels = labelsObject;
        break;
    }
    const sourcesTuple = unwrappedLabels[unwrappedLabels.length - 1];
    const unwrappedSourcesTuple = sourcesTuple;
    const transformedSources = transformRESP2Sources(unwrappedSourcesTuple[1]);
    return {
      labels: transformedLabels,
      sources: transformedSources
    };
  }
  exports.transformRESP2LabelsWithSources = transformRESP2LabelsWithSources;
  function transformRESP2Sources(sourcesRaw) {
    const unwrappedSources = sourcesRaw;
    if (typeof unwrappedSources === "string") {
      return unwrappedSources.split(",");
    }
    const indexOfComma = unwrappedSources.indexOf(",");
    if (indexOfComma === -1) {
      return [unwrappedSources];
    }
    const sourcesArray = [
      unwrappedSources.subarray(0, indexOfComma)
    ];
    let previousComma = indexOfComma + 1;
    while (true) {
      const indexOf = unwrappedSources.indexOf(",", previousComma);
      if (indexOf === -1) {
        sourcesArray.push(unwrappedSources.subarray(previousComma));
        break;
      }
      const source = unwrappedSources.subarray(previousComma, indexOf);
      sourcesArray.push(source);
      previousComma = indexOf + 1;
    }
    return sourcesArray;
  }
});

// ../../node_modules/@redis/time-series/dist/lib/commands/ADD.js
var require_ADD5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, timestamp, value, options) {
      parser.push("TS.ADD");
      parser.pushKey(key);
      parser.push((0, helpers_1.transformTimestampArgument)(timestamp), value.toString());
      (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
      (0, helpers_1.parseEncodingArgument)(parser, options?.ENCODING);
      (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
      if (options?.ON_DUPLICATE) {
        parser.push("ON_DUPLICATE", options.ON_DUPLICATE);
      }
      (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
      (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/ALTER.js
var require_ALTER2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("TS.ALTER");
      parser.pushKey(key);
      (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
      (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
      (0, helpers_1.parseDuplicatePolicy)(parser, options?.DUPLICATE_POLICY);
      (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
      (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/CREATE.js
var require_CREATE3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("TS.CREATE");
      parser.pushKey(key);
      (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
      (0, helpers_1.parseEncodingArgument)(parser, options?.ENCODING);
      (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
      (0, helpers_1.parseDuplicatePolicy)(parser, options?.DUPLICATE_POLICY);
      (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
      (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/CREATERULE.js
var require_CREATERULE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TIME_SERIES_AGGREGATION_TYPE = undefined;
  exports.TIME_SERIES_AGGREGATION_TYPE = {
    AVG: "AVG",
    FIRST: "FIRST",
    LAST: "LAST",
    MIN: "MIN",
    MAX: "MAX",
    SUM: "SUM",
    RANGE: "RANGE",
    COUNT: "COUNT",
    STD_P: "STD.P",
    STD_S: "STD.S",
    VAR_P: "VAR.P",
    VAR_S: "VAR.S",
    TWA: "TWA"
  };
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, sourceKey, destinationKey, aggregationType, bucketDuration, alignTimestamp) {
      parser.push("TS.CREATERULE");
      parser.pushKeys([sourceKey, destinationKey]);
      parser.push("AGGREGATION", aggregationType, bucketDuration.toString());
      if (alignTimestamp !== undefined) {
        parser.push(alignTimestamp.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/INCRBY.js
var require_INCRBY4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseIncrByArguments = undefined;
  var helpers_1 = require_helpers2();
  function parseIncrByArguments(parser, key, value, options) {
    parser.pushKey(key);
    parser.push(value.toString());
    if (options?.TIMESTAMP !== undefined && options?.TIMESTAMP !== null) {
      parser.push("TIMESTAMP", (0, helpers_1.transformTimestampArgument)(options.TIMESTAMP));
    }
    (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
    if (options?.UNCOMPRESSED) {
      parser.push("UNCOMPRESSED");
    }
    (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
    (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
    (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
  }
  exports.parseIncrByArguments = parseIncrByArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("TS.INCRBY");
      parseIncrByArguments(...args);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/DECRBY.js
var require_DECRBY2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var INCRBY_1 = __importStar(require_INCRBY4());
  exports.default = {
    IS_READ_ONLY: INCRBY_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("TS.DECRBY");
      (0, INCRBY_1.parseIncrByArguments)(...args);
    },
    transformReply: INCRBY_1.default.transformReply
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/DEL.js
var require_DEL4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, fromTimestamp, toTimestamp) {
      parser.push("TS.DEL");
      parser.pushKey(key);
      parser.push((0, helpers_1.transformTimestampArgument)(fromTimestamp), (0, helpers_1.transformTimestampArgument)(toTimestamp));
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/DELETERULE.js
var require_DELETERULE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, sourceKey, destinationKey) {
      parser.push("TS.DELETERULE");
      parser.pushKeys([sourceKey, destinationKey]);
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/GET.js
var require_GET3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("TS.GET");
      parser.pushKey(key);
      if (options?.LATEST) {
        parser.push("LATEST");
      }
    },
    transformReply: {
      2(reply) {
        return reply.length === 0 ? null : {
          timestamp: reply[0],
          value: Number(reply[1])
        };
      },
      3(reply) {
        return reply.length === 0 ? null : {
          timestamp: reply[0],
          value: reply[1]
        };
      }
    }
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/INFO.js
var require_INFO8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TS.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        const ret = {};
        for (let i = 0;i < reply.length; i += 2) {
          const key = reply[i].toString();
          switch (key) {
            case "totalSamples":
            case "memoryUsage":
            case "firstTimestamp":
            case "lastTimestamp":
            case "retentionTime":
            case "chunkCount":
            case "chunkSize":
            case "chunkType":
            case "duplicatePolicy":
            case "sourceKey":
            case "ignoreMaxTimeDiff":
              ret[key] = reply[i + 1];
              break;
            case "labels":
              ret[key] = reply[i + 1].map(([name, value]) => ({
                name,
                value
              }));
              break;
            case "rules":
              ret[key] = reply[i + 1].map(([key2, timeBucket, aggregationType]) => ({
                key: key2,
                timeBucket,
                aggregationType
              }));
              break;
            case "ignoreMaxValDiff":
              ret[key] = generic_transformers_1.transformDoubleReply[2](reply[27], undefined, typeMapping);
              break;
          }
        }
        return ret;
      },
      3: undefined
    },
    unstableResp3: true
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/INFO_DEBUG.js
var require_INFO_DEBUG = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var INFO_1 = __importDefault(require_INFO8());
  exports.default = {
    IS_READ_ONLY: INFO_1.default.IS_READ_ONLY,
    parseCommand(parser, key) {
      INFO_1.default.parseCommand(parser, key);
      parser.push("DEBUG");
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        const ret = INFO_1.default.transformReply[2](reply, _, typeMapping);
        for (let i = 0;i < reply.length; i += 2) {
          const key = reply[i].toString();
          switch (key) {
            case "keySelfName": {
              ret[key] = reply[i + 1];
              break;
            }
            case "Chunks": {
              ret["chunks"] = reply[i + 1].map((chunk) => ({
                startTimestamp: chunk[1],
                endTimestamp: chunk[3],
                samples: chunk[5],
                size: chunk[7],
                bytesPerSample: chunk[9]
              }));
              break;
            }
          }
        }
        return ret;
      },
      3: undefined
    },
    unstableResp3: true
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MADD.js
var require_MADD2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, toAdd) {
      parser.push("TS.MADD");
      for (const { key, timestamp, value } of toAdd) {
        parser.pushKey(key);
        parser.push((0, helpers_1.transformTimestampArgument)(timestamp), value.toString());
      }
    },
    transformReply: undefined
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MGET.js
var require_MGET3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseFilterArgument = exports.parseLatestArgument = undefined;
  var helpers_1 = require_helpers2();
  function parseLatestArgument(parser, latest) {
    if (latest) {
      parser.push("LATEST");
    }
  }
  exports.parseLatestArgument = parseLatestArgument;
  function parseFilterArgument(parser, filter2) {
    parser.push("FILTER");
    parser.pushVariadic(filter2);
  }
  exports.parseFilterArgument = parseFilterArgument;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, filter2, options) {
      parser.push("TS.MGET");
      parseLatestArgument(parser, options?.LATEST);
      parseFilterArgument(parser, filter2);
    },
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([, , sample]) => {
          return {
            sample: helpers_1.transformSampleReply[2](sample)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([, sample]) => {
          return {
            sample: helpers_1.transformSampleReply[3](sample)
          };
        });
      }
    }
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MGET_WITHLABELS.js
var require_MGET_WITHLABELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTransformMGetLabelsReply = undefined;
  var MGET_1 = require_MGET3();
  var helpers_1 = require_helpers2();
  function createTransformMGetLabelsReply() {
    return {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([, labels, sample]) => {
          return {
            labels: (0, helpers_1.transformRESP2Labels)(labels),
            sample: helpers_1.transformSampleReply[2](sample)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([labels, sample]) => {
          return {
            labels,
            sample: helpers_1.transformSampleReply[3](sample)
          };
        });
      }
    };
  }
  exports.createTransformMGetLabelsReply = createTransformMGetLabelsReply;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, filter2, options) {
      parser.push("TS.MGET");
      (0, MGET_1.parseLatestArgument)(parser, options?.LATEST);
      parser.push("WITHLABELS");
      (0, MGET_1.parseFilterArgument)(parser, filter2);
    },
    transformReply: createTransformMGetLabelsReply()
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MGET_SELECTED_LABELS.js
var require_MGET_SELECTED_LABELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var MGET_1 = require_MGET3();
  var helpers_1 = require_helpers2();
  var MGET_WITHLABELS_1 = require_MGET_WITHLABELS();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, filter2, selectedLabels, options) {
      parser.push("TS.MGET");
      (0, MGET_1.parseLatestArgument)(parser, options?.LATEST);
      (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
      (0, MGET_1.parseFilterArgument)(parser, filter2);
    },
    transformReply: (0, MGET_WITHLABELS_1.createTransformMGetLabelsReply)()
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/RANGE.js
var require_RANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRangeArguments = exports.parseRangeArguments = exports.TIME_SERIES_BUCKET_TIMESTAMP = undefined;
  var helpers_1 = require_helpers2();
  exports.TIME_SERIES_BUCKET_TIMESTAMP = {
    LOW: "-",
    MIDDLE: "~",
    END: "+"
  };
  function parseRangeArguments(parser, fromTimestamp, toTimestamp, options) {
    parser.push((0, helpers_1.transformTimestampArgument)(fromTimestamp), (0, helpers_1.transformTimestampArgument)(toTimestamp));
    if (options?.LATEST) {
      parser.push("LATEST");
    }
    if (options?.FILTER_BY_TS) {
      parser.push("FILTER_BY_TS");
      for (const timestamp of options.FILTER_BY_TS) {
        parser.push((0, helpers_1.transformTimestampArgument)(timestamp));
      }
    }
    if (options?.FILTER_BY_VALUE) {
      parser.push("FILTER_BY_VALUE", options.FILTER_BY_VALUE.min.toString(), options.FILTER_BY_VALUE.max.toString());
    }
    if (options?.COUNT !== undefined) {
      parser.push("COUNT", options.COUNT.toString());
    }
    if (options?.AGGREGATION) {
      if (options?.ALIGN !== undefined) {
        parser.push("ALIGN", (0, helpers_1.transformTimestampArgument)(options.ALIGN));
      }
      parser.push("AGGREGATION", options.AGGREGATION.type, (0, helpers_1.transformTimestampArgument)(options.AGGREGATION.timeBucket));
      if (options.AGGREGATION.BUCKETTIMESTAMP) {
        parser.push("BUCKETTIMESTAMP", options.AGGREGATION.BUCKETTIMESTAMP);
      }
      if (options.AGGREGATION.EMPTY) {
        parser.push("EMPTY");
      }
    }
  }
  exports.parseRangeArguments = parseRangeArguments;
  function transformRangeArguments(parser, key, fromTimestamp, toTimestamp, options) {
    parser.pushKey(key);
    parseRangeArguments(parser, fromTimestamp, toTimestamp, options);
  }
  exports.transformRangeArguments = transformRangeArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("TS.RANGE");
      transformRangeArguments(...args);
    },
    transformReply: {
      2(reply) {
        return helpers_1.transformSamplesReply[2](reply);
      },
      3(reply) {
        return helpers_1.transformSamplesReply[3](reply);
      }
    }
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MRANGE_GROUPBY.js
var require_MRANGE_GROUPBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extractResp3MRangeSources = exports.createTransformMRangeGroupByArguments = exports.parseGroupByArguments = exports.TIME_SERIES_REDUCERS = undefined;
  var helpers_1 = require_helpers2();
  var RANGE_1 = require_RANGE();
  var MGET_1 = require_MGET3();
  exports.TIME_SERIES_REDUCERS = {
    AVG: "AVG",
    SUM: "SUM",
    MIN: "MIN",
    MAX: "MAX",
    RANGE: "RANGE",
    COUNT: "COUNT",
    STD_P: "STD.P",
    STD_S: "STD.S",
    VAR_P: "VAR.P",
    VAR_S: "VAR.S"
  };
  function parseGroupByArguments(parser, groupBy) {
    parser.push("GROUPBY", groupBy.label, "REDUCE", groupBy.REDUCE);
  }
  exports.parseGroupByArguments = parseGroupByArguments;
  function createTransformMRangeGroupByArguments(command) {
    return (parser, fromTimestamp, toTimestamp, filter2, groupBy, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      (0, MGET_1.parseFilterArgument)(parser, filter2);
      parseGroupByArguments(parser, groupBy);
    };
  }
  exports.createTransformMRangeGroupByArguments = createTransformMRangeGroupByArguments;
  function extractResp3MRangeSources(raw2) {
    const unwrappedMetadata2 = raw2;
    if (unwrappedMetadata2 instanceof Map) {
      return unwrappedMetadata2.get("sources");
    } else if (unwrappedMetadata2 instanceof Array) {
      return unwrappedMetadata2[1];
    } else {
      return unwrappedMetadata2.sources;
    }
  }
  exports.extractResp3MRangeSources = extractResp3MRangeSources;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand: createTransformMRangeGroupByArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key, _labels, samples]) => {
          return {
            samples: helpers_1.transformSamplesReply[2](samples)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([_labels, _metadata1, metadata2, samples]) => {
          return {
            sources: extractResp3MRangeSources(metadata2),
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MRANGE_SELECTED_LABELS.js
var require_MRANGE_SELECTED_LABELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTransformMRangeSelectedLabelsArguments = undefined;
  var helpers_1 = require_helpers2();
  var RANGE_1 = require_RANGE();
  var MGET_1 = require_MGET3();
  function createTransformMRangeSelectedLabelsArguments(command) {
    return (parser, fromTimestamp, toTimestamp, selectedLabels, filter2, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
      (0, MGET_1.parseFilterArgument)(parser, filter2);
    };
  }
  exports.createTransformMRangeSelectedLabelsArguments = createTransformMRangeSelectedLabelsArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand: createTransformMRangeSelectedLabelsArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key, labels, samples]) => {
          return {
            labels: (0, helpers_1.transformRESP2Labels)(labels, typeMapping),
            samples: helpers_1.transformSamplesReply[2](samples)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([_key, labels, samples]) => {
          return {
            labels,
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MRANGE_SELECTED_LABELS_GROUPBY.js
var require_MRANGE_SELECTED_LABELS_GROUPBY = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createMRangeSelectedLabelsGroupByTransformArguments = undefined;
  var helpers_1 = require_helpers2();
  var RANGE_1 = require_RANGE();
  var MRANGE_GROUPBY_1 = require_MRANGE_GROUPBY();
  var MGET_1 = require_MGET3();
  var MRANGE_SELECTED_LABELS_1 = __importDefault(require_MRANGE_SELECTED_LABELS());
  function createMRangeSelectedLabelsGroupByTransformArguments(command) {
    return (parser, fromTimestamp, toTimestamp, selectedLabels, filter2, groupBy, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
      (0, MGET_1.parseFilterArgument)(parser, filter2);
      (0, MRANGE_GROUPBY_1.parseGroupByArguments)(parser, groupBy);
    };
  }
  exports.createMRangeSelectedLabelsGroupByTransformArguments = createMRangeSelectedLabelsGroupByTransformArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand: createMRangeSelectedLabelsGroupByTransformArguments("TS.MRANGE"),
    transformReply: {
      2: MRANGE_SELECTED_LABELS_1.default.transformReply[2],
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, metadata2, samples]) => {
          return {
            labels,
            sources: (0, MRANGE_GROUPBY_1.extractResp3MRangeSources)(metadata2),
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MRANGE_WITHLABELS_GROUPBY.js
var require_MRANGE_WITHLABELS_GROUPBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createMRangeWithLabelsGroupByTransformArguments = undefined;
  var helpers_1 = require_helpers2();
  var RANGE_1 = require_RANGE();
  var MRANGE_GROUPBY_1 = require_MRANGE_GROUPBY();
  var MGET_1 = require_MGET3();
  function createMRangeWithLabelsGroupByTransformArguments(command) {
    return (parser, fromTimestamp, toTimestamp, filter2, groupBy, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      parser.push("WITHLABELS");
      (0, MGET_1.parseFilterArgument)(parser, filter2);
      (0, MRANGE_GROUPBY_1.parseGroupByArguments)(parser, groupBy);
    };
  }
  exports.createMRangeWithLabelsGroupByTransformArguments = createMRangeWithLabelsGroupByTransformArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand: createMRangeWithLabelsGroupByTransformArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key, labels, samples]) => {
          const transformed = (0, helpers_1.transformRESP2LabelsWithSources)(labels);
          return {
            labels: transformed.labels,
            sources: transformed.sources,
            samples: helpers_1.transformSamplesReply[2](samples)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, metadata2, samples]) => {
          return {
            labels,
            sources: (0, MRANGE_GROUPBY_1.extractResp3MRangeSources)(metadata2),
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MRANGE_WITHLABELS.js
var require_MRANGE_WITHLABELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTransformMRangeWithLabelsArguments = undefined;
  var helpers_1 = require_helpers2();
  var RANGE_1 = require_RANGE();
  var MGET_1 = require_MGET3();
  function createTransformMRangeWithLabelsArguments(command) {
    return (parser, fromTimestamp, toTimestamp, filter2, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      parser.push("WITHLABELS");
      (0, MGET_1.parseFilterArgument)(parser, filter2);
    };
  }
  exports.createTransformMRangeWithLabelsArguments = createTransformMRangeWithLabelsArguments;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand: createTransformMRangeWithLabelsArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key, labels, samples]) => {
          const unwrappedLabels = labels;
          const labelsObject = Object.create(null);
          for (const tuple of unwrappedLabels) {
            const [key, value] = tuple;
            const unwrappedKey = key;
            labelsObject[unwrappedKey.toString()] = value;
          }
          return {
            labels: labelsObject,
            samples: helpers_1.transformSamplesReply[2](samples)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, samples]) => {
          return {
            labels,
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MRANGE.js
var require_MRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTransformMRangeArguments = undefined;
  var helpers_1 = require_helpers2();
  var RANGE_1 = require_RANGE();
  var MGET_1 = require_MGET3();
  function createTransformMRangeArguments(command) {
    return (parser, fromTimestamp, toTimestamp, filter2, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      (0, MGET_1.parseFilterArgument)(parser, filter2);
    };
  }
  exports.createTransformMRangeArguments = createTransformMRangeArguments;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand: createTransformMRangeArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key, _labels, samples]) => {
          return helpers_1.transformSamplesReply[2](samples);
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([_labels, _metadata, samples]) => {
          return helpers_1.transformSamplesReply[3](samples);
        });
      }
    }
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_GROUPBY.js
var require_MREVRANGE_GROUPBY = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_GROUPBY_1 = __importStar(require_MRANGE_GROUPBY());
  exports.default = {
    IS_READ_ONLY: MRANGE_GROUPBY_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_GROUPBY_1.createTransformMRangeGroupByArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_GROUPBY_1.default.transformReply
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_SELECTED_LABELS_GROUPBY.js
var require_MREVRANGE_SELECTED_LABELS_GROUPBY = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_SELECTED_LABELS_GROUPBY_1 = __importStar(require_MRANGE_SELECTED_LABELS_GROUPBY());
  exports.default = {
    IS_READ_ONLY: MRANGE_SELECTED_LABELS_GROUPBY_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_SELECTED_LABELS_GROUPBY_1.createMRangeSelectedLabelsGroupByTransformArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_SELECTED_LABELS_GROUPBY_1.default.transformReply
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_SELECTED_LABELS.js
var require_MREVRANGE_SELECTED_LABELS = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_SELECTED_LABELS_1 = __importStar(require_MRANGE_SELECTED_LABELS());
  exports.default = {
    IS_READ_ONLY: MRANGE_SELECTED_LABELS_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_SELECTED_LABELS_1.createTransformMRangeSelectedLabelsArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_SELECTED_LABELS_1.default.transformReply
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_WITHLABELS_GROUPBY.js
var require_MREVRANGE_WITHLABELS_GROUPBY = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_WITHLABELS_GROUPBY_1 = __importStar(require_MRANGE_WITHLABELS_GROUPBY());
  exports.default = {
    IS_READ_ONLY: MRANGE_WITHLABELS_GROUPBY_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_WITHLABELS_GROUPBY_1.createMRangeWithLabelsGroupByTransformArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_WITHLABELS_GROUPBY_1.default.transformReply
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_WITHLABELS.js
var require_MREVRANGE_WITHLABELS = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_WITHLABELS_1 = __importStar(require_MRANGE_WITHLABELS());
  exports.default = {
    NOT_KEYED_COMMAND: MRANGE_WITHLABELS_1.default.NOT_KEYED_COMMAND,
    IS_READ_ONLY: MRANGE_WITHLABELS_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_WITHLABELS_1.createTransformMRangeWithLabelsArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_WITHLABELS_1.default.transformReply
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/MREVRANGE.js
var require_MREVRANGE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_1 = __importStar(require_MRANGE());
  exports.default = {
    NOT_KEYED_COMMAND: MRANGE_1.default.NOT_KEYED_COMMAND,
    IS_READ_ONLY: MRANGE_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_1.createTransformMRangeArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_1.default.transformReply
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/QUERYINDEX.js
var require_QUERYINDEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, filter2) {
      parser.push("TS.QUERYINDEX");
      parser.pushVariadic(filter2);
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/REVRANGE.js
var require_REVRANGE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var RANGE_1 = __importStar(require_RANGE());
  exports.default = {
    IS_READ_ONLY: RANGE_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("TS.REVRANGE");
      (0, RANGE_1.transformRangeArguments)(...args);
    },
    transformReply: RANGE_1.default.transformReply
  };
});

// ../../node_modules/@redis/time-series/dist/lib/commands/index.js
var require_commands6 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD5());
  var ALTER_1 = __importDefault(require_ALTER2());
  var CREATE_1 = __importDefault(require_CREATE3());
  var CREATERULE_1 = __importDefault(require_CREATERULE());
  var DECRBY_1 = __importDefault(require_DECRBY2());
  var DEL_1 = __importDefault(require_DEL4());
  var DELETERULE_1 = __importDefault(require_DELETERULE());
  var GET_1 = __importDefault(require_GET3());
  var INCRBY_1 = __importDefault(require_INCRBY4());
  var INFO_DEBUG_1 = __importDefault(require_INFO_DEBUG());
  var INFO_1 = __importDefault(require_INFO8());
  var MADD_1 = __importDefault(require_MADD2());
  var MGET_SELECTED_LABELS_1 = __importDefault(require_MGET_SELECTED_LABELS());
  var MGET_WITHLABELS_1 = __importDefault(require_MGET_WITHLABELS());
  var MGET_1 = __importDefault(require_MGET3());
  var MRANGE_GROUPBY_1 = __importDefault(require_MRANGE_GROUPBY());
  var MRANGE_SELECTED_LABELS_GROUPBY_1 = __importDefault(require_MRANGE_SELECTED_LABELS_GROUPBY());
  var MRANGE_SELECTED_LABELS_1 = __importDefault(require_MRANGE_SELECTED_LABELS());
  var MRANGE_WITHLABELS_GROUPBY_1 = __importDefault(require_MRANGE_WITHLABELS_GROUPBY());
  var MRANGE_WITHLABELS_1 = __importDefault(require_MRANGE_WITHLABELS());
  var MRANGE_1 = __importDefault(require_MRANGE());
  var MREVRANGE_GROUPBY_1 = __importDefault(require_MREVRANGE_GROUPBY());
  var MREVRANGE_SELECTED_LABELS_GROUPBY_1 = __importDefault(require_MREVRANGE_SELECTED_LABELS_GROUPBY());
  var MREVRANGE_SELECTED_LABELS_1 = __importDefault(require_MREVRANGE_SELECTED_LABELS());
  var MREVRANGE_WITHLABELS_GROUPBY_1 = __importDefault(require_MREVRANGE_WITHLABELS_GROUPBY());
  var MREVRANGE_WITHLABELS_1 = __importDefault(require_MREVRANGE_WITHLABELS());
  var MREVRANGE_1 = __importDefault(require_MREVRANGE());
  var QUERYINDEX_1 = __importDefault(require_QUERYINDEX());
  var RANGE_1 = __importDefault(require_RANGE());
  var REVRANGE_1 = __importDefault(require_REVRANGE());
  __exportStar(require_helpers2(), exports);
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    ALTER: ALTER_1.default,
    alter: ALTER_1.default,
    CREATE: CREATE_1.default,
    create: CREATE_1.default,
    CREATERULE: CREATERULE_1.default,
    createRule: CREATERULE_1.default,
    DECRBY: DECRBY_1.default,
    decrBy: DECRBY_1.default,
    DEL: DEL_1.default,
    del: DEL_1.default,
    DELETERULE: DELETERULE_1.default,
    deleteRule: DELETERULE_1.default,
    GET: GET_1.default,
    get: GET_1.default,
    INCRBY: INCRBY_1.default,
    incrBy: INCRBY_1.default,
    INFO_DEBUG: INFO_DEBUG_1.default,
    infoDebug: INFO_DEBUG_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    MADD: MADD_1.default,
    mAdd: MADD_1.default,
    MGET_SELECTED_LABELS: MGET_SELECTED_LABELS_1.default,
    mGetSelectedLabels: MGET_SELECTED_LABELS_1.default,
    MGET_WITHLABELS: MGET_WITHLABELS_1.default,
    mGetWithLabels: MGET_WITHLABELS_1.default,
    MGET: MGET_1.default,
    mGet: MGET_1.default,
    MRANGE_GROUPBY: MRANGE_GROUPBY_1.default,
    mRangeGroupBy: MRANGE_GROUPBY_1.default,
    MRANGE_SELECTED_LABELS_GROUPBY: MRANGE_SELECTED_LABELS_GROUPBY_1.default,
    mRangeSelectedLabelsGroupBy: MRANGE_SELECTED_LABELS_GROUPBY_1.default,
    MRANGE_SELECTED_LABELS: MRANGE_SELECTED_LABELS_1.default,
    mRangeSelectedLabels: MRANGE_SELECTED_LABELS_1.default,
    MRANGE_WITHLABELS_GROUPBY: MRANGE_WITHLABELS_GROUPBY_1.default,
    mRangeWithLabelsGroupBy: MRANGE_WITHLABELS_GROUPBY_1.default,
    MRANGE_WITHLABELS: MRANGE_WITHLABELS_1.default,
    mRangeWithLabels: MRANGE_WITHLABELS_1.default,
    MRANGE: MRANGE_1.default,
    mRange: MRANGE_1.default,
    MREVRANGE_GROUPBY: MREVRANGE_GROUPBY_1.default,
    mRevRangeGroupBy: MREVRANGE_GROUPBY_1.default,
    MREVRANGE_SELECTED_LABELS_GROUPBY: MREVRANGE_SELECTED_LABELS_GROUPBY_1.default,
    mRevRangeSelectedLabelsGroupBy: MREVRANGE_SELECTED_LABELS_GROUPBY_1.default,
    MREVRANGE_SELECTED_LABELS: MREVRANGE_SELECTED_LABELS_1.default,
    mRevRangeSelectedLabels: MREVRANGE_SELECTED_LABELS_1.default,
    MREVRANGE_WITHLABELS_GROUPBY: MREVRANGE_WITHLABELS_GROUPBY_1.default,
    mRevRangeWithLabelsGroupBy: MREVRANGE_WITHLABELS_GROUPBY_1.default,
    MREVRANGE_WITHLABELS: MREVRANGE_WITHLABELS_1.default,
    mRevRangeWithLabels: MREVRANGE_WITHLABELS_1.default,
    MREVRANGE: MREVRANGE_1.default,
    mRevRange: MREVRANGE_1.default,
    QUERYINDEX: QUERYINDEX_1.default,
    queryIndex: QUERYINDEX_1.default,
    RANGE: RANGE_1.default,
    range: RANGE_1.default,
    REVRANGE: REVRANGE_1.default,
    revRange: REVRANGE_1.default
  };
});

// ../../node_modules/@redis/time-series/dist/lib/index.js
var require_lib5 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TIME_SERIES_REDUCERS = exports.TIME_SERIES_BUCKET_TIMESTAMP = exports.TIME_SERIES_AGGREGATION_TYPE = exports.TIME_SERIES_DUPLICATE_POLICIES = exports.TIME_SERIES_ENCODING = exports.default = undefined;
  var commands_1 = require_commands6();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return __importDefault(commands_1).default;
  } });
  Object.defineProperty(exports, "TIME_SERIES_ENCODING", { enumerable: true, get: function() {
    return commands_1.TIME_SERIES_ENCODING;
  } });
  Object.defineProperty(exports, "TIME_SERIES_DUPLICATE_POLICIES", { enumerable: true, get: function() {
    return commands_1.TIME_SERIES_DUPLICATE_POLICIES;
  } });
  var CREATERULE_1 = require_CREATERULE();
  Object.defineProperty(exports, "TIME_SERIES_AGGREGATION_TYPE", { enumerable: true, get: function() {
    return CREATERULE_1.TIME_SERIES_AGGREGATION_TYPE;
  } });
  var RANGE_1 = require_RANGE();
  Object.defineProperty(exports, "TIME_SERIES_BUCKET_TIMESTAMP", { enumerable: true, get: function() {
    return RANGE_1.TIME_SERIES_BUCKET_TIMESTAMP;
  } });
  var MRANGE_GROUPBY_1 = require_MRANGE_GROUPBY();
  Object.defineProperty(exports, "TIME_SERIES_REDUCERS", { enumerable: true, get: function() {
    return MRANGE_GROUPBY_1.TIME_SERIES_REDUCERS;
  } });
});

// ../../node_modules/redis/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createSentinel = exports.createCluster = exports.createClient = undefined;
  var client_1 = require_dist();
  var bloom_1 = __importDefault(require_lib2());
  var json_1 = __importDefault(require_lib3());
  var search_1 = __importDefault(require_lib4());
  var time_series_1 = __importDefault(require_lib5());
  __exportStar(require_dist(), exports);
  __exportStar(require_lib2(), exports);
  __exportStar(require_lib3(), exports);
  __exportStar(require_lib4(), exports);
  __exportStar(require_lib5(), exports);
  var modules = {
    ...bloom_1.default,
    json: json_1.default,
    ft: search_1.default,
    ts: time_series_1.default
  };
  function createClient(options) {
    return (0, client_1.createClient)({
      ...options,
      modules: {
        ...modules,
        ...options?.modules
      }
    });
  }
  exports.createClient = createClient;
  function createCluster(options) {
    return (0, client_1.createCluster)({
      ...options,
      modules: {
        ...modules,
        ...options?.modules
      }
    });
  }
  exports.createCluster = createCluster;
  function createSentinel(options) {
    return (0, client_1.createSentinel)({
      ...options,
      modules: {
        ...modules,
        ...options?.modules
      }
    });
  }
  exports.createSentinel = createSentinel;
});

// ../../node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// ../../node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length;i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0;i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length;i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = undefined;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(typeof setImmediate === "function", isFunction(_global.postMessage));
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

// ../../node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// ../../node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data = __toESM(require_form_data(), 1);
var FormData_default = import_form_data.default;

// ../../node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData);
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(formData, el, utils_default.isString(key) ? key.trim() : key, path, exposedHelpers);
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// ../../node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\x00"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// ../../node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// ../../node_modules/axios/lib/core/InterceptorManager.js
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
var InterceptorManager_default = InterceptorManager;

// ../../node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// ../../node_modules/axios/lib/platform/node/index.js
import crypto2 from "crypto";

// ../../node_modules/axios/lib/platform/node/classes/URLSearchParams.js
import url from "url";
var URLSearchParams_default = url.URLSearchParams;

// ../../node_modules/axios/lib/platform/node/index.js
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  const randomValues = new Uint32Array(size);
  crypto2.randomFillSync(randomValues);
  for (let i = 0;i < size; i++) {
    str += alphabet[randomValues[i] % length];
  }
  return str;
};
var node_default = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: ["http", "https", "file", "data"]
};

// ../../node_modules/axios/lib/platform/common/utils.js
var exports_utils = {};
__export(exports_utils, {
  origin: () => origin,
  navigator: () => _navigator,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasBrowserEnv: () => hasBrowserEnv
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || undefined;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// ../../node_modules/axios/lib/platform/index.js
var platform_default = {
  ...exports_utils,
  ...node_default
};

// ../../node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams, Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// ../../node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0;i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// ../../node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(isFileList2 ? { "files[]": data } : data, _FormData && new _FormData, this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": undefined
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// ../../node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split(`
`).forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// ../../node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === undefined || _rewrite === true || _rewrite === undefined && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// ../../node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });
  headers.normalize();
  return data;
}

// ../../node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// ../../node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// ../../node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default("Request failed with status code " + response.status, [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}

// ../../node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// ../../node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// ../../node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// ../../node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
var import_follow_redirects = __toESM(require_follow_redirects(), 1);
import http from "http";
import https from "https";
import util2 from "util";
import zlib from "zlib";

// ../../node_modules/axios/lib/env/data.js
var VERSION = "1.10.0";

// ../../node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}

// ../../node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match = DATA_URL_PATTERN.exec(uri);
    if (!match) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

// ../../node_modules/axios/lib/adapters/http.js
import stream3 from "stream";

// ../../node_modules/axios/lib/helpers/AxiosTransformStream.js
import stream from "stream";
var kInternals = Symbol("internals");

class AxiosTransformStream extends stream.Transform {
  constructor(options) {
    options = utils_default.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils_default.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1000 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      internals.isCaptured && this.emit("progress", internals.bytesSeen);
      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}
var AxiosTransformStream_default = AxiosTransformStream;

// ../../node_modules/axios/lib/adapters/http.js
import { EventEmitter } from "events";

// ../../node_modules/axios/lib/helpers/formDataToStream.js
import util from "util";
import { Readable } from "stream";

// ../../node_modules/axios/lib/helpers/readBlob.js
var { asyncIterator } = Symbol;
var readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
var readBlob_default = readBlob;

// ../../node_modules/axios/lib/helpers/formDataToStream.js
var BOUNDARY_ALPHABET = platform_default.ALPHABET.ALPHA_DIGIT + "-_";
var textEncoder = typeof TextEncoder === "function" ? new TextEncoder : new util.TextEncoder;
var CRLF = `\r
`;
var CRLF_BYTES = textEncoder.encode(CRLF);
var CRLF_BYTES_COUNT = 2;

class FormDataPart {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils_default.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async* encode() {
    yield this.headers;
    const { value } = this;
    if (utils_default.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob_default(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
}
var formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + platform_default.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils_default.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils_default.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
var formDataToStream_default = formDataToStream;

// ../../node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
import stream2 from "stream";

class ZlibHeaderTransformStream extends stream2.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
}
var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

// ../../node_modules/axios/lib/helpers/callbackify.js
var callbackify = (fn, reducer) => {
  return utils_default.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
var callbackify_default = callbackify;

// ../../node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== undefined ? min : 1000;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}
var speedometer_default = speedometer;

// ../../node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// ../../node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// ../../node_modules/axios/lib/adapters/http.js
var zlibOptions = {
  flush: zlib.constants.Z_SYNC_FLUSH,
  finishFlush: zlib.constants.Z_SYNC_FLUSH
};
var brotliOptions = {
  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
};
var isBrotliSupported = utils_default.isFunction(zlib.createBrotliDecompress);
var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
var isHttps = /https:?/;
var supportedProtocols = platform_default.protocols.map((protocol) => {
  return protocol + ":";
});
var flushOnFinish = (stream4, [throttled, flush]) => {
  stream4.on("end", flush).on("error", flush);
  return throttled;
};
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = import_proxy_from_env.default.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
var wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone)
        return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
var resolveFamily = ({ address, family }) => {
  if (!utils_default.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
var buildAddressEntry = (address, family) => resolveFamily(utils_default.isObject(address) ? address : { address, family });
var http_default = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let { data, lookup, family } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup) {
      const _lookup = callbackify_default(lookup, (value) => utils_default.isArray(value) ? value : [value]);
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils_default.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new EventEmitter;
    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config, req) : reason);
    }
    emitter.once("abort", reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform_default.hasBrowserEnv ? platform_default.origin : undefined);
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils_default.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = stream3.Readable.from(convertedData);
      }
      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders_default,
        config
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_BAD_REQUEST, config));
    }
    const headers = AxiosHeaders_default.from(config.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION, false);
    const { onUploadProgress, onDownloadProgress } = config;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;
    if (utils_default.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream_default(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
    } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util2.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e) {}
      }
    } else if (utils_default.isBlob(data) || utils_default.isFile(data)) {
      data.size && headers.setContentType(data.type || "application/octet-stream");
      headers.setContentLength(data.size || 0);
      data = stream3.Readable.from(readBlob_default(data));
    } else if (data && !utils_default.isStream(data)) {
      if (Buffer.isBuffer(data)) {} else if (utils_default.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils_default.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError_default("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", AxiosError_default.ERR_BAD_REQUEST, config));
      }
      headers.setContentLength(data.length, false);
      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError_default("Request body larger than maxBodyLength limit", AxiosError_default.ERR_BAD_REQUEST, config));
      }
    }
    const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
    if (utils_default.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils_default.isStream(data)) {
        data = stream3.Readable.from(data, { objectMode: false });
      }
      data = stream3.pipeline([data, new AxiosTransformStream_default({
        maxRate: utils_default.toFiniteNumber(maxUploadRate)
      })], utils_default.noop);
      onUploadProgress && data.on("progress", flushOnFinish(data, progressEventDecorator(contentLength, progressEventReducer(asyncDecorator(onUploadProgress), false, 3))));
    }
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path;
    try {
      path = buildURL(parsed.pathname + parsed.search, config.params, config.paramsSerializer).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set("Accept-Encoding", "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""), false);
    const options = {
      path,
      method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils_default.isUndefined(lookup) && (options.lookup = lookup);
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? https : http;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed)
        return;
      const streams = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream_default({
          maxRate: utils_default.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", flushOnFinish(transformStream, progressEventDecorator(responseLength, progressEventReducer(asyncDecorator(onDownloadProgress), true, 3))));
        streams.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch ((res.headers["content-encoding"] || "").toLowerCase()) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams.push(new ZlibHeaderTransformStream_default);
            streams.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams.push(zlib.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams.length > 1 ? stream3.pipeline(streams, utils_default.noop) : streams[0];
      const offListeners = stream3.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders_default(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError_default("maxContentLength size of " + config.maxContentLength + " exceeded", AxiosError_default.ERR_BAD_RESPONSE, config, lastRequest));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError_default("stream has been aborted", AxiosError_default.ERR_BAD_RESPONSE, config, lastRequest);
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed)
            return;
          reject(AxiosError_default.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils_default.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError_default.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError_default.from(err, null, config, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1000 * 60);
    });
    if (config.timeout) {
      const timeout = parseInt(config.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError_default("error trying to parse `config.timeout` to int", AxiosError_default.ERR_BAD_OPTION_VALUE, config, req));
        return;
      }
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone)
          return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = config.transitional || transitional_default;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError_default(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config, req));
        abort();
      });
    }
    if (utils_default.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort(new CanceledError_default("Request stream has been aborted", config, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

// ../../node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? ((origin2, isMSIE) => (url2) => {
  url2 = new URL(url2, platform_default.origin);
  return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
})(new URL(platform_default.origin), platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)) : () => true;

// ../../node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? {
  write(name, value, expires, path, domain, secure) {
    const cookie = [name + "=" + encodeURIComponent(value)];
    utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
    utils_default.isString(path) && cookie.push("path=" + path);
    utils_default.isString(domain) && cookie.push("domain=" + domain);
    secure === true && cookie.push("secure");
    document.cookie = cookie.join("; ");
  },
  read(name) {
    const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
    return match ? decodeURIComponent(match[3]) : null;
  },
  remove(name) {
    this.write(name, "", Date.now() - 86400000);
  }
} : {
  write() {},
  read() {
    return null;
  },
  remove() {}
};

// ../../node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(undefined, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// ../../node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set("Authorization", "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : "")));
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// ../../node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest;
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    requestData === undefined && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// ../../node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController;
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// ../../node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream4) {
  if (stream4[Symbol.asyncIterator]) {
    yield* stream4;
    return;
  }
  const reader = stream4.getReader();
  try {
    for (;; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream4, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream4, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};

// ../../node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder) => (str) => encoder.encode(str))(new TextEncoder) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream,
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response);
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length = utils_default.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var fetch_default = isFetchSupported && (async (config) => {
  let {
    url: url2,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url2, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url2, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });
    let response = await fetch(request, fetchOptions);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];
      response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
        flush && flush();
        unsubscribe && unsubscribe();
      }), options);
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request), {
        cause: err.cause || err
      });
    }
    throw AxiosError_default.from(err, err && err.code, config, request);
  }
});

// ../../node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: http_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {}
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0;i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === undefined) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build"));
      let s = length ? reasons.length > 1 ? `since :
` + reasons.map(renderReason).join(`
`) : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(`There is no suitable adapter to dispatch the request ` + s, "ERR_NOT_SUPPORT");
    }
    return adapter;
  },
  adapters: knownAdapters
};

// ../../node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(config, config.transformRequest);
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(config, config.transformResponse, response);
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// ../../node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), AxiosError_default.ERR_DEPRECATED);
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// ../../node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;

class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default,
      response: new InterceptorManager_default
    };
  }
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error;
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += `
` + stack;
          }
        } catch (e) {}
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== undefined) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== undefined) {} else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(headers.common, headers[config.method]);
    headers && utils_default.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (method) => {
      delete headers[method];
    });
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// ../../node_modules/axios/lib/cancel/CancelToken.js
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController;
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
var CancelToken_default = CancelToken;

// ../../node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// ../../node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// ../../node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// ../../node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// ../../packages/db/index.ts
var import_prisma = __toESM(require_prisma(), 1);
var prisma = new import_prisma.PrismaClient;

// ../../packages/redisstream/src/client.ts
var import_redis = __toESM(require_dist2(), 1);
var getClient = async () => {
  const redisUrl = process.env.REDIS_URL || "redis://localhost:6379";
  const redisConfig = redisUrl.includes("@") ? { url: `redis://${redisUrl}` } : { url: redisUrl };
  return await import_redis.createClient(redisConfig).on("error", (err) => console.log("Redis Client Error", err)).on("connect", () => console.log("Redis connected successfully")).connect();
};

// ../../packages/redisstream/src/index.ts
var STREAM_NAME = "betteruptime:website";
var client = await getClient();
async function xGroupRead(group_id, consumer_id) {
  const res = await client.xReadGroup(group_id, consumer_id, {
    key: STREAM_NAME,
    id: ">"
  }, {
    COUNT: 5
  });
  return res;
}
async function xAck(group_id, stream_id) {
  await client.xAck(STREAM_NAME, group_id, stream_id);
}
async function xAckBulk(group_id, data) {
  data.map(async (item) => {
    await xAck(group_id, item.id);
  });
}

// index.ts
var REGION_ID = process.env.REGION_ID || "13b23acd-e69b-43b3-a23e-48f985d56793";
var CONSUMER_ID = process.env.CONSUMER_ID || "india-1";
async function main() {
  while (true) {
    const data = await xGroupRead(REGION_ID, CONSUMER_ID);
    if (!data) {
      continue;
    }
    const worker_data = data[0].messages;
    const promise = worker_data.map(async (item) => {
      return new Promise((resolve, reject) => {
        const timeGet = item.id.slice(0, -3);
        const website_url = item.message.url;
        const website_id = item.message.id;
        const startTime = Date.now();
        axios_default.get(website_url).then(async () => {
          const endTime = Date.now();
          const response_time = endTime - startTime;
          try {
            await prisma.website_tick.create({
              data: {
                response_time_ms: response_time,
                status: "UP",
                website_id,
                region_id: REGION_ID
              }
            });
          } catch (dbError) {
            console.log(`Failed to save UP status for ${website_url}:`, dbError);
          }
          resolve();
        }).catch(async () => {
          const endTime = Date.now();
          const response_time = endTime - startTime;
          try {
            axios_default.post(`${process.env.API_URL || "http://localhost:3001"}/api/v1/notify`, {
              url: website_url,
              id: website_id
            });
            await prisma.website_tick.create({
              data: {
                response_time_ms: response_time,
                status: "DOWN",
                website_id,
                region_id: REGION_ID
              }
            });
          } catch (dbError) {
            console.log(`Failed to save DOWN status for ${website_url}:`, dbError);
          }
          resolve();
        });
      });
    });
    await Promise.all(promise);
    await xAckBulk(REGION_ID, data[0].messages);
  }
}
main();
